аннотация: книга посвящена внутреннему устройству и алгоритмам работы основных компонентов операционной системы - 2003, и 2000 - и файловой системы . детально рассмотрены системные механизмы: диспетчеризация ловушек и прерываний, , , , , синхронизация, системные рабочие потоки, глобальные флаги и др. также описываются все этапы загрузки операционной системы и завершения ее работы. четвертом издании книги больше внимания уделяется глубокому анализу и устранению проблем, из-за которых происходит крах операционной системы или из-за которых ее не удается загрузить. кроме того, рассматриваются детали реализации поддержки аппаратных платформ 64 и 64. книга состоит из 14 глав, словаря терминов и предметного указателя. книга предназначена системным администраторам, разработчикам серьезных приложений и всем, кто хочет понять, как устроена операционная система .
 названия всех команд, диалоговых окон и других интерфейсных элементов операционной системы приведены как на английском языке, так и на русском.
 версия 2 редакции - 1.5 . об ошибках просьба сообщать по адресу - 2008@..
---------------------------------------------
 м.руссинович, д.соломон
 внутреннее устройство (главы 1-4)
 2003, и 2000
 4-е издание 
предыстория
 я вновь признателен дэвиду соломону ( ) и марку руссиновичу ( ) за то, что они предоставили мне возможность сказать несколько слов о новом издании их книги «внутреннее устройство ». прошло уже более трех лет с момента выхода последнего издания этой книги, и за это время на свет появились два выпуска операционной системы - очень значимые обновления клиентской и серверной систем.
 перед авторами стояли две задачи, которые постоянно усложняются: отслеживание эволюционного развития системы и документирование того, как менялась реализация ее компонентов в каждой версии. этом смысле авторы проделали просто выдающуюся работу.
 (слева направо) дэвид соломон, дэвид катлер и марк руссинович 
 впервые я познакомился с дэвидом соломоном, когда ему было всего 16 лет, а я работал в над операционной системой для . тех пор он участвовал в разработке операционных систем, а также преподавал в этой области. марком руссиновичем я познакомился позже, но уже задолго до этого был немало наслышан о его глубоких познаниях в области операционных систем. числе его заслуг версия файловой системы , которую он заставил работать в 98, и «живой» отладчик ядра , позволяющий заглянуть внутрь системы в процессе ее выполнения.
 истоки восходят к октябрю 1988 года, когда было решено создать переносимую операционную систему, совместимую с /2, поддерживающую и многопроцессорную обработку, обладающую высокой защищенностью, надежностью и интегрированными средствами работы в сетях. приходом 3.0 и ее колоссальным успехом заявленные цели несколько изменились: совместимость с /2 была перенесена с уровня всей системы на уровень отдельной подсистемы.
 поначалу мы полагали, что сумеем создать за пару лет, но в действительности ее первая версия вышла лишь через четыре с половиной года - летом 1993-го. эта версия поддерживала процессоры 386, 486 и 4000. шесть недель спустя мы ввели поддержку и для процессоров .
 первая версия получилась более громоздкой и медленной, чем ожидалось, так что следующей вехой стал проект (так называется автострада во флориде). главной целью в этой версии было уменьшение размера системы, повышение ее быстродействия и, разумеется, надежности. через полгода после выпуска 3.5 осенью 1994-го мы подготовили 3.51, которая представляла собой обновленную версию с дополнительной поддержкой процессора .
 толчком к созданию следующей версии стало желание сделать пользовательский интерфейс, совместимый с 95, и включить технологии , уже находившиеся в разработке пару лет. создание этой системы ушло еще два года, и летом 1996 года была представлена 4.0.
 название следующей версии было изменено на 2000. она стала последней системой, для которой одновременно выпускались клиентская и серверная версии. 2000 была построена на той же технологии , что и предыдущие версии, но обладала новой важной функциональностью, поддерживая, в частности, . разработку 2000 ушло три с половиной года, и на тот период она была самой оптимизированной и наиболее тщательно протестированной версией технологии 2000 стала кульминацией более чем одиннадцатилетних разработок, реализованных на четырех архитектурах.
 конце разработки 2000 мы приступили к работе над амбициозным планом реализации новых версий клиентской и серверной систем, которые должны были предоставить новые, более совершенные возможности потребителям и улучшить характеристики серверов. потом стало ясно, что реализация серверных средств привела бы к задержке в реализации клиентских, и поэтому было решено разделить выпуски. августе 2001 года на свет появились и , через год с небольшим, в марте 2003 года была выпущена 2003. помимо архитектуры 86, эти системы поддерживали 64, благодаря чему впервые вышла на стезю 64-разрядных вычислений.
 эта книга единственная, где так глубоко и полно рассмотрены внутренние структуры и принципы функционирования и 
 2003. кроме того, она предлагает заглянуть в будущее - перевод на 64-разрядные «рельсы», т. е. на ее поддержку архитектур 64 (64) и 64, объявленных в 2003 году и в феврале 2004 года соответственно. выпуск клиентской и серверной версий с полной поддержкой 64 запланирован на первую половину 2005 года, и в этой книге содержится масса информации о внутренних деталях реализации х64-системы.
 архитектура х64 - это начало новой эры для в тот момент, когда время архитектуры 86 подходит к концу. архитектура 64 обеспечивает совместимость с 32-разрядной х86-платформой и предоставляет 64-разрядную адресацию для наиболее требовательных, совершенно новых приложений. это позволит сохранить инвестиции в 32-разрядное программное обеспечение, в то же время вдохнув новую жизнь в на ближайшее десятилетие или даже на более длительный период.
 хотя название -системы за последние несколько лет неоднократно менялось, она по-прежнему полностью основана на исходной кодовой базе . время бежит, появляются новые технологии, и реализация многих внутренних компонентов и функций значительно изменилась. авторы проделали внушительную работу, собрав столько детальной информации о кодовой базе и ее реализациях в разных выпусках на разных платформах, а также создав примеры и утилиты, которые помогают читателю разобраться в том, как работают компоненты и подсистемы . экземпляр этой книги должен лежать на столе у каждого разработчика серьезного программного обеспечения.
 дэвид . катлер, заслуженный старший инженер корпорации 
предисловие
 была частью моей жизни целых 14 лет. за это время - от версии к версии - наша операционная система развивалась вширь и вглубь. сегодня работа над - один из самых важных и сложных проектов в мире. выпуске участвуют более 5000 инженеров. среди пользователей есть представители уже почти всех культур, она используется как на крупных предприятиях, так и маленькими детьми. пользователи постоянно требуют ее совершенствования практически во всех сферах - от эффективной работы на крупнейших серверах до применения в дошкольном обучении. поставляется в самых разных ипостасях - от встраиваемых версий и выпусков для медиа-центров до редакций для центров обработки данных. все эти продукты опираются на одни и те же базовые компоненты , которые развиваются и совершенствуются в каждой новой версии.
 это фундаментальная книга о внутреннем устройстве базовых компонентов . если вы хотите как можно быстрее освоить принципы внутренней работы , тогда эта книга для вас. освоение всех частей столь основательного продукта - задача устрашающая. если вы начнете с базовых концепций системы, сложить фрагменты головоломки воедино будет гораздо легче. эволюцией самой развивается и эта книга - сейчас публикуется ее четвертое издание. мы уже давно используем ее для обучения новых сотрудников , так что предлагаемые вам материалы проверены на практике.
 если вы вроде меня, значит, вам тоже нравится разбираться в том, как устроены вещи. чтение книжек типа «как использовать то-то и то-то» меня никогда не удовлетворяло. когда понимаешь, как именно устроена вещь, пользуешься ею гораздо эффективнее и, честно говоря, с большим удовольствием. если вас интересует «с изнанки», вы выбрали подходящую книгу.
 дэвид и марк проделали превосходную работу, написав книгу о технической «изнанке» . инструменты, которые они предлагают вам, - отличное средство для самостоятельного обучения и диагностики. прочитав эту книгу, вы будете гораздо лучше понимать, как взаимодействуют между собой различные компоненты и подсистемы, какие усовершенствования внесены в новую версию и как выжать из них максимум возможного.
 это был долгий путь - и он все еще продолжается. так что открывайте книгу, а заодно и капот, под которым бьется сердце одной из самых потрясающих операционных систем.
 джим олчин, вице-президент группы платформ корпорации 
благодарности
 первую очередь мы хотим особо поблагодарить следующих людей.
  дэйва катлера ( ), заслуженного старшего инженера и первого архитектора . дэйв разрешил дэвиду соломону ( ) доступ к исходному коду и всячески поддерживал его преподавательскую деятельность, посвященную объяснению деталей внутреннего устройства , а также его работу над вторым и третьим изданием книги. помимо рецензирования главы по процессам и потокам, дэйв ответил на массу вопросов об архитектуре ядра и написал об истории создания для нашей книги.
  джима олчина ), нашего главного спонсора, - за предисловие к этой книге и за отстаивание интересов нашего дела в .
  роба шорта ( ), вице-президента, который позаботился о том, чтобы нам предоставили ресурсы и доступ к нужным людям.
 мы также выражаем признательность двум разработчикам из отдела за подготовку новых материалов, включенных в это издание:
  адриану маринеску ( ), который написал заметно разросшийся раздел по диспетчеру куч в главе, где рассматривается диспетчер памяти.
  самеру арафеху ( ), который предоставил материалы по 64.
 спасибо нашему старому приятелю, джеффри рихтеру ), с которым мы часто вместе обедаем, за врезку «как насчет. и ?» в главе 1 и за постоянное напоминание о том, как мало людей, по-настоящему интересующихся тем, о чем мы говорим в своей книге.
 этой книге не было бы такой глубины и точности изложения технических сведений без поддержки, замечаний и предложений ключевых членов команды разработчиков . вот эти люди:
 были и другие, кто отвечал на наши вопросы в коридорах или кафетериях, - если мы вас пропустили, пожалуйста, простите нас!
 мы также выражаем благодарность джейми ханрахан ) из (..), которая в соавторстве с дэвидом подготовила учебный курс по внутренней архитектуре исходной версии . основе этого курса было написано второе издание этой книги. джейми, у которой настоящий талант доходчиво объяснять сложнейшие вещи, предоставила нам отдельные материалы, а также ряд схем и иллюстраций.
 спасибо дэйву проберту ( ) за то, что разместил в сети наши черновые материалы для распространения среди рецензентов внутри .
 благодарим джонатана славза ( ) из , с помощью которого нам предоставили тестовые системы 64; они очень помогли нам в написании материалов по 64-разрядной архитектуре и в переносе ряда утилит на платформу 64.
 наконец, мы хотим выразить благодарность следующим сотрудникам за их вклад в эту книгу.
  робину ван-штеенбергу ( ), рецензенту издательства, за терпение в работе с нами над этим проектом.
  салли стикни ( ), которая на первых порах по-прежнему была редактором нашего проекта, но потом ее закрутил водоворот административных дел. мы очень скучали без вас!
  валери вулли ( ), которая приняла бразды правления от салли и стала нашим новым редактором проекта. вы замечательная и не такая резкая, как салли!
  роджеру лебланку ( ), который одолел все главы и сумел сократить в них текст, найти несогласованности и вообще довести нашу рукопись до высоких стандартов .
 дэвид соломон и марк руссинович сентябрь 2004 г. 
введение
 четвертое издание этой книги ориентировано на квалифицированных специалистов (программистов, разработчиков и системных администраторов), желающих разобраться в принципах внутренней работы основных компонентов операционных систем 2000, и 2003. зная их, разработчики смогут принимать более эффективные решения на этапах проектирования приложений для платформы . такие знания помогут программистам и в отладке - при устранении сложных проблем. информация, изложенная в книге, будет также полезна системным администраторам: понимание того, как устроена и работает операционная система, упростит им оптимизацию своих систем и устранение неполадок в случае каких-либо сбоев. прочитав эту книгу, вы лучше поймете, как функционирует и почему она ведет себя именно так, а не как-то иначе.
структура книги
 первые две главы закладывают фундамент, вводя термины и концепции, используемые во всей книге. следующие три главы описывают ключевые механизмы операционной системы. следующих восьми главах детально рассматриваются базовые компоненты - процессы, потоки и задания, управление памятью, защита, подсистема ввода-вывода, управление внешней памятью, диспетчер кэша, файловые системы и поддержка сетей. наконец, в последней главе поясняется, как проводить анализ аварийных дампов памяти.
история написания книги
 это четвертое издание книги, которая изначально называлась « » ( , 1992) и была написана хелен кастер ( ) еще до выпуска 3.1. она стала первой книгой по и представляла собой глубокий обзор архитектуры этой системы. второе издание, « » ( , 1998), было написано дэвидом соломоном. него вошла новая информация по 4.0, а сама книга стала гораздо более глубокой. третье издание, « 2000» ( , 2000), было подготовлено дэвидом соломоном и марком руссиновичем. нем появилось много новых тематических разделов, в том числе по этапам загрузки и завершения работы системы, внутреннему устройству сервисов и реестра, по драйверам файловых систем, поддержке сетей, а также по новой функциональности ядра 2000, например модели , , , шифрованию, и др.
особенности четвертого издания
 новое издание дополнено информацией об изменениях в ядре, которые были внесены в и 2003, в том числе касающихся поддержки 64-разрядных систем. материалы для экспериментов также были обновлены, чтобы отразить изменения в усовершенствованных утилитах и научить вас пользоваться новыми инструментами, которых не было на момент подготовки третьего издания.
 так как отличия новых версий от 2000 относительно невелики (по сравнению с различиями между 4.0 и 2000), основная часть книги равно применима к 2000, и 2003. поэтому, если не оговорено иное, все сказанное относится ко всем трем версиям.
инструменты для проведения экспериментов
 даже без доступа к исходному коду существующие инструменты вроде отладчика ядра позволяют многое прояснить во внутреннем устройстве . том месте, где для демонстрации какого-либо аспекта поведения используется тот или иной инструмент, во врезке «эксперимент» даются инструкции по его применению. такие врезки часто встречаются в книге, и мы рекомендуем вам проделывать эти эксперименты в процессе чтения: наглядно увидев, как ведет себя в конкретной ситуации, вы гораздо лучше усвоите прочитанный материал.
тематика, не рассматриваемая в книге
 - большая и сложная операционная система. нельзя объять необъятное, и поэтому основное внимание в книге уделяется только базовым системным компонентам. например, мы не рассматриваем +, инфраструктуру объектно-ориентированного программирования распределенных приложений для , или. , платформу для следующего поколения приложений с управляемым кодом.
 поскольку наша книга о внутреннем устройстве , а не о том, как пользоваться этой операционной системой, программировать для нее или администрировать системы, созданные на ее основе, вы не найдете здесь никаких сведений об использовании, программировании и конфигурировании .
подводные камни
 книге описываются недокументированные внутренние структуры и функции ядра, архитектура и различные аспекты внутренней работы , и часть таких структур и функций может измениться в следующем выпуске этой операционной системы. (впрочем, внешние интерфейсы вроде всегда сохраняют совместимость с аналогичными интерфейсами в очередных выпусках.)
 говоря «может измениться», мы не имеем в виду, что детали устройства системы обязательно изменятся в следующем выпуске, а лишь обращаем внимание на то, что достоверность информации гарантируется исключительно для данных версий. любое программное обеспечение, использующее недокументированные интерфейсы, может перестать работать в будущих версиях . более того, такое программное обеспечение, если оно работает в режиме ядра (как, например, драйверы устройств), может привести к краху более новых версий .
техническая поддержка
 мы приложили максимум усилий, чтобы не допустить неточностей и ошибок в книге. если у вас возникнут какие-либо проблемы или вопросы, пожалуйста, обращайтесь по адресам, указанным в следующих двух разделах.
от авторов
 эта книга отнюдь не совершенна. несомненно в ней есть какие-то неточности; может быть, мы упустили что-то важное. если вы найдете то, что считаете ошибочным, или если вы сочтете, что в книгу следует включить дополнительный материал, пожалуйста, пошлите свое сообщение по адресу @. . обновления и исправления будут выкладываться на страницу ./* 
от 
 публикует исправления к книгам по адресу ://.//. для прямого подключения к и ввода запроса по проблеме, с которой вы столкнулись, заходите на страницу ://..//. .
 переводе учтены исправления, опубликованные на этой -странице, по состоянию на 1 июля 2005 года. - прим. перев. 
 гл 1  концепции и инструменты
 этой главе мы познакомим вас с основными концепциями и терминами операционной системы , которые будут использоваться в последующих главах, в том числе с , процессами, потоками, виртуальной памятью, режимом ядра и пользовательским режимом, объектами, описателями (), защитой, реестром. мы также расскажем об инструментах, с помощью которых вы сможете исследовать внутреннее устройство . ним относятся, например, отладчик ядра, оснастка и важнейшие утилиты с сайта .. . кроме того, мы поясним, как пользоваться () и () в качестве источника дополнительной информации о внутреннем устройстве .
 вы должны хорошо понимать все, что написано в этой главе, - в остальной части книги мы предполагаем именно так.
версии операционных систем 
 эта книга охватывает три последние версии операционной системы , основанные на кодовой базе : 2000, (32- и 64-разрядные версии) и 2003 (32- и 64-разрядные версии). текст относится ко всем трем версиям, если не оговорено иное. таблице 1-1 перечислены выпуски кодовой базы , номера версий и названия продуктов.
 и 95
 при первом выпуске компания дала ясно понять, что это долгосрочная замена 95 (и ее последующих выпусков - 98 и ). вот список некоторых архитектурных различий и преимуществ (и ее последующих выпусков) над 95 (и ее последующими выпусками).
  поддерживает многопроцессорные системы, 95 - нет.
  файловая система поддерживает средства защиты, например управление избирательным доступом ( ). файловой системе 95 этого нет.
  - полностью 32-разрядная (а теперь и 64-разрядная) операционная система, в ней нет 16-разрядного кода, кроме того, который предназначен для выполнения 16-разрядных -приложений. 95 содержит большой объем старого 16-разрядного кода из предшествующих операционных систем - 3.1 -.
  полностью реентерабельна, а многие части 95 нереентерабельны (в основном это касается 16-разрядного кода, взятого из 3.1 ). большинство функций, связанных с графикой и управлением окнами ( и ), включают именно нереентерабельный код. когда 32-разрядное приложение в 95 пытается вызвать системный сервис, реализованный как нереентерабельный 16-разрядный код, оно должно сначала получить общесистемную блокировку (или мьютекс), чтобы предотвратить вход других потоков в нереентерабельную кодовую базу. еще хуже, что 16-разрядное приложение удерживает такую блокировку в течение всего времени своего выполнения. итоге, хотя ядро 95 содержит 32-разрядный планировщик с поддержкой мно-гопоточности и вытесняющей многозадачности, приложения часто работают как однопоточные из-за того, что большая часть системы реализована как нереентерабельный код.
  позволяет выполнять 16-разрядные -приложения в выделенном адресном пространстве, 95 всегда выполняет такие приложения в общем адресном пространстве, в котором они могут навредить друг другу и привести к зависанию системы.
  разделяемая (общая) память процесса в видна только тем процессам, которые имеют проекцию на один и тот же блок разделяемой памяти. 95 вся общая память видна и доступна для записи всем процессам. таким образом, любой процесс может что-то записать и повредить какие-то данные в общей памяти, используемые другими процессами.
  некоторые критически важные страницы памяти, занимаемые операционной системой 95, доступны для записи из пользовательского режима, а значит, обычное приложение может повредить содержимое этих страниц и привести к краху системы. единственное, что умеет 95 и чего никогда не смогут делать операционные системы на основе , - выполнять все старые программы для - и 3.1 (а именно программы, требующие прямого доступа к оборудованию), а также 16-разрядные драйверы устройств -. если одной из основных целей разработки 95 была 100 %-я совместимость с - и 3.1, то исходной целью разработки - возможность выполнения большинства существующих 16-разрядных приложений при условии сохранения целостности и надежности системы.
базовые концепции и термины
 книге будут часто встречаться ссылки на концепции и структуры, с которыми некоторые читатели, возможно, не знакомы. здесь мы определимся с используемой в дальнейшем терминологией.
 
 это системный интерфейс программирования в семействе операционных систем , включая 2000, , 2003, 95, 98, () и . каждая операционная система реализует разное подмножество . 95, 98, и в этой книге не рассматриваются.
 примечание описывается в документации (). (см. раздел « ()» далее в этой главе.) этудокументацию можно бесплатно просмотреть на сайте ... она также поставляется с () всех уровней подписки. ( - это программа для поддержки разработчиков. подробности см. на сайте ...) отличное описание того, как программировать с использованием базового , см. в четвертом издании книги джеффри рихтера ) « для профессионалов» (русская редакция, 2000). 
 до появления 64-разрядных версий и 2003 интерфейс программирования 32-разрядных версий операционных систем назывался 32 , чтобы отличать его от исходного 16-разрядного . этой книге термин « » относится к 32-разрядному интерфейсу программирования 2000, а также к 32- и 64-разрядным интерфейсам программирования и 2003.
 включает тысячи вызываемых функций, которые сгруппированы в следующие основные категории:
  базовые сервисы ( );
  сервисы компонентов ( );
  сервисы пользовательского интерфейса ( );
  сервисы графики и мультимедиа ( );
  коммуникационное взаимодействие и совместная работа ( );
  сети ();
  -сервисы ( ).
 основное внимание в нашей книге уделяется внутреннему устройству ключевых базовых сервисов, в частности поддержки процессов и потоков (), управления памятью, ввода-вывода и защиты.
как насчет. и ?
 состоит из библиотеки классов, называемой (), и общеязыковой исполняющей среды ( , ), которая предоставляет среду для выполнения управляемого кода с такими возможностями, как компиляция по требованию (-- , ), верификация типов, сбор мусора и защита по правам доступа кода ( ). благодаря этому создает среду разработки, которая повышает продуктивность труда программистов и уменьшает вероятность появления распространенных ошибок программирования. отличное описание. и ее базовой архитектуры см. в книге джеффри рихтера «программирование на платформе . -» (русская редакция, 2003).
 реализована как классический сом-сервер, код которой хранится в стандартной пользовательского режима. фактически все компоненты. реализованы как стандартные пользовательского режима, занимающие уровень поверх неуправляемых функций (никакие компоненты. не работают в режиме ядра.) рис. 1-1 показаны взаимосвязи этих компонентов.
 - «новый ». это результат эволюционного развития. , которая будет поставляться с версией под кодовым названием «», следующим выпуском . также можно установить в и 2003. образует фундамент для приложений следующего поколения, создаваемых для операционной системы .
история создания 32 
 интересно, что поначалу 32 не рассматривался как интерфейс программирования для . поскольку проект начинался как замена /2 версии 2, основным интерфейсом программирования был 32-разрядный /2 . однако год спустя на рынке появилась 3.0, быстро ставшая очень популярной. результате сменила курс и перенацелила проект на будущую замену семейства продуктов , а не /2. вот на этом-то перепутье и встал вопрос о создании - до этого существовал только как 16-разрядный интерфейс.
 хотя в должно было появиться много новых функций, отсутствующих в 3.1, решила сделать новый по возможности совместимым с именами функций, семантикой и типами данных в 16-разрядном , чтобы максимально облегчить бремя переноса существующих 16-разрядных -приложений в поэтому тот, кто, впервые глядя на , удивляется, почему многие имена и интерфейсы функций кажутся противоречивыми, должен учитывать, что одной из причин такой противоречивости было стремление сделать совместимым со старым 16-разрядным .
сервисы, функции и процедуры
 несколько терминов в документации для пользователей и программистов имеет разный смысл в разных контекстах. например, понятие «сервис» () может относиться к вызываемой функции операционной системы, драйверу устройства или серверному процессу (в последнем случае сервис часто называют службой). ниже показано, что означают подобные термины в этой книге.
  функции документированные, вызываемые подпрограммы в , например , и . 
  неуправляемые («родные») системные сервисы (или исполняемые системные сервисы) недокументированные низкоуровневые сервисы операционной системы, которые можно вызывать в пользовательском режиме. так, - это внутрисистемный сервис, вызываемый -функцией при создании нового процесса. (определение неуправляемых функций см. в разделе «диспетчеризация системных сервисов» главы 3.)
  функции (или процедуры) ядра подпрограммы внутри операционной системы , которые можно вызывать только в режиме ядра (определение мы дадим чуть позже). например, - процедура, вызываемая драйверами устройств для выделения памяти из системных куч (динамически распределяемых областей памяти) .
  -сервисы процессы, запускаемые диспетчером управления сервисами в . (хотя в документации на реестр драйверы устройств определяются как сервисы, мы не пользуемся таким термином в этой книге.) например, сервис выполняется в процессе пользовательского режима, который поддерживает команду (аналогичную -команде или ). 
  (динамически подключаемая библиотека) набор вызываемых подпрограмм, включенных в один двоичный файл, который приложения, использующие эти подпрограммы, могут динамически загружать во время своего выполнения. качестве примера можно привести модули . (библиотека исполняющей подсистемы ) и 32. (одна из библиотек подсистемы ). активно используются компонентами и приложениями пользовательского режима. преимущество над статическими библиотеками в том, что приложения могут разделять -модули, гарантирует, что в памяти будет находиться лишь по одному экземпляру используемых .
процессы, потоки и задания
 хотя на первый взгляд кажется, что программа и процесс - понятия практически одинаковые, они фундаментально отличаются друг от друга. программа представляет собой статический набор команд, а процесс - это контейнер для набора ресурсов, используемых при выполнении экземпляра программы. самом высоком уровне абстракции процесс в включает следующее:
  закрытое виртуальное адресное пространство - диапазон адресов виртуальной памяти, которым может пользоваться процесс;
  исполняемую программу - начальный код и данные, проецируемые на виртуальное адресное пространство процесса;
  список открытых описателей () различных системных ресурсов - семафоров, коммуникационных портов, файлов и других объектов, доступных всем потокам в данном процессе;
  контекст защиты ( ), называемый маркером доступа ( ) и идентифицирующий пользователя, группы безопасности и привилегии, сопоставленные с процессом;
  уникальный идентификатор процесса (во внутрисистемной терминологии называемый идентификатором клиента);
  минимум один поток.
 каждый процесс также указывает на свой родительский процесс (процесс-создатель). однако, если родитель существует, эта информация не обновляется. поэтому есть вероятность, что некий процесс указывает на уже несуществующего родителя. это не создает никакой проблемы, поскольку никто не полагается на наличие такой информации. следующий эксперимент иллюстрирует данный случай.
 эксперимент: просмотр дерева процессов 
 большинство утилит не отображает такой уникальный атрибут, как идентификатор родительского процесса. значение этого атрибута можно получить программно или с помощью оснастки , запросив значение счетчика [код () создавшего процесса]. дерево процессов показывается утилитой . (из ), если вы указываете ключ /. вот образец вывода этой команды:
 взаимоотношения процессов (дочерний-родительский) показывает отступами. имена процессов, родительские процессы которых на данный момент завершились, выравниваются по левому краю, потому что установить их родственные связи невозможно - даже если процессы-прапредки еще существуют. сохраняет идентификатор только родительского процесса, так что проследить его создателя нельзя. чтобы убедиться в этом, выполните следующие операции.
 1. откройте окно командной строки.
 2. наберите для запуска второго окна командной строки.
 3. откройте диспетчер задач.
 4. переключитесь на второе окно командной строки.
 5. введите для запуска .
 6. щелкните второе окно командной строки.
 7. введите . (заметьте, что окно остается.)
 8. переключитесь в диспетчер задач.
 9. откройте его вкладку (приложения). 
 10.щелкните правой кнопкой мыши задачу (командная строка) и выберите (перейти к процессам).
 11. щелкните процесс ., выделенный серым цветом.
 12. щелкнув правой кнопкой мыши, выберите команду 
 (завершить дерево процессов).
 13.  окне (предупреждение диспетчера задач) щелкните (да).
 первое окно командной строки исчезнет, но вы по-прежнему сможете наблюдать окно , так как оно является внуком первого из завершенных процессов . поскольку второй (родительский процесс ) тоже завершен, связь между родителем и внуком потеряна.
 для просмотра (и модификации) процессов и информации, связанной с ними, существует целый набор утилит. следующие эксперименты демонстрируют, как получить ту или иную информацию о процессе с помощью некоторых из этих утилит. они включаются непосредственно в саму , а также в , , ресурсы и . многие из этих утилит выводят перекрывающиеся подмножества информации о базовых процессах и потоках, иногда идентифицируемые по разным именам.
 вероятно, наиболее широко применяемая утилита для анализа активности процессов - (диспетчер задач). (любопытно, что в ядре нет такого понятия, как задача, так что на самом деле является инструментом для управления процессами.) следующий эксперимент показывает разницу между тем, что перечисляет как приложения и процессы.
 эксперимент: просмотр информации о процессах через диспетчер задач 
 диспетчер задач отображает список выполняемых в системе процессов. его можно запустить тремя способами: 1) нажав клавиши ++; 2) щелкнув панель задач правой кнопкой мыши и выбрав команду (диспетчер задач); 3) нажав клавиши ++. после запуска диспетчера задач откройте вкладку (процессы). заметьте, что процессы идентифицируются по имени образа, экземплярами которого они являются. отличие от некоторых объектов в процессам нельзя присваивать глобальные имена. для просмотра более подробных сведений выберите из меню (вид) команду (выбрать столбцы) и укажите, какая дополнительная информация вас интересует.
 если вкладка окна диспетчера задач со всей очевидностью показывает список процессов, то содержимое вкладки (приложения) нуждается в пояснениях. ней отображается список видимых окон верхнего уровня всех объектов «рабочий стол» интерактивного объекта . (по умолчанию существуют два объекта «рабочий стол», но вы можете создать дополнительные рабочие столы через -функцию .) колонка (состояние) дает представление о том, находится ли поток - владелец окна в состоянии ожидания -сообщения. «» («выполняется») означает, что поток ожидает ввода в окно, « » (« отвечает») - что не ожидает (т. е. занят либо ждет завершения операции ввода-вывода или освобождения какого-либо синхронизирующего объекта).
 вкладка позволяет идентифицировать процесс, которому принадлежит поток, владеющий каким-либо окном задачи. для этого щелкните правой кнопкой мыши имя задачи и выберите команду (перейти к процессам).
 утилита показывает больше информации о процессах и потоках, чем любой другой доступный инструмент; вот почему она используется нами во многих экспериментах, которые вы увидите в этой книге. ниже перечислены некоторые уникальные сведения, выводимые утилитой , и ее возможности:
  полное имя (вместе с путем) выполняемого образа;
  маркер защиты процесса (список групп и привилегий);
  выделение изменений в списке процессов и потоков;
  список сервисов внутри процессов - хостов сервисов с выводом отображаемого имени ( ) и описания;
  процессы, которые являются частью задания, и детальные сведения о заданиях;
  процессы, выполняющие. /-приложения, и сведения, специфичные для. (например, список доменов приложений и счетчики производительности, относящиеся к );
  время запуска процессов и потоков;
  полный список файлов, проецируемых в память (не только -модулей);
  возможность приостановки процесса;
  возможность принудительного завершения индивидуальных потоков;
  простота выявления процессов, использующих наибольшую долю процессорного времени за определенный период. (оснастка позволяет просматривать процент использования процессора для заданного набора процессов, но не показывает автоматически процессы, созданные после начала сеанса мониторинга.)
 также упрощает доступ к информации, предоставляемой другими утилитами, создавая единую точку ее просмотра:
  дерево процессов с возможностью свертывания отдельных частей этого дерева;
  открытые описатели в процессе без предварительной настройки (утилиты для вывода открытых описателей требуют предварительной установки общесистемного флага и перезагрузки);
  список (и файлов, проецируемых в память) в каком-либо процессе;
  активность потоков в каком-либо процессе;
  стеки потоков пользовательского режима (с сопоставлением адресов именам, используя механизм поддержки символов для инструментов отладки);
  стеки системных потоков режима ядра (с сопоставлением адресов именам, используя механизм поддержки символов для инструментов отладки);
  разница в переключении контекстов ( ) (более наглядное представление активности процессора, как поясняется в главе 6);
  лимиты памяти режима ядра (пулов подкачиваемой и неподкачиваемой памяти) (остальные утилиты показывают только текущие размеры). попробуем провести первый эксперимент с помощью .
 эксперимент: просмотр детальных сведений о процессах с помощью 
 скачайте последнюю версию и запустите ее. при первом запуске вы увидите сообщение о том, что на данный момент символы не сконфигурированы. когда они корректно сконфигурированы, может обращаться к символьной информации для отображения символьного имени стартовой функции потока и функций в его стеке вызовов (для этого нужно дважды щелкнуть процесс и выбрать вкладку ). эта информация полезна для идентификации того, что именно делают потоки внутри процесса. для доступа к символам вы должны установить (об этом мы еще поговорим в данной главе). потом щелкнуть , выбрать и набрать подходящий путь . например:
 предыдущем примере для доступа к символам использовался сервер символов по требованию (- ), а копии файлов символов хранились на локальном компьютере в папке : \. подробнее о конфигурировании сервера символов см. по ссылке :/ /..////. .
 при запуске по умолчанию выводит список процессов в верхней половине окна, а список открытых описателей для выбранного на данный момент процесса - в нижней половине. если вы задержите курсор мыши над именем процесса, также показывает описание образа, название компании и полный путь.
 вот как использовать некоторые базовые возможности :
 1. отключите нижнюю секцию, сбросив , . (нижняя секция может отображать открытые описатели или проецируемые и файлы - об этом речь пойдет в главах 3 и 7.)
 2. обратите внимание на то, что процессы, являющиеся хостами сервисов, по умолчанию выделяются розовым цветом. ваши собственные процессы выделяются синим. (эти цвета можно настроить.)
 3. задержите курсор мыши над именем образа и обратите внимание на то, что в подсказке отображается полный путь.
 4. щелкните , и добавьте путь образа.
 5. отсортируйте по колонке процессов и вы увидите, что представление в виде дерева исчезло. (вы можете либо вывести представление в виде дерева, либо сортировать по любой из отображаемых колонок.) снова щелкните для сортировки по алфавиту в обратном порядке (от к а). после этого очередной щелчок вернет представление в виде дерева.
 6. сбросьте , для отображения только ваших процессов.
 7. перейдите в , и смените значение на 5 секунд. потом запустите новый процесс (какой угодно) и обратите внимание на то, что этот процесс выделяется зеленым в течение 5 секунд. закройте новый процесс и заметьте, что этот процесс выделяется красным в течение 5 секунд, прежде чем исчезнуть из древовидного списка. эта функция может пригодиться для обнаружения создаваемых и завершаемых процессов в системе.
 8. наконец, дважды щелкните какой-нибудь процесс и изучите вкладки, доступные в окне свойств процесса. (эти вкладки понадобятся нам в дальнейших экспериментах; там же мы поясним, какую информацию они сообщают.)
 поток () - некая сущность внутри процесса, получающая процессорное время для выполнения. без потока программа процесса не может выполняться. поток включает следующие наиболее важные элементы:
  содержимое набора регистров процессора, отражающих состояние процессора;
  два стека, один из которых используется потоком при выполнении в режиме ядра, а другой - в пользовательском режиме;
  закрытую область памяти, называемую локальной памятью потока (- , ) и используемую подсистемами, библиотеками исполняющих систем (- ) и ;
  уникальный идентификатор потока (во внутрисистемной терминологии также называемый идентификатором клиента: идентификаторы процессов и потоков генерируются из одного пространства имен и никогда не перекрываются);
  иногда потоки обладают своим контекстом защиты, который обычно используется многопоточными серверными приложениями, подменяющими контекст защиты обслуживаемых клиентов.
 переменные регистры, стеки и локальные области памяти называются контекстом потока. поскольку эта информация различна на каждой аппаратной платформе, на которой может работать , соответствующая структура данных специфична для конкретной платформы. -функция предоставляет доступ к этой аппаратно-зависимой информации (называемой блоком ).
волокна и потоки
 волокна () позволяют приложениям планировать собственные «потоки» выполнения, не используя встроенный механизм планирования потоков на основе приоритетов. волокна часто называют «облегченными» потоками. они невидимы ядру, так как 32. реализует их в пользовательском режиме. для использования волокна нужно вызвать -функцию , которая преобразует поток в волокно. полученное волокно может создавать дополнительные волокна через функцию (у каждого волокна может быть свой набор волокон). выполнение волокна (в отличие от потока) не начинается до тех пор, пока оно не будет вручную выбрано вызовом . волокно работает до завершения или до переключения процессора на другое волокно вызовом все той же . подробнее о функциях, связанных с волокнами, см. документацию .
 хотя у потоков свой контекст выполнения, каждый поток внутри одного процесса делит его виртуальное адресное пространство (а также остальные ресурсы, принадлежащие процессу). это означает, что все потоки в процессе могут записывать и считывать содержимое памяти любого из потоков данного процесса. однако потоки не могут случайно сослаться на адресное пространство другого процесса. исключение возможно в ситуации, когда тот предоставляет часть своего адресного пространства как раздел общей памяти ( ), в называемый объектом «проекция файла» ( ), или когда один из процессов имеет право на открытие другого процесса и использует функции доступа к памяти между процессами, например и . 
 кроме закрытого адресного пространства и одного или нескольких потоков у каждого процесса имеются идентификация защиты и список открытых описателей таких объектов, как файлы и разделы общей памяти, или синхронизирующих объектов вроде мьютексов, событий и семафоров (рис. 1-2).
 каждый процесс обладает контекстом защиты, который хранится в объекте - маркере доступа. маркер доступа содержит идентификацию защиты и определяет полномочия данного процесса. по умолчанию у потока нет собственного маркера доступа, но он может получить его, и это позволит ему подменять контекст защиты другого процесса (в том числе выполняемого на удаленной системе ). подробнее на эту тему см. главу 8.
 дескрипторы виртуальных адресов ( , ) - это структуры данных, используемые диспетчером памяти для учета виртуальных адресов, задействованных процессом (см. главу 7).
 предоставляет расширение для модели процессов - задания (). они предназначены в основном для того, чтобы группами процессов можно было оперировать и управлять как единым целым. объект-задание позволяет устанавливать определенные атрибуты и накладывать ограничения на процесс или процессы, сопоставленные с заданием. этом объекте также хранится информация обо всех процессах, которые были сопоставлены с заданием, но к настоящему времени уже завершены. каких-то отношениях объект-задание компенсирует отсутствие иерархического дерева процессов в , а в каких-то - даже превосходит по своим возможностям дерево процессов .
 более детальное описание внутренней структуры заданий, процессов и потоков, механизмов создания потоков и процессов, а также алгоритмов планирования потоков вы найдете в главе 6.
виртуальная память
 реализована система виртуальной памяти, основанная на плоском (линейном) адресном пространстве. она создает каждому процессу иллюзию того, что у него есть собственное большое и закрытое адресное пространство. виртуальная память дает логическое представление, не обязательно соответствующее структуре физической памяти. период выполнения диспетчер памяти, используя аппаратную поддержку, транслирует, или проецирует (), виртуальные адреса на физические, по которым реально хранятся данные. управляя проецированием и защитой страниц памяти, операционная система гарантирует, что ни один процесс не помешает другому и не сможет повредить данные самой операционной системы. рис. 1-3 показано, как три смежные страницы виртуальной памяти проецируются на три разрозненные страницы физической памяти.
 поскольку у большинства компьютеров объем физической памяти намного меньше общего объема виртуальной памяти, задействованной выполняемыми процессами, диспетчер памяти перемещает, или подкачивает (), часть содержимого памяти на диск. подкачка данных на диск освобождает физическую память для других процессов или самой операционной системы. когда поток обращается к странице виртуальной памяти, сброшенной на диск, диспетчер виртуальной памяти загружает эту информацию с диска обратно в память. для использования преимуществ подкачки в приложениях никакого дополнительного кода не требуется, так как диспетчер памяти опирается на аппаратную поддержку этого механизма.
 размер виртуального адресного пространства зависит от конкретной аппаратной платформы. 32-разрядных х86-системах теоретический максимум для общего виртуального адресного пространства составляет 4 гб. по умолчанию выделяет нижнюю половину этого пространства (в диапазоне адресов от 00000000 до 7) процессам, а вторую половину (в диапазоне адресов от 80000000 до ) использует в собственных целях. 2000 , 2000 , (2 и выше) и 2003 поддерживают загрузочные параметры /3 и /, которые указываются в файле . (см. главу 5), что позволяет процессам, выполняющим программы со специальным флагом в заголовке исполняемого образа, использовать до 3 гб закрытого адресного пространства и оставляет операционной системе только 1 гб. этот вариант дает возможность приложению вроде сервера базы данных хранить в адресном пространстве своего процесса большие порции базы данных и тем самым уменьшить частоту проецирования отдельных представлений этой базы. две структуры виртуальных адресных пространств, поддерживаемые 32-разрядной , показаны на рис. 1-4.
 хотя три гигабайта лучше двух, этого все равно недостаточно для проецирования очень больших баз данных. связи с этим в 32-разрядных появился механизм (), который позволяет 32-разрядному приложению выделять до 64 гб физической памяти, а затем проецировать представления (), или окна (), на свое 2-гигабайтное виртуальное адресное пространство. применение усложняет управление проекциями виртуальной памяти на физическую, но снимает проблему прямого доступа к объему физической памяти, превышающему лимиты 32-разрядного адресного пространства процесса.
 64-разрядная предоставляет процессам гораздо большее адресное пространство: 7152 гб на -системах и 8192 гб на х64-системах. рис. 1-5 показана упрощенная схема структур 64-разрядных адресных пространств (детали см. в главе 7). заметьте, что эти размеры отражают не архитектурные лимиты для данных платформ, а ограничения реализации в текущих версиях 64-разрядной .
 подробнее о реализации диспетчера памяти, в том числе о трансляции адресов и управлении физической памятью в , см. главу 7.
режим ядра и пользовательский режим
 для предотвращения доступа приложений к критически важным данным операционной системы и устранения риска их модификации использует два режима доступа к процессору (даже если он поддерживает более двух режимов): пользовательский ( ) и ядра ( ). код приложений работает в пользовательском режиме, тогда как код операционной системы (например, системные сервисы и драйверы устройств) - в режиме ядра. режиме ядра предоставляется доступ ко всей системной памяти и разрешается выполнять любые машинные команды процессора. предоставляя операционной системе более высокий уровень привилегий, чем прикладным программам, процессор позволяет разработчикам операционных систем реализовать такие архитектуры, которые не дают возможности сбойным приложениям нарушать стабильность работы всей системы.
 примечание архитектуре процессора 86 определено четыре уровня привилегий, или колец (), предназначенных для защиты кода и данных системы от случайной или умышленной перезаписи кодом с меньшим уровнем привилегий. использует уровень привилегий 0 (или кольцо 0) для режима ядра и уровень привилегий 3 (или кольцо 3) для пользовательского режима. почему использует только два уровня? дело в том, что на некоторых из ранее поддерживавшихся аппаратных платформ (например, и ) реализовано лишь два уровня привилегий. 
 хотя каждый -процесс имеет свою (закрытую) память, код операционной системы и драйверы устройств, работающие в режиме ядра, делят единое виртуальное адресное пространство. каждая страница в виртуальной памяти помечается тэгом, определяющим, в каком режиме должен работать процессор для чтения и/или записи данной страницы. страницы в системном пространстве доступны лишь в режиме ядра, а все страницы в пользовательском адресном пространстве - в пользовательском режиме. страницы только для чтения (например, содержащие лишь исполняемый код) ни в каком режиме для записи недоступны.
 не предусматривает никакой защиты системной памяти от компонентов, работающих в режиме ядра. иначе говоря, код операционной системы и драйверов устройств в режиме ядра получает полный доступ к системной памяти и может обходить средства защиты для обращения к любым объектам. поскольку основная часть кода выполняется в режиме ядра, крайне важно, чтобы компоненты, работающие в этом режиме, были тщательно продуманы и протестированы.
 это также подчеркивает, насколько надо быть осторожным при загрузке драйвера устройства от стороннего поставщика: перейдя в режим ядра, он получит полный доступ ко всем данным операционной системы. такая уязвимость стала одной из причин, по которым в введен механизм проверки цифровых подписей драйверов, предупреждающий пользователя о попытке установки неавторизованного (неподписанного) драйвера (подробнее на эту тему см. главу 9). кроме того, механизм (верификатор драйверов) помогает разработчикам драйверов устройств находить в них ошибки (вызывающие, например, утечку памяти или переполнения буферов). поясняется в главе 7.
 как вы увидите в главе 2, прикладные программы могут переключаться из пользовательского режима в режим ядра, обращаясь к системному сервису. например, -функции в ходе своего выполнения приходится вызывать внутреннюю подпрограмму - она-то и считывает данные из файла. так как эта подпрограмма обращается к внутрисистемным структурам данных, она должна выполняться в режиме ядра. переключение из пользовательского режима в режим ядра осуществляется специальной командой процессора. операционная система перехватывает эту команду, обнаруживает запрос системного сервиса, проверяет аргументы, которые поток передал системной функции, и выполняет внутреннюю подпрограмму. перед возвратом управления пользовательскому потоку процессор переключается обратно в пользовательский режим. благодаря этому операционная система защищает себя и свои данные от возможной модификации пользовательскими процессами.
 примечание переключение из пользовательского режима в режим ядра (и обратно) не влияет на планирование потока, так как контекст в этом случае не переключается. диспетчеризации системных сервисов см. главу 3. 
 так что ситуация, когда пользовательский поток часть своего времени работает в пользовательском режиме, а часть - в режиме ядра, совершенно нормальна. поскольку подсистема, отвечающая за поддержку графики и окон, функционирует в режиме ядра, то приложения, интенсивно работающие с графикой, большую часть времени действуют в режиме ядра, а не в пользовательском режиме. самый простой способ проверить это - запустить приложение вроде или и с помощью одного из счетчиков оснастки (производительность), перечисленных в таблице 1-2, понаблюдать за показателями времени работы в пользовательском режиме и в режиме ядра.
 эксперимент: наблюдение за активностью потоков с помощью 
 позволяет в динамике наблюдать за соотношением времени, проведенного каждым процессом в режиме ядра и в пользовательском режиме. диаграмме красная часть столбца отражает количество процессорного времени в режиме ядра, а синяя - в пользовательском режиме. (хотя в книге эти столбцы воспроизведены в черно-белом цвете, на самом деле они всегда красные и синие.) сумма всех показателей, отображаемых столбцами в окне , должна соответствовать 100 % процессорного времени. для запуска щелкните кнопку (пуск), выберите команду (выполнить) и введите . (в переменной должен быть указан путь к ресурсам ). например, попробуйте запустить такое интенсивно использующее графику приложение, как (.). откройте , расположив его окно рядом с окном , и нарисуйте в несколько кривых. это время вы сможете наблюдать за выполнением . в окне , как показано ниже.
 чтобы получить дополнительную информацию о потоках процесса, дважды щелкните имя нужного процесса или соответствующий цветной столбик на диаграмме. вы увидите список потоков этого процесса и относительное процессорное время, используемое каждым потоком (в рамках процесса, а не всей системы).
 эксперимент: режим ядра и пользовательский режим 
 помощью оснастки вы можете выяснить, сколько времени ваша система работает в режиме ядра и в пользовательском режиме.
 1. запустите оснастку (производительность), открыв меню (пуск) и последовательно выбрав команды (программы), (администрирование), (производительность).
 2. щелкните на панели инструментов кнопку (добавить) (на этой кнопке изображен большой знак плюс).
 3. выберите в списке объект (процессор), щелкните счетчик % (% работы в привилегированном режиме) и, удерживая клавишу в нажатом состоянии, щелкните счетчик % (% работы в пользовательском режиме).
 4. щелкните кнопку (добавить), а затем (закрыть).
 5. быстро подвигайте мышью. при этом вы должны заметить всплеск на линии % (рис. 1-6), который отражает время, затраченное на обслуживание прерываний от мыши, и время, понадобившееся подсистеме поддержки окон на отрисовку графики (эта подсистема, как поясняется в главе 2, работает преимущественно как драйвер устройства в режиме ядра).
 6. закончив, щелкните на панели инструментов кнопку (новый набор счетчиков) (или просто закройте оснастку).
 за той же активностью можно понаблюдать через (диспетчер задач). просто перейдите в нем на вкладку (быстродействие), а затем выберите из меню (вид) команду (вывод времени ядра). процент загруженности процессора отражается зеленым цветом, а процент времени работы в режиме ядра - красным.
 чтобы увидеть, как сама оснастка использует время в двух режимах, запустите ее снова, но добавьте те же счетчики для объекта (процесс).
 1. если вы закрыли оснастку , снова запустите ее. (если она уже работает, откройте новый экран, щелкнув на панели инструментов кнопку .)
 2. щелкните кнопку на панели инструментов.
 3. выберите в списке объект .
 4. выберите счетчики % и % .
 5.  списке экземпляров объекта выберите все процессы (кроме процесса _).
 6. щелкните кнопку , а затем .
 7. быстро подвигайте мышью.
 8. нажмите комбинацию клавиш + для активизации режима выделения - текущий выбранный счетчик будет выделен белым цветом в 2000 и черным в или 2003.
 9. прокрутите список всех счетчиков в нижней части окна оснастки, чтобы определить процессы, потоки которых выполнялись при перемещении мыши, и обратите внимание на то, в каком режиме они выполнялись - пользовательском или ядра.
 вы должны заметить, как значения счетчиков для процесса оснастки - ищите в колонке (экземпляр) - резко увеличиваются при перемещении мыши, поскольку код приложения выполняется в пользовательском режиме, а вызываемые им -функции - в режиме ядра. вы также заметите, что при перемещении мыши увеличивается активность работы в режиме ядра потока процесса . он представляет поток необработанного ввода ( ) подсистемы , принимающий ввод от клавиатуры и мыши и передающий его процессу, к которому он подключен. (подробнее о системных потоках см. главу 2.) наконец, процесс с именем , потоки которого, как вы убедитесь, тратят почти 100 % своего времени в режиме ядра, на самом деле не является процессом. это лжепроцесс, используемый для учета тактов процессора в состоянии простоя. таким образом, когда нечего делать, она предается этому занятию в режиме ядра.
 и несколько сеансов
 (службы терминала) обеспечивают в поддержку нескольких интерактивных сеансов пользователей на одной системе. помощью удаленный пользователь может установить сеанс на другой машине, зарегистрироваться на ней и запускать приложения на сервере. сервер предоставляет клиенту графический пользовательский интерфейс (), а клиент возвращает серверу пользовательский ввод. (это отличается от того, как ведет себя на -системах, где разрешается выполнять индивидуальные приложения на сервере, а клиенту предоставляется удаленный дисплей, так как удаленным является весь сеанс пользователя - не только одно приложение.)
 первый сеанс входа на физической консоли компьютера считается консольным сеансом, или нулевым сеансом ( ). дополнительные сеансы можно создать с помощью программы соединения с удаленным рабочим столом (.), а в - через механизм быстрого переключения пользователей (об этом позже).
 возможность создания удаленного сеанса поддерживается 2000 , но не 2000 . позволяет одному удаленному пользователю подключаться к машине, однако если кто-то начинает процедуру входа в консоли, рабочая станция блокируется (т. е. систему можно использовать либо локально, либо удаленно, но не и то, и другое одновременно).
 2000 и 2003 поддерживают два одновременных удаленных сеанса. (это упрощает удаленное управление, например облегчает применение инструментов, требующих от администратора входа на удаленный компьютер.) 2000 , и все издания 2003 способны поддерживать более двух сеансов одновременно при условии правильного лицензирования и настройки системы в качестве сервера терминала.
 хотя и не поддерживают несколько удаленных подключений к рабочему столу, они все же поддерживают несколько сеансов, созданных локально через механизм быстрого переключения пользователей. (этот механизм отключается в , если система присоединяется к домену.) когда пользователь выбирает выключение своего сеанса вместо выхода [например, последовательным выбором (пуск), (выход из системы) и (смена пользователя) или нажатием клавиши при одновременном удерживании клавиши ], текущий сеанс (т. е. процессы, выполняемые в этом сеансе, и все структуры данных, глобальные для сеанса и описывающие его) остается в системе, а возвращается к основному окну входа. если в систему входит новый пользователь, создается новый сеанс.
 для приложений, которым нужно знать, выполняются ли они в сеансе сервера терминала, предназначен набор -функций, позволяющих программно распознавать такую ситуацию и контролировать различные аспекты служб терминала. (детали см. в .)
 главе 2 кратко описывается, как создаются сеансы, и проводится несколько экспериментов, показывающих, как просматривать информацию о сеансе с помощью различных инструментов, включая отладчик ядра. разделе «диспетчер объектов» главы 3 поясняется, как создается сеансовый экземпляр системного пространства имен для объектов и как приложения могут узнавать о других своих экземплярах в той же системе. наконец, в главе 7 рассказывается, как диспетчер памяти настраивает данные, глобальные для сеанса, и управляет ими.
объекты и описатели
 операционной системе объект - это единственный экземпляр периода выполнения (- ) статически определенного типа объекта. тип объекта состоит из общесистемного типа данных, функций, оперирующих экземплярами этого типа данных, и набора атрибутов. если вы пишете -приложения, вам наверняка знакомы такие объекты, как процесс, поток, файл и событие, - продолжать можно еще долго. эти объекты базируются на объектах более низкого уровня, создаваемых и управляемых . процесс является экземпляром объекта типа «процесс», файл - экземпляром объекта типа «файл» и т. д.
 атрибут объекта ( ) - это поле данных в объекте, частично определяющее состояние этого объекта. например, объект типа «процесс», имеет атрибуты, в число которых входят идентификатор процесса, базовый приоритет и указатель на объект маркера доступа. методы объекта (средства для манипулирования объектами) обычно считывают или изменяют какие-либо атрибуты. так, метод процесса мог бы принимать идентификатор процесса и возвращать указатель на этот объект.
 примечание путайте параметр , предоставляемый вызывающей программой при создании объекта через или его родные сервисы, с термином «атрибуты объекта», имеющим более общий смысл. 
 самое главное различие между объектом и обычной структурой данных заключается в том, что внутренняя структура объекта скрыта. чтобы получить данные из объекта или записать в него какую-то информацию, вы должны вызвать его сервис. прямое чтение или изменение данных внутри объекта невозможно. тем самым реализация объекта отделяется от кода, который просто использует его, а это позволяет менять реализацию объекта, не модифицируя остальной код.
 объекты очень удобны для поддержки четырех важных функций операционной системы:
  присвоения понятных имен системным ресурсам;
  разделения ресурсов и данных между процессами;
  защиты ресурсов от несанкционированного доступа;
  учета ссылок (благодаря этому система узнает, когда объект больше не используется, и автоматически уничтожает его).
 все структуры данных в являются объектами. объекты помещаются лишь те данные, которые нужно разделять, защищать, именовать или делать доступными программам пользовательского режима (через системные сервисы). структуры, используемые только одним из компонентов операционной системы для поддержки каких-то внутренних функций, к объектам не относятся. подробнее объекты и их описатели (ссылки на экземпляр объекта) рассматриваются в главе 3.
безопасность
 с самого начала разрабатывалась как защищенная система, удовлетворяющая требованиям различных правительственных и промышленных стандартов безопасности, например спецификации (). подтверждение правительством рейтинга безопасности операционной системы позволяет ей конкурировать в сферах, требующих повышенной защиты. разумеется, многим из этих требований должна удовлетворять любая многопользовательская система.
 базовые возможности защиты в таковы: избирательная защита любых разделяемых системных объектов (файлов, каталогов, процессов, потоков и т. д.), аудит безопасности (для учета пользователей и инициируемых ими операций), аутентификация паролей при входе и предотвращение доступа одного из пользователей к неинициализированным ресурсам (например, к памяти или дисковому пространству), освобожденным другим пользователем.
 поддерживает два вида контроля доступа к объектам. первый из них - управление избирательным доступом ( ) - является механизмом, который как раз и связывается большинством пользователей с защитой. это метод, при котором владельцы объектов (например, файлов или принтеров) разрешают или запрещают доступ к ним для других пользователей. при входе пользователь получает набор удостоверений защиты ( ), или контекст защиты ( ). когда он пытается обратиться к объекту, его контекст защиты сверяется со списком управления доступом ( , ) для данного объекта, чтобы определить, имеет ли он разрешение на выполнение запрошенной операции.
 второй метод - управление привилегированным доступом 31 ) - необходим в тех случаях, когда управления избирательным доступом недостаточно. данный метод гарантирует, что пользователь сможет обратиться к защищенным объектам, даже если их владелец недоступен. например, если какой-то сотрудник увольняется из компании, администратору нужно получить доступ к файлам, которые могли быть доступны только бывшему сотруднику. таких случаях позволяет администратору стать владельцем этих файлов и при необходимости управлять правами доступа к ним.
 защита пронизывает весь интерфейс подсистема реализует защиту на основе объектов точно так же, как и сама операционная система. при первой попытке доступа приложения к общему (разделяемому) объекту подсистема проверяет, имеет ли это приложение соответствующие права. если проверка завершается успешно, подсистема разрешает приложению доступ.
 подсистема реализует защиту для общих объектов, часть из которых построена на основе родных объектов . -объектам относятся объекты рабочего стола, меню, окна, файлы, процессы, потоки и ряд синхронизирующих объектов.
 детальное описание защиты в см. в главе 8.
реестр
 если вы работали хоть с какой-нибудь операционной системой , то, вероятно, слышали о реестре или даже просматривали его. рассказать о внутреннем устройстве , не упоминая реестр, вряд ли возможно, так как это системная база данных с информацией, необходимой для загрузки и конфигурирования системы; в ней содержатся общесистемные параметры, контролирующие работу , база данных защиты и конфигурационные настройки, индивидуальные для каждого пользователя.
 кроме того, реестр - это окно, через которое можно заглянуть в переменные системные данные, чтобы, например, выяснить текущее состояние аппаратной части системы (какие драйверы устройств загружены, какие ресурсы они используют и т. д.) или значения счетчиков производительности . счетчики производительности, которые на самом деле в реестре не хранятся, доступны через функции реестра (см. главу 4).
 хотя у многих пользователей и администраторов никогда не возникает необходимости работать непосредственно с реестром (большую часть параметров можно просматривать или модифицировать с помощью стандартных административных утилит), он все же является источником полезной информации о внутренних структурах данных , так как содержит множество параметров, влияющих на быстродействие и поведение системы. (будьте крайне осторожны, напрямую изменяя параметры реестра: любые изменения могут отрицательно сказаться на быстродействии или, что гораздо хуже, привести к краху системы.)
 ссылки на различные разделы реестра, относящиеся к описываемым компонентам, будут встречаться на протяжении всей книги. большинство таких разделов находится в ветви __, которую мы сокращенно называем . подробнее о реестре и его внутренней структуре см. главу 4.
 отличается от большинства других операционных систем тем, что в качестве внутреннего формата для хранения и обработки текстовых строк использует . - это стандартная кодировка, которая поддерживает многие известные в мире наборы символов и в которой каждый символ представляется 16-битным (двухбайтовым) кодом. (подробнее о см. .. и документацию на компакт-дисках .)
 поскольку многие приложения имеют дело с 8-битными (однобайтовыми) -символами, -функции, принимающие строковые параметры, существуют в двух версиях: для и для . 95, 98 и реализована лишь часть -версий -функций, поэтому приложения, рассчитанные на выполнение как в одной из этих операционных систем, так и в -подобных , обычно используют -версии функций. если вы вызываете -версию -функции, входные строковые параметры перед обработкой системой преобразуются в , а выходные - из в (перед возвратом приложению). таким образом при использовании в устаревшего сервиса или фрагмента кода, написанного в расчете на -строки, эта операционная система будет вынуждена преобразовывать -символы в . однако никогда не преобразует данные внутри файлов - решения о том, в какой кодировке хранить текстовую информацию в файлах, принимают лишь сами приложения.
 предыдущих версиях ее азиатский и ближневосточный выпуски представляли собой надмножество базовых американского и европейского выпусков, в которые включались дополнительные -функции для обработки более сложных раскладок клавиатур и принципов ввода текста (например, набора текста справа налево). начиная с 2000, все языковые выпуски содержат одинаковые -функции. единая для всех стран двоичная кодовая база способна поддерживать множество языков за счет простого добавления нужных компонентов языковой поддержки. используя эти -функции, разработчики могут создавать универсальные приложения, способные работать со множеством языков.
изучение внутреннего устройства 
 хотя большая часть информации, представленная в этой книге, получена при чтении исходного кода и общении с разработчиками, вы не обязаны принимать все на веру. многие детали внутреннего устройства можно вытащить на свет с помощью самых разнообразных средств, в том числе поставляемых с , входящих в и ресурсы , а также с использованием отладочных средств самой . чуть позже мы вкратце рассмотрим эти пакеты инструментальных средств.
 чтобы упростить вам исследование внутреннего устройства , мы часто даем в книге врезки «эксперимент» с пошаговыми инструкциями для изучения какого-либо аспекта поведения . (вы уже видели такие врезки в этой главе.) советуем проводить эти эксперименты - это позволит увидеть в действии многие вещи, о которых рассказывается в книге.
 таблице 1-3 перечислены все используемые нами инструменты и утилиты.
 таблица 1-3. средства просмотра внутренней информации 
оснастка 
 мы часто ссылаемся на этот инструмент, доступный через папку (администрирование) в меню (пуск) или через (панель управления). оснастка (производительность) предназначена для мониторинга системы, просмотра журналов, в которых регистрируются значения счетчиков производительности, и оповещения при достижении заданных пороговых значений тех или иных счетчиков. говоря об оснастке , мы подразумеваем лишь ее функцию системного мониторинга.
 оснастка способна сообщить о том, как работает система, гораздо больше, чем любая другая, отдельно взятая утилита. она предусматривает сотни счетчиков для различных объектов. по каждому счетчику можно получить краткое описание. чтобы увидеть описание, выберите счетчик в окне (добавить счетчики) и щелкните кнопку (объяснение). или откройте справочный файл с компакт-диска «ресурсы ». информацию о том, как интерпретировать показания счетчиков для устранения «узких мест» в системе или для планирования пропускной способности сервера, см. раздел « » в книге « 2000 » из набора 2000 . для и 2003 см. документацию в 2003 .
 заметьте, что все счетчики производительности доступны программным путем. краткое описание соответствующих компонентов см. в разделе «__» главы 4.
 
 включают около 40 утилит, полезных в администрировании систем на базе и устранении неполадок в них. многие из этих утилит раньше были частью ресурсов 4.
 вы можете установить , запустив . из папки \\ в дистрибутиве любого издания . одинаковы в 2000 , , и , для , равно как и для 2003, существует своя версия .
ресурсы 
 ресурсы ( ) расширяют , предлагая дополнительные утилиты для администрирования и поддержки систем. утилиты 2003 можно бесплатно скачать с . (выполните поиск по ключевым словам « »). их можно установить в или 2003.
 ресурсы 2000 существуют в двух изданиях: 2000 и 2000 * (самая последняя
 последнее издание переведено на русский язык издательством «русская редакция» и выпущено в 2001 г. в виде серии «ресурсы 2000 » которая включает 4 книги: «сети /», «сопровождение сервера», «распределенные системы» и «межсетевое взаимодействие». - прим. перев. 
 его версия - 1). хотя последний набор представляет собой надмножество первого и может быть установлен на системах с 2000 , утилиты, входящие только в 2000 , ни в одном из наших экспериментов не используются. отличие от утилит 2003 эти утилиты нельзя скачать бесплатно. однако 2000 поставляется с подписками на и .
отладка ядра
 отладка ядра подразумевает изучение внутренних структур данных ядра и/ или пошаговый проход по функциям в ядре. это полезный способ исследования внутреннего устройства , потому что он позволяет увидеть внутрисистемную информацию, недоступную при использовании каких-либо других способов, и получить более ясное представление о схеме выполнения кода внутри ядра.
 отладку ядра можно проводить с помощью разнообразных утилит: от , от . или от . прежде чем описывать эти средства, давайте рассмотрим файл, который понадобится при любом виде отладки ядра.
символы для отладки ядра
 файлы символов ( ) содержат имена функций и переменных. они генерируются компоновщиком () и используются отладчиками для ссылки и отображения этих имен в сеансе отладки. эта информация обычно не хранится в двоичном образе, потому что она не нужна при выполнении кода. есть двоичные образы имеют меньший размер и работают быстрее. это означает, что вам нужно позаботиться о том, чтобы у отладчика был доступ к файлам символов, сопоставляемым с образами, на которые вы ссылаетесь в сеансе отладки.
 для изучения внутренних структур данных ядра (например, списка процессов, блоков потока, списка загруженных драйверов, информации об использовании памяти и т. д.) вам понадобятся подходящие файлы символов как минимум для образа ядра, .. (подробнее этот файл рассматривается в разделе «обзор архитектуры» главы 2.) файлы таблиц символов должны соответствовать версии образа. так, если вы установили или какое-то оперативное исправление, то должны получить обновленные файлы символов хотя бы для образа ядра; иначе возникнет ошибка из-за неправильной контрольной суммы при попытке отладчика ядра загрузить их.
 хотя можно скачать и установить символы для разных версий , обновленные символы для оперативных исправлений доступны не всегда. самый простой способ получить подходящую версию символов для отладки - обратиться к -серверу символов с запросом, в котором используется специальный синтаксис пути к символам, как в отладчике. например,
 следующий путь к символам заставляет средства отладки загружать требуемые символы с интернет-сервера символов и сохранять локальную копию в папке : \:
 *: \* ://..// 
 подробные инструкции о том, как пользоваться сервером символов, см. в справочном файле или на -странице . ////.. 
 
 пакет содержит дополнительные средства отладки, применяемые в этой книге для исследования внутреннего устройства . вы найдете их последние версии по ссылке ../ //. эти средства можно использовать для отладки как процессов пользовательского режима, так и ядра (см. следующую врезку).
 примечание регулярно обновляются и выпускаются независимо от версий операционной системы , поэтому почаще проверяйте наличие новых версий отладочных средств. 
отладка в пользовательском режиме
 средства отладки можно подключать к процессу пользовательского режима, чтобы исследовать и/или изменять память процесса. существует два варианта подключения к процессу:
  (инвазивный) если не указано иное, то, когда вы подключаетесь к выполняемому процессу, -функция - устанавливает соединение между отладчиком и отлаживаемым процессом. это позволяет изучать и/или изменять память процесса, устанавливать точки прерывания () и выполнять другие отладочные действия. 2000 при завершении отладчика закрывается и отлаживаемый процесс. однако в отладчик можно отключать, не уничтожая целевой процесс.
  (неинвазивный) этом случае отладчик просто открывает процесс через функцию . он не подключается к процессу как отладчик это позволяет изучать и/или изменять память целевого процесса, но не дает возможности устанавливать точки прерывания. преимущество данного варианта в том, что в 2000 можно закрыть отладчик, не завершая целевой процесс.
 помощью отладочных средств также можно открывать файлы дампов процессов пользовательского режима. что представляют собой эти файлы, поясняется в главе 3 в разделе по диспетчеризации исключений.
 предлагает отладчики ядра в двух версиях: командной строки (.) и с графическим пользовательским интерфейсом .). оба инструмента предоставляют одинаковый набор команд, так что выбор конкретной утилиты определяется сугубо личными пристрастиями. помощью этих средств вы можете вести отладку ядра в трех режимах.
  откройте файл дампа, полученный в результате краха системы с (подробнее о таких дампах см. главу 14).
  подключитесь к работающей системе и изучите ее состояние (или поставьте точки прерывания, если вы отлаживаете код драйвера устройства). эта операция требует двух компьютеров - целевого и управляющего. целевой считается отлаживаемая система, а управляющей - та, в которой выполняется отладчик. целевая система может быть либо локальной (соединенной с управляющей нуль-модемным кабелем или по 1394), либо удаленной (соединенной по модему). вы должны загрузить целевую систему со спецификатором /, или нажать при загрузке клавишу 8 и выбрать , или добавить соответствующую запись в файл ..
  случае и 2003 подключитесь к локальной системе и изучите ее состояние. это называется локальной отладкой ядра. чтобы инициировать такую отладку ядра, выберите в меню команду , перейдите на вкладку и щелкните ок. пример окна с выводом показан на рис. 1-7. некоторые команды отладчика ядра в этом режиме не работают (например, просмотр стеков ядра и создание дампа памяти командой. невозможны). однако вы можете пользоваться бесплатной утилитой с сайта . в тех случаях, когда родные средства локальной отладки не срабатывают (см. следующий раздел).
 подключившись в режиме отладки ядра, вы можете использовать одну из многих команд расширения отладчика (команды, которые начинаются с «!») для вывода содержимого внутренних структур данных, например потоков, процессов, пакетов запроса на ввод-вывод и информации, связанной с управлением памятью. команды отладчика ядра и их вывод будут обсуждаться при рассмотрении соответствующей тематики. пока добавим, что команда ( ) может форматировать свыше 400 структур ядра благодаря тому, что файлы символов ядра для 2000 3, и 2003 содержат информацию о типах, которая и позволяет отладчику форматировать структуры.
 эксперимент: отображение информации о типах для структур ядра 
 чтобы вывести список структур ядра, чья информация о типах включена в символы ядра, наберите !_* в отладчике ядра. пример части вывода показан ниже:
 команда позволяет искать конкретные структуры по шаблонам. например, если вы ищете имя структуры для объекта прерывания ( ), введите !**: 
 заметьте, что по умолчанию не показывает подструктуры (структуры внутри структур). для рекурсивного прохода по подструктурам, используйте ключ - . например, указав этот ключ для отображения объекта ядра «прерывание», вы увидите формат структуры __, хранящейся в поле :
 справочном файле объясняется, как устанавливать и использовать отладчики ядра. дополнительные сведения о применении отладчиков ядра, предназначенных в основном разработчикам драйверов устройств, см. в документации . есть также несколько полезных статей в по отладчикам ядра. выполните поиск по ключевому слову «» в (онлайновой базе данных технических статей) на . .
утилита 
 - бесплатная утилита, которая позволяет использовать стандартные отладчики ядра от на «живой» системе - без подключения второго компьютера. если встроенная поддержка локальной отладки ядра действует только в и 2003, то обеспечивает такую отладку в 4.0, 2000, и 2003.
 запускается точно так же, как или . эта утилита передает любые указанные параметры командной строки выбранному вами отладчику. по умолчанию запускает отладчик . для запуска -отладчика (), задайте ключ - . чтобы получить подсказку по ключам -, укажите ключ -?.
 предоставляет отладчику смоделированный файл аварийного дампа ( ), поэтому вы можете выполнять в любые операции, поддерживаемые для аварийных дампов. поскольку хранит смоделированный дамп в физической памяти, отладчик ядра может попасть в такую ситуацию, в которой структуры данных находятся в рассогласованном состоянии в процессе их изменения системой. при каждом запуске отладчик получает снимок состояния системы; если вы хотите обновить этот снимок, выйдите из отладчика (командой ), и спросит вас, нужно ли начать сначала. если отладчик, выводя информацию на экран, вошел в цикл, нажмите клавиши +, чтобы прервать вывод, выйдите из отладчика и запустите его снова. если он завис, нажмите клавиши +, которые заставят завершить процесс отладчика. после этого вам будет предложено снова запустить отладчик.
 еще один инструмент, не требующий двух машин для прямой отладки ядра, - , который можно приобрести у (.- .). обладает во многом теми же возможностями, что и , но поддерживает переход между кодом пользовательского режима и режима ядра. он также поддерживает -модули расширения ядра , поэтому большинство команд, описываемых нами в книге, будут работать и в . рис. 1-8 показан пользовательский интерфейс , появляющийся при нажатии клавиши активизации (по умолчанию - +); этот интерфейс представляет собой окно на рабочем столе системы, в которой он выполняется.
 ()
 является частью подписки на уровня и выше; кроме того, его можно бесплатно скачать с .. . нем содержатся документация, заголовочные файлы и библиотеки с, необходимые для компиляции и компоновки -приложений. ( ++ тоже поставляется с этими файлами, но их версии в всегда более новые и соответствуют самым последним версиям операционных систем .) для нас будут представлять интерес заголовочные файлы (\ \ \) и несколько утилит (., ., ., . и .). некоторые из них также поставляются с ресурсами и . наконец, отдельные утилиты поставляются с и как примеры исходного кода.
 ()
 является частью подписки на уровня и выше, но в отличие от его нельзя скачать бесплатно (впрочем, можно заказать - за минимальную цену). документация включается в .
 хотя нацелен на разработчиков драйверов устройств, он представляет собой богатый источник информации о внутреннем устройстве . например, в главе 9 мы даем описание архитектуры подсистемы ввода-вывода, модели драйверов и структур данных базовых драйверов устройств, но не вдаемся в детали соответствующих функций ядра. в документации исчерпывающе описаны все внутрисистемные функции и драйверы устройств.
 кроме документации в входят заголовочные файлы, определяющие ключевые внутренние структуры данных, константы и интерфейсы многих внутрисистемных подпрограмм (в частности, обратите внимание на файлы . и .). эти файлы очень полезны в исследовании внутренних структур данных с помощью отладчика ядра, так как мы даем лишь обобщенное описание внутренних структур, а в заголовочных файлах можно найти все подробности о каждом поле таких структур. также детально поясняются некоторые структуры данных (вроде заголовков для диспетчера объектов, блоки ожидания, события, мутанты, семафоры и др.).
 поэтому, если вы хотите поглубже покопаться в подсистеме ввода-вывода и в модели драйверов, читайте документацию (особенно руководства - и ). еще один превосходный источник - книга уолта они ( ) « , » ( ).
утилиты 
 многих экспериментах мы используем свободно распространяемые утилиты, которые можно скачать с . . большинство этих ути-
 лит написано марком руссиновичем, соавтором этой книги. наиболее популярным утилитам относятся , и . многие из этих утилит требуют установки и запуска драйверов устройств, работающих в режиме ядра, а значит, вам понадобятся полномочия администратора.
резюме
 этой главе вы познакомились с ключевыми техническими концепциями и терминами , которые будут использоваться во всей книге. вы также получили первое представление о многих полезных инструментах, позволяющих изучать внутренние структуры данных . теперь вы готовы вместе с нами приступить к исследованию внутреннего устройства системы. мы начнем с общего обзора архитектуры системы и ее основных компонентов.
 гл 2  архитектура системы
 теперь, познакомившись с необходимыми терминами, понятиями и инструментами, мы можем рассмотреть задачи, которые ставились при разработке операционной системы . этой главе описывается общая архитектура системы: ключевые компоненты, принципы их взаимодействия и контекст выполнения. чтобы получить базовое представление о внутреннем устройстве , давайте сначала обсудим требования и цели, обусловившие структуру и спецификацию этой системы.
требования и цели проекта
 характеристики в 1989 году определялись следующими требованиями. операционная система должна:
  быть истинно 32-разрядной, реентерабельной, поддерживать вытесняющую многозадачность и работу с виртуальной памятью;
  работать на разных аппаратных платформах;
  хорошо масштабироваться в системах с симметричной мультипроцессорной обработкой;
  быть распределенной вычислительной платформой, способной выступать в роли как клиента сети, так и сервера;
  поддерживать большинство существующих 16-разрядных приложений
 - и 3.1;  отвечать требованиям правительства к соответствию 1003.1;
  отвечать требованиям правительства и промышленности к безопасности операционных систем;
  обеспечивать простоту адаптации к глобальному рынку за счет поддержки .
 для создания системы, соответствующей предъявленным требованиям, нужно было принять тысячи решений. поэтому перед командой разработчиков на начальном этапе проекта были поставлены следующие цели.
  расширяемость код должен быть написан так, чтобы системы можно было легко наращивать и модифицировать по мере изменения потребностей рынка.
  переносимость система должна работать на разных аппаратных архитектурах и обладать способностью к сравнительно легкому переносу на новые аппаратные архитектуры, если на рынке возникнет такая потребность.
  отказоустойчивость и надежность система должна быть защищенной как от внутренних сбоев, так и от внешних деструктивных действий. у приложений не должно быть возможности нарушить работу операционной системы или других приложений.
  совместимость хотя должна расширить существующую технологию, ее пользовательский интерфейс и должны быть совместимы с предыдущими версиями и -. она также должна уметь взаимодействовать с другими системами вроде , /2 и .
  производительность учетом ограничений, налагаемых поставленными целями, система должна быть максимально быстрой и отзывчивой независимо от аппаратной платформы.
 по мере изучения деталей внутренней структуры вы увидите, насколько успешно были реализованы все эти требования и цели. сначала мы рассмотрим общую модель и сравним ее с другими современными операционными системами.
модель операционной системы
 большинстве многопользовательских операционных систем приложения отделены от собственно операционной системы: код ее ядра выполняется в привилегированном режиме процессора (называемом режимом ядра), который обеспечивает доступ к системным данным и оборудованию. код приложений выполняется в непривилегированном режиме процессора (называемом пользовательским) с неполным набором интерфейсов, ограниченным доступом к системным данным и без прямого доступа к оборудованию. когда программа пользовательского режима вызывает системный сервис, процессор перехватывает вызов и переключает вызывающий поток в режим ядра. по окончании работы системного сервиса операционная система переключает контекст потока обратно в пользовательский режим и продолжает его выполнение.
 , как и большинство -систем, является монолитной операционной системой - в том смысле, что большая часть ее кода и драйверов использует одно и то же пространство защищенной памяти режима ядра. это значит, что любой компонент операционной системы или драйвер устройства потенциально способен повредить данные, используемые другими компонентами операционной системы.
основана ли на микроядре?
 хотя некоторые объявляют ее таковой, не является операционной системой на основе микроядра в классическом понимании этого термина. подобных системах основные компоненты операционной системы (диспетчеры памяти, процессов, ввода-вывода) выполняются как отдельные процессы в собственных адресных пространствах и представляют собой надстройки над примитивными сервисами микроядра. пример современной системы с архитектурой на основе микроядра - операционная система , разработанная в - . она реализует крошечное ядро, которое включает сервисы планирования потоков, передачи сообщений, виртуальной памяти и драйверов устройств. все остальное, в том числе разнообразные , файловые системы и поддержка сетей, работает в пользовательском режиме. однако в коммерческих реализациях на основе микроядра код файловой системы, поддержки сетей и управления памятью выполняется в режиме ядра. причина проста: системы, построенные строго по принципу микроядра, непрактичны с коммерческой точки зрения из-за слишком низкой эффективности.
 означает ли тот факт, что большая часть работает в режиме ядра, ее меньшую надежность в сравнении с операционными системами на основе микроядра? вовсе нет. рассмотрим следующий сценарий. допустим, в коде файловой системы имеется ошибка, которая время от времени приводит к краху системы. ошибка в коде режима ядра (например, в диспетчере памяти или файловой системы) скорее всего вызовет полный крах традиционной операционной системы. истинной операционной системе на основе микроядра подобные компоненты выполняются в пользовательском режиме, поэтому теоретически ошибка приведет лишь к завершению процесса соответствующего компонента. на практике такая ошибка все равно вызовет крах системы, так как восстановление после сбоя столь критически важного процесса невозможно.
 все эти компоненты операционной системы, конечно, полностью защищены от сбойных приложений, поскольку такие программы не имеют прямого доступа к коду и данным привилегированной части операционной системы (хотя и способны вызывать сервисы ядра). эта защита - одна из причин, по которым заслужила репутацию отказоустойчивой и стабильной операционной системы в качестве сервера приложений и платформы рабочих станций, обеспечивающей быстродействие основных системных сервисов вроде поддержки виртуальной памяти, файлового ввода-вывода, работы с сетями и доступа к общим файлам и принтерам.
 компоненты режима ядра также построены на принципах объектно-ориентированного программирования (ооп). так, для получения информации о каком-либо компоненте они, как правило, не обращаются к его структурам данных. вместо этого для передачи параметров, доступа к структурам данных и их изменения используются формальные интерфейсы.
 однако, несмотря на широкое использование объектов, представляющих разделяемые системные ресурсы, не является объектно-ориентированной системой в строгом понимании этого термина. большая часть системного кода написана на в целях переносимости и из-за широкой распространенности средств разработки на с. этом языке нет прямой поддержки конструкций и механизмов ооп вроде динамического связывания типов данных, полиморфных функций или наследования классов.
обзор архитектуры
 теперь обратимся к ключевым компонентам системы, составляющим ее архитектуру. упрощенная версия этой архитектуры показана на рис. 2-1. учтите, что упрощенная схема не отражает всех деталей архитектуры (например, здесь не показаны уровни сетевых компонентов и различных типов драйверов устройств).
 рис. 2-1. упрощенная схема архитектуры 
 рис. 2-1 прежде всего обратите внимание на линию, разделяющую те части , которые выполняются в режиме ядра и в пользовательском режиме. прямоугольники над этой линией соответствуют процессам пользовательского режима, а компоненты под ней - сервисам режима ядра. как говорилось в главе 1, потоки пользовательского режима выполняются в защищенных адресных пространствах процессов (хотя при выполнении в режиме ядра они получают доступ к системному пространству). таким образом, процессы поддержки системы, сервисов, приложений и подсистем окружения имеют свое адресное пространство.
 существует четыре типа пользовательских процессов:
  фиксированные процессы поддержки системы ( ) - например, процесс обработки входа в систему и диспетчер сеансов, не являющиеся сервисами (т. е. не запускаемые диспетчером управления сервисами);
  процессы сервисов ( ) - носители -сервисов вроде и . многие серверные приложения , например и , тоже включают компоненты, выполняемые как сервисы;
  пользовательские приложения ( ) - бывают шести типов: для 32-разрядной , 64-разрядной , 16-разрядной 3.1, 16-разрядной -, 32-разрядной и 32-разрядной /2;
  подсистемы окружения ( ) - реализованы как часть поддержки среды операционной системы, предоставляемой пользователям и программистам. изначально поставлялась с тремя подсистемами окружения: , и /2. последняя была изъята в 2000. что касается , то в ней исходно поставляется только подсистема - улучшенная подсистема доступна как часть бесплатного продукта . обратите внимание на прямоугольник « подсистем», расположенный на рис. 2-1 под прямоугольниками «процессы сервисов» и «пользовательские приложения». пользовательские приложения не могут вызывать родные сервисы операционной системы напрямую, вместо этого они работают с одной или несколькими подсистем. их назначение заключается в трансляции документированных функций в соответствующие внутренние (и обычно недокументированные) вызовы системных сервисов . трансляция может осуществляться как с помощью сообщения, посылаемого процессу подсистемы окружения, обслуживающему пользовательское приложение, так и без него.
 включает следующие компоненты режима ядра.
  исполнительная система () , содержащая базовые сервисы операционной системы, которые обеспечивают управление памятью, процессами и потоками, защиту, ввод-вывод и взаимодействие между процессами.
  ядро () , содержащее низкоуровневые функции операционной системы, которые поддерживают, например, планирование потоков, диспетчеризацию прерываний и исключений, а также синхронизацию при использовании нескольких процессоров. оно также предоставляет набор процедур и базовых объектов, применяемых исполнительной системой для реализации структур более высокого уровня.
  драйверы устройств ( ), в состав которых входят драйверы аппаратных устройств, транслирующие пользовательские вызовы функций ввода-вывода в запросы, специфичные для конкретного устройства, а также сетевые драйверы и драйверы файловых систем.
  уровень абстрагирования от оборудования ( , ), изолирующий ядро, драйверы и исполнительную систему от специфики оборудования на данной аппаратной платформе (например, от различий между материнскими платами).
  подсистема поддержки окон и графики ( ), реализующая функции графического пользовательского интерфейса (), более известные как -функции модулей и эти функции обеспечивают поддержку окон, элементов управления пользовательского интерфейса и отрисовку графики.
 таблице 2-1 перечислены имена файлов основных компонентов . (вы должны знать их, потому что в дальнейшем мы будем ссылаться на некоторые системные файлы по именам.) каждый из этих компонентов подробно рассматривается в этой и последующих главах.
 прежде чем детально рассматривать эти компоненты, давайте проясним, как достигается переносимость между различными аппаратными платформами.
переносимость
 рассчитана на разные аппаратные платформы, включая как -системы , так и -системы. первого выпуска поддерживала архитектуры 86 и . спустя некоторое время была добавлена поддержка производства ( была приобретена , а позднее произошло слияние компаний и ). (хотя был 64 -разрядным процессором, работала с ним в 32-разрядном режиме. ходе разработки 2000 была создана ее 64 -разрядная версия специально под , но в свет она так и не вышла.) 3.51 ввели поддержку четвертой процессорной архитектуры - . связи с изменениями на рынке необходимость в поддержке и практически отпала еще до начала разработки 2000. позднее отозвала поддержку архитектуры , и в 2000 осталась поддержка лишь архитектуры 86. самые последние выпуски - и 2003 - добавлена поддержка трех семейств 64 -разрядных процессоров: -64, 86-64 и 64 - (64) для 86 (эта архитектура совместима с архитектурой 86-64, хотя есть небольшие различия в поддерживаемых командах). последние два семейства процессоров называются системами с 64-разрядными расширениями и в этой книге обозначаются как 64. (как 32 -разрядные приложения выполняются в 64 -разрядной , объясняется в главе 3.) 
 переносимость между системами с различной аппаратной архитектурой и платформами достигается главным образом двумя способами.
  имеет многоуровневую структуру. специфичные для архитектуры процессора или платформы низкоуровневые части системы вынесены в отдельные модули. благодаря этому высокоуровневая часть системы не зависит от специфики архитектур и аппаратных платформ. ключевые компоненты, обеспечивающие переносимость операционной системы, - ядро (содержится в файле .) и уровень абстрагирования от оборудования () (содержится в файле .). функции, специфичные для конкретной архитектуры (переключение контекста потоков, диспетчеризация ловушек и др.), реализованы в ядре. функции, которые могут отличаться на компьютерах с одинаковой архитектурой (например, в системах с разными материнскими платами), реализованы в . еще один компонент, содержащий большую долю кода, специфичного для конкретной архитектуры, - диспетчер памяти ( ), но если рассматривать систему в целом, такого кода все равно немного.
  подавляющее большинство компонентов написано на и лишь часть из них - на ++. язык ассемблера применяли только при создании частей системы, напрямую взаимодействующих с системным оборудованием (например, при написании обработчика ловушек прерываний) или требующих исключительного быстродействия (скажем, при переключении контекста). ассемблерный код имеется не только в ядре и , но и в составе некоторых других частей операционной системы: процедур, реализующих взаимоблокировку, механизма вызова локальных процедур (), части подсистемы , выполняемой в режиме ядра, и даже в некоторых библиотеках пользовательского режима (например, в коде запуска процессов в . - системной библиотеке, о которой будет рассказано в этой главе несколько позже).
симметричная многопроцессорная обработка
 многозадачность () - механизм операционной системы, позволяющий использовать один процессор для выполнения нескольких потоков. однако истинно одновременное выполнение, например, двух потоков возможно, только если на компьютере установлено два процессора. при многозадачности система лишь создает видимость одновременного выполнения множества потоков, тогда как многопроцессорная система действительно выполняет сразу несколько потоков - по одному на каждом процессоре.
 как уже говорилось в начале этой главы, одной из ключевых целей разработки была поддержка многопроцессорных компьютерных систем. является операционной системой, поддерживающей симметричную многопроцессорную обработку ( , ). этой модели нет главного процессора; операционная система, как и пользовательские потоки, может выполняться на любом процессоре. кроме того, все процессоры используют одну итуже память. при асимметричной многопроцессорной обработке ( , ) система, напротив, выбирает один из процессоров для выполнения кода ядра операционной системы, а другие процессоры выполняют только пользовательский код. различия между этими двумя моделями показаны на рис. 2-2.
 и 2003 поддерживают два новых типа многопроцессорных систем: логические процессоры () и (- ). об этом кратко рассказывается в абзаце ниже. (полное описание поддержки планирования потоков для таких систем см. в разделе по планированию потоков в главе 6.)
 логические процессоры - это технология, созданная ; благодаря ей на одном физическом процессоре может быть несколько логических. каждый логический процессор имеет свое состояние, но исполняющее ядро ( ) и набортный кэш ( ) являются общими. это позволяет одному из логических процессоров продолжать работу, пока другой логический процессор занят (например, обработкой прерывания, которая не дает потокам выполняться на этом логическом процессоре). алгоритмы планирования в были оптимизированы под компьютеры с такими процессорами.
 -системах процессоры группируются в блоки, называемые узлами (). каждом узле имеются свои процессоры и память, и он соединяется с остальными узлами специальной шиной. в -систе-ме по-прежнему работает как -система, в которой все процессоры имеют доступ ко всей памяти, - просто доступ к памяти, локальной для узла, осуществляется быстрее, чем к памяти в других узлах. система стремится повысить производительность, выделяя потокам время на процессорах, которые находятся в том же узле, что и используемая память. она также пытается выделять память в пределах узла, но при необходимости выделяет память и из других узлов.
 хотя изначально разрабатывалась для поддержки до 32 процессоров, многопроцессорной модели не свойственны никакие внутренние особенности, которые ограничивали бы число используемых процессоров до 32. просто это число легко представить битовой маской с помощью машинного 32-разрядного типа данных. и действительно, 64-разрядные версии поддерживают до 64 процессоров, потому что размер слова на 64-разрядных процессорах равен 64 битам.
 реальное число поддерживаемых процессоров зависит от конкретного выпуска (см. таблицы 2-3 и 2-4). это число хранится в параметре реестра \\\\\\-. учтите, что модификация этого параметра считается нарушением условий лицензионного соглашения на программное обеспечение, да и для увеличения числа поддерживаемых процессоров требуется нечто большее, чем простое изменение данного параметра.)
 для большей производительности ядро и имеют одно- и многопроцессорную версии. случае 2000 это относится к шести ключевым системным файлам (см. примечание ниже), а в 32-разрядных и 2003 - только к трем (см. таблицу 2-2). 64-разрядных системах ядра нет, поэтому одно- и многопроцессорные системы отличаются лишь ядром и .
 соответствующие файлы выбираются и копируются в локальный каталог \\32 на этапе установки. чтобы определить, какие файлы были скопированы, см. файл \\\., где перечисляются все файлы, копировавшиеся на локальный системный диск, и каталоги на дистрибутивном носителе, откуда они были взяты.
 примечание папке \386\ в дистрибутиве 2000 находится файл .. хотя он помещен в папку , название которой указывает на однопроцессорную версию, на самом деле для одно- и многопроцессорных систем существует только одна версия этого образа. 
 эксперимент: поиск файлов поддержки многопроцессорных систем в 2000 
 вы можете убедиться в том, что для многопроцессорной 32-разрядной системы 2000 используются другие файлы, просмотрев сведения о драйверах для (компьютер) в (диспетчер устройств).
 1. откройте окно свойств системы, дважды щелкнув (система) в окне (панель управления) или щелкнув правой кнопкой мыши (мой компьютер) на рабочем столе и выбрав из контекстного меню команду (свойства).
 2. перейдите на вкладку (оборудование).
 3. щелкните кнопку (диспетчер устройств).
 4. раскройте объект (компьютер).
 5. дважды щелкните дочерний узел объекта .
 6. откройте вкладку (драйвер).
 7. щелкните кнопку (сведения о драйверах).
 многопроцессорной системе вы должны увидеть диалоговое окно, показанное ниже.
 специальные версии этих ключевых системных файлов для однопроцессорных систем созданы для максимального повышения производительности. синхронизация работы нескольких процессоров - задача принципиально более сложная, и благодаря «однопроцессорным» версиям системных файлов устраняются издержки этой синхронизации, которая в однопроцессорных системах (а они составляют подавляющее большинство систем под управлением ) не нужна.
 интересно, что «однопроцессорная» и «многопроцессорная» версии создаются за счет условной компиляции одного и того же исходного кода, а «однопроцессорные» версии . и 32. для 2000 требуют замены машинных х86-команд и , используемых для синхронизации множества потоков, командой (которая ничего не делает).
 остальные системные файлы (включая все утилиты, библиотеки и драйверы устройств) одинаковы как в многопроцессорных, так и в однопроцессорных системах. при разработке нового программного обеспечения - -приложения или драйвера устройства - вы должны учитывать этот подход и тестировать свое программное обеспечение как в одно-, так и в многопроцессорных системах.
 эксперимент: определение текущей версии 
 2000 и выше нет утилиты, показывающей, с какой версией вы работаете. однако при каждой загрузке в журнале системы регистрируется, какая версия ядра запускается - одно- или многопроцессорная, отладочная или конечная (см. следующую иллюстрацию). выберите из меню (пуск) команду (программы), затем (администрирование) и (просмотр событий). далее выберите (журнал системы) и дважды щелкните запись с кодом события 6009 - она создается при загрузке системы.
 эта запись не содержит сведений о том, загружена ли рае-версия образа ядра, поддерживающая более 4 гб физической памяти (.). однако вы можете узнать это, проверив значение параметра в разделе реестра \\-\. кроме того, при загрузке рае-версии ядра параметру в разделе реестра \\-\\ \ присваивается значение, равное 1.
 есть и другой способ определить, установлена ли многопроцессорная версия (или ): запустите (проводник), в каталоге \\32 щелкните правой кнопкой мыши файл . и выберите из контекстного меню команду -
 (свойства). перейдите на вкладку (версия) и выберите свойство (исходное имя файла). если вы работаете с многопроцессорной версией, то увидите диалоговое окно, показанное на предыдущей странице.
 наконец, просмотрев файл \\\., можно точно выяснить, какие файлы ядра и были выбраны при установке.
масштабируемость
 масштабируемость () - одна из ключевых целей многопроцессорных систем. для корректного выполнения в -системах операционная система должна строго соответствовать определенным требованиям. решить проблемы конкуренции за ресурсы и другие вопросы в многопроцессорных системах сложнее, чем в однопроцессорных, и это нужно учитывать при разработке системы. некоторые особенности оказались решающими для ее успеха как многопроцессорной операционной системы:
  способность выполнять код операционной системы на любом доступном процессоре и на нескольких процессорах одновременно;
  несколько потоков одного процесса можно параллельно выполнять на разных процессорах;
  тонкая синхронизация внутри ядра (спин-блокировки, спин-блокировки с очередями и др.; см. главу 3), драйверов устройств и серверных процессов позволяет выполнять больше компонентов на нескольких процессорах одновременно;
  механизмы вроде портов завершения ввода-вывода (см. главу 9), облегчающие эффективную реализацию многопоточных серверных процессов, хорошо масштабируемых в многопроцессорных системах. масштабируемость ядра со временем улучшалась. например, в 2003 имеются очереди планирования, индивидуальные для каждого процессора, что дает возможность планировать потоки параллельно на нескольких машинах. планировании потоков в многопроцессорных системах см. главу 6, а о синхронизации в таких системах - главу 3.
различия между клиентскими и серверными версиями
 поставляется в клиентских и серверных версиях. 2000 клиентская версия называется 2000 . существует также три серверных версии 2000: 2000 , и .
 у шесть клиентских версий: , , , , и . последние три являются надмножествами и в книге детально не рассматриваются, так как все они построены на том же базовом коде, что и .
 2003 выпускается в шести разновидностях: 2003 , , , , и .
 эти версии различаются по следующим параметрам:
  числу поддерживаемых процессоров;
  объему поддерживаемой физической памяти;
  возможному количеству одновременных сетевых соединений (например, в клиентской версии допускается максимум 10 одновременных соединений со службой доступа к общим файлам и принтерам);
  наличием в выпусках сервисов, не входящих в (например, служб каталогов, поддержкой кластеризации и многопользовательской службы терминала).
 эти различия для 2000 суммируются в таблице 2-3. же информация, но применительно к и 2003 дана в таблице 2-4.
 хотя существует несколько клиентских и серверных выпусков операционной системы , у них общий набор базовых системных файлов, в том числе: ядро, . (а также версия рае, .), библиотеки , драйверы, основные системные утилиты и . эти файлы идентичны для всех выпусков 2000.
 примечание была первым клиентским выпуском кодовой базы , который поставляется без соответствующих серверных версий. вместо этого разработки продолжались, и примерно год спустя после выхода была выпущена 2003. таким образом, базовые системные файлы и 2003 не идентичны. однако они не столь значимы (и во многих случаях компоненты не изменялись). 
 итак, если образ ядра для 2000 и 2000 одинаков (и сходен для и 2003), то как же система определяет, какой именно выпуск загружается? для этого она проверяет значения параметров и в разделе реестра \\\\. параметр используется, чтобы отличить клиентскую систему от серверной (любого выпуска). список допустимых значений этого параметра приведен в таблице 2-5. результат проверки помещается в глобальную системную переменную , значение которой может быть запрошено драйвером устройства через функцию режима ядра, описанную в документации .
 другой параметр, , позволяет различать серверные версии (, , и др.), а также от . для проверки текущего выпуска пользовательские программы вызывают -функцию , описанную в . драйверы могут вызвать функцию режима ядра, документированную в .
 итак, если базовые файлы в целом одинаковы для клиентских и серверных версий, то чем же отличается их функционирование? серверные системы оптимизированы для работы в качестве высокопроизводительных серверов приложений, а клиентские, несмотря на поддержку серверных возможностей, - для персональных систем. так, некоторые решения по выделению ресурсов (например, о числе и размере системных пулов памяти, количестве внутрисистемных рабочих потоков и размере системного кэша данных) при загрузке принимаются по-разному, в зависимости от типа продукта. политика принятия таких решений, как обслуживание диспетчером памяти запросов системы и процессов на выделение памяти, у серверной и клиентской версий тоже различается. равной мере это относится и к особенностям планирования потоков по умолчанию (детали см. в главе 6). существенные отличия в функционировании этих двух продуктов будут отмечены в соответствующих главах. любые материалы в нашей книге, если явно не указано иное, относятся к обеим версиям - клиентской и серверной.
проверочный выпуск
 специальная отладочная версия 2000 , или 2003 называется проверочным выпуском ( ). она доступна только подписчикам уровня (или выше). проверочный выпуск представляет собой перекомпилированный исходный код , для которого флаг «» (заставляющий включать код отладки и трассировки этапа компиляции) был установлен как . кроме того, чтобы облегчить восприятие машинного кода, отключается обработка двоичных файлов, при которой структура кода оптимизируется для большего быстродействия (см. раздел «- » в справочном файле ).
 проверочный выпуск предназначен главным образом разработчикам драйверов устройств, поскольку эта версия выполняет более строгую проверку ошибок при вызове функций режима ядра драйверами устройств или другим системным кодом. например, если драйвер (или какой-то иной код режима ядра) неверно вызывает системную функцию, контролирующую передаваемые параметры, то при обнаружении этой проблемы система останавливается, предотвращая повреждение структур данных и возможный крах.
 эксперимент: определяем, является ли данная система проверочным выпуском 
 встроенной утилиты, которая позволяла бы увидеть, с каким выпуском вы имеете дело - проверочным или готовым, нет. однако эта информация доступна через свойство «» -класса ) 32_. следующий сценарий на отображает содержимое этого свойства:
 значительная часть дополнительного кода в собранных таким образом двоичных файлах является результатом работы макроса , определенного в заголовочном файле ., который входит в состав . этот макрос проверяет некое условие (например, правильность структуры данных или параметра) и, если значение выражения получается равным , вызывает функцию режима ядра, которая в свою очередь обращается , передающей текст отладочного сообщения в буфер отладочных сообщений ( ). если отладчик ядра подключен, это сообщение выводится на экран, а за ним автоматически появляется запрос к пользователю, какое действие следует предпринять (игнорировать, завершить процесс или поток и т. д.). если система загружена без отладчика ядра (в отсутствие ключа / в файле .) и этот отладчик сейчас не подключен, неудачный тест вызовет крах системы. список тестов
 , выполняемых некоторыми вспомогательными процедурами ядра, см. в разделе « » документации .
 примечание сравнив файл . с . или . с . в проверочной версии системы, вы убедитесь, что они идентичны и являются «многопроцессорными» версиями соответствующих файлов. иначе говоря, в проверочной версии системы нет отладочных вариантов файлов для однопроцессорных систем. 
 проверочный выпуск также полезен системным администраторам, так как в нем можно включить детальную трассировку для определенных компонентов. (подробные инструкции см. в статье 3743 «: » в .) вывод такой трассировки посылается в буфер отладочных сообщений с помощью функции , о которой мы уже упоминали. для просмотра отладочных сообщений к целевой системе можно подключить отладчик ядра (что потребует загрузки целевой системы в отладочном режиме), использовать команду ! в процессе локальной отладки ядра или применить утилиту . с сайта . .
 для использования возможностей отладочной версии операционной системы необязательно устанавливать весь проверочный выпуск. можно просто скопировать проверочную версию образа ядра (.) и соответствующий (.) в обычную систему. преимущество этого подхода в том, что он позволяет тщательно протестировать драйверы устройств и другой код ядра, не устанавливая медленнее работающие версии всех компонентов системы. том, как это сделать, см. раздел « » в документации . поскольку не поставляет проверочный выпуск 2000 , вы можете применить этот способ и получить проверочную версию ядра в системе 2000 .
 наконец, проверочная версия пригодится и для тестирования кода пользовательского режима, но только в том смысле, что в проверочной версии системы устанавливаются другие интервалы ожидания (тайминги). (это связано с тем, что в ядре выполняются дополнительные проверки, а сами компоненты компилируются без оптимизации.) таких условиях часто проявляются ошибки, связанные с синхронизацией нескольких потоков приложения.
ключевые компоненты системы
 теперь, ознакомившись с высокоуровневой архитектурой , копнем поглубже и рассмотрим роль каждого ключевого компонента системы. рис. 2-3 отражена более подробная схема системной архитектуры . заметьте, что на ней все равно не показаны некоторые компоненты (в частности, компоненты сетевой поддержки, о которых пойдет речь в главе 13).
 основные элементы этой схемы детально описываются в последующих главах. главе 3 рассказывается об основных механизмах управления,
 используемых системой (в том числе о диспетчере объектов, прерываниях и т. п.), в главе 5 - о процессах запуска и завершения , а в главе 4 - о таких механизмах управления, как реестр, процессы сервисов и (). остальных главах не менее подробно поясняется внутреннее устройство и функционирование ключевых элементов - процессов, потоков, подсистемы управления памятью, защиты, диспетчера ввода-вывода, диспетчера кэша, файловой системы , сетевой поддержки и др.
 р ис. 2-3 подсистемы окружения и их :
 как показано на рис. 2-3, в имеется три подсистемы окружения: /2, и . как мы уже говорили, подсистема /2 была удалена в 2000. начиная с , базовая подсистема не поставляется с , но ее гораздо более совершенную версию можно получить бесплатно как часть продукта .
 подсистема отличается от остальных двух тем, что без нее работать не может (эта подсистема обрабатывает все, что связано с клавиатурой, мышью и экраном, и нужна даже на серверах в отсутствие интерактивных пользователей). фактически остальные две подсистемы запускаются только по требованию, тогда как подсистема работает всегда.
 стартовая информация подсистемы хранится в разделе реестра \ \\\ \. значения параметров в этом разделе показаны на рис. 2-4.
 значением параметра является список подсистем, загружаемых при запуске системы. параметр состоит из двух строк: и . параметре указывается спецификация файла подсистемы , . (аббревиатура от / - ; см. примечание ниже). параметр остается незаполненным (он используется для внутреннего тестирования) и не выполняет никаких функций. параметр указывает, что подсистемы /2 и запускаются по требованию. параметр содержит имя файла той части подсистемы , которая работает в режиме ядра, - 32. (об этом файле чуть позже).
 подсистемы окружения предоставляют прикладным программам некое подмножество базовых сервисов исполнительной системы . каждая подсистема обеспечивает доступ к разным подмножествам встроенных сервисов . это значит, что приложения, созданные для одной подсистемы, могут выполнять операции, невозможные в другой подсистеме. так, -приложения не могут использовать -функцию .
 каждый исполняемый образ () принадлежит одной - и только одной - подсистеме. при запуске образа код, отвечающий за создание процесса, получает тип подсистемы, указанный в заголовке образа, и уведомляет соответствующую подсистему о новом процессе. тип указывается спецификатором / в команде в ++; его можно просмотреть с помощью утилиты , входящей в состав ресурсов .
 примечание процесс подсистемы назван . потому, что в все подсистемы изначально предполагалось выполнять как потоки внутри единственного общесистемного процесса. когда подсистемы и /2 были выделены в собственные процессы, имя файла процесса подсистемы осталось прежним. 
 смешивать вызовы функций разных подсистем нельзя. иными словами, приложения могут вызывать только сервисы, экспортируемые подсистемой , а приложения - лишь сервисы, экспортируемые подсистемой . как вы еще убедитесь, это ограничение послужило одной из причин, по которой исходная подсистема , реализующая весьма ограниченный набор функций (только 1003.1), не стала полезной средой для переноса в нее -приложений.
 мы уже говорили, что пользовательские приложения не могут вызывать системные сервисы напрямую. вместо этого они обращаются к подсистем. эти предоставляют документированный интерфейс между программами и вызываемой ими подсистемой. так, подсистемы (32., 32., 32. и 32.) реализуют функции . подсистемы (.) реализует .
 эксперимент: определение типа подсистемы, для которой предназначен исполняемый файл 
 вы можете определить, для какой подсистемы предназначен исполняемый файл с помощью утилиты из набора ресурсов или утилиты (.), входящей в состав и . попробуем, например, выяснить тип подсистемы для двух принципиально разных -образов: . (простого текстового редактора) и . (поддержки командной строки ).
 это показывает, что является -программой, - консольной, или программой текстового режима. хотя вывод утилиты сообщает о наличии двух разных подсистем для - и консольных программ, на самом деле существует лишь одна подсистема . кроме того, не поддерживает процессор 386 (или 486, если это имеет какое-то значение) - текст сообщений, выводимых программой , просто не обновили.
 при вызове приложением одной из функций подсистемы возможно одно из трех.
  функция полностью реализована в пользовательском режиме внутри подсистемы. иначе говоря, никаких сообщений процессу подсистемы окружения не посылается, и вызова сервисов исполнительной системы не происходит. после выполнения функции в пользовательском режиме результат возвращается вызвавшей ее программе. примерами таких функций могут служить (всегда возвращает -1, значение, определенное для ссылки на текущий процесс во всех функциях, связанных с процессами) и (идентификатор процесса не меняется в течение его срока жизни, поэтому его можно получить из кэша, что позволяет избежать переключения в режим ядра).
  функция требует одного или более вызовов исполнительной системы . например, -функции и обращаются к внутренним недокументированным сервисам ввода-вывода - соответственно к и . 
  функция требует выполнения каких-либо операций в процессе подсистемы окружения (такие процессы, работающие в пользовательском режиме, отвечают за обслуживание клиентских приложений, выполняемых под их контролем). этом случае подсистеме окружения выдается клиент-серверный запрос через сообщение с требованием выполнить какую-либо операцию, и подсистемы, прежде чем вернуть управление вызвавшей программе, ждет соответствующего ответа.
 некоторые функции вроде и могут требовать выполнения как второго, так и третьего пункта.
 хотя структура позволяет поддерживать несколько независимых подсистем окружения, с практической точки зрения было бы неудобно включать в состав каждой подсистемы свой код для обработки окон и отображения ввода-вывода. это привело бы к дублированию системных функций и в конечном счете негативно отразилось бы на объеме и производительности системы. поскольку главной подсистемой была , разработчики решили разместить эти базовые функции именно в ней. так что другие подсистемы для отображения ввода-вывода вызывают соответствующие сервисы . (кстати, посмотрев на тип подсистемы в заголовках их файлов, вы убедитесь, что фактически они являются исполняемыми файлами .)
 теперь поближе познакомимся с каждой подсистемой окружения.
подсистема 
 эта подсистема состоит из следующих основных элементов.
  процесса подсистемы окружения (.), предоставляющего:
  поддержку консольных (текстовых) окон;
  поддержку создания и удаления процессов и потоков;
  частичную поддержку процессов 16-разрядной виртуальной -машины ();
  множество других функций, например , , , а также несколько функций поддержки естественных языков.
  драйвера режима ядра (32.), включающего:
  диспетчер окон, который управляет отрисовкой и выводом окон на экран, принимает ввод с клавиатуры, мыши и других устройств, а также передает пользовательские сообщения приложениям;
  (), который представляет собой библиотеку функций для устройств графического вывода. входят функции для манипуляций с графикой и отрисовки линий, текста и фигур.
  -модулей подсистем (32., 32., 32. и 32.), транслирующих вызовы документированных функций в вызовы соответствующих (и в большинстве своем недокументированных) сервисов режима ядра из . и 32..
  драйверов графических устройств, представляющих собой специфичные для конкретного оборудования драйверы графического дисплея, принтера и минипорт-драйверы видеоплат.
 для формирования элементов управления пользовательского интерфейса на экране, например окон и кнопок, приложения могут вызывать стандартные функции . диспетчер окон передает эти вызовы , а тот - драйверам графических устройств, где они форматируются для дисплея. драйвер дисплея работает в паре с соответствующим минипорт-драйвером видеоплаты, обеспечивая полную поддержку видео.
 предоставляет набор стандартных функций двухмерной графики, которые позволяют приложениям, не имеющим представления о графических устройствах, обращаться к ним. -функции играют роль посредника между приложениями и драйверами дисплея и принтера. интерпретирует запросы приложений на вывод графики и посылает соответствующие запросы драйверам. он также предоставляет приложениям стандартный унифицированный интерфейс для использования самых разнообразных устройств графического вывода. этот интерфейс обеспечивает независимость кода приложений от конкретного оборудования и его драйверов. выдает свои запросы с учетом возможностей конкретного устройства, часто разделяя запрос на несколько частей для обработки. так, некоторые устройства сами умеют формировать эллипсы, а другие требуют от интерпретировать эллипсы как набор пикселов с определенными координатами. подробнее об архитектуре подсистемы вывода графики и драйвере дисплея см. раздел « » в книге « » из .
 до 4 диспетчер окон и графические сервисы были частью процесса подсистемы пользовательского режима. 4 основная часть кода, ответственного за обработку окон и графики, перенесена из контекста процесса подсистемы в набор вызываемых сервисов, выполняемых в режиме ядра (в файл 32.). этот перенос был осуществлен в основном для повышения общей производительности системы. отдельный серверный процесс, содержащий графическую подсистему, требовал многочисленных переключений контекста потоков и процессов, что отнимало большое количество тактов процессора и значительные ресурсы памяти, даже несмотря на высокую оптимизацию исходной архитектуры этой подсистемы.
 например, каждый клиентский поток обслуживается парным серверным потоком в процессе подсистемы , ожидающем запросов от клиентского потока. для передачи сообщений между потоками используется специальный механизм взаимодействия между процессами, так называемый быстрый ( ). отличие от обычного переключения контекста потоков передача данных между парными потоками через быстрый не вызывает в ядре события перепланирования, что позволяет серверному потоку выполняться в течение оставшегося кванта времени клиентского потока (вне очереди, определенной планировщиком). более того, для быстрой передачи больших структур данных, например битовых карт, используются разделяемые буферы памяти, и клиенты получают прямой доступ (только для чтения) к ключевым структурам данных сервера, а это сводит к минимуму необходимость в частом переключении контекста между клиентами и сервером .
 -операции выполняются в пакетном режиме. при этом серия графических объектов, запрошенных -приложениями, не обрабатывается сервером и не прорисовывается на устройстве вывода до тех пор, пока не будет заполнена вся очередь . размер очереди можно установить через -функцию . любой момент все объекты из очереди можно сбросить вызовом функции . другой стороны, неизменяемые свойства и структуры данных после получения от процессов подсистемы кэшируются клиентскими процессами для ускорения последующего доступа к ним.
 однако, несмотря на такую оптимизацию, общая производительность системы по-прежнему не соответствовала требованиям приложений, интенсивно работающих с графикой. очевидным решением проблемы стал перевод подсистемы поддержки окон и графики в режим ядра, что позволило избежать потребности в дополнительных потоках и связанных с ними переключениями контекста. кроме того, как только приложения вызывают диспетчер окон и , эти подсистемы теперь получают прямой доступ к компонентам исполнительной системы без перехода из пользовательского режима в режим ядра и обратно. прямой доступ особенно важен в случае вызова через видеодрайверы, когда взаимодействие с видеооборудованием требует высокой пропускной способности.
 так что же остается в той части процесса подсистемы , которая работает в пользовательском режиме? поскольку консольные программы не перерисовывают окна, все операции по отрисовке и обновлению консольных и текстовых окон проводятся именно этой частью . увидеть ее деятельность несложно: просто откройте окно командной строки и перетащите поверх него другое окно. вы увидите, что процесс подсистемы начинает расходовать процессорное время, перерисовывая консольное окно. кроме поддержки консольных окон, только небольшая часть -функций посылает сообщения процессу подсистемы . ним относятся функции, отвечающие за создание и завершение процессов и потоков, назначение букв сетевым дискам, создание временных файлов. как правило, -приложение нечасто переключает (если вообще переключает) контекст в процесс подсистемы .
 пострадала ли стабильность от перевода и в режим ядра?
 некоторые интересуются, не повлияет ли на стабильность системы перевод такой значительной части кода в режим ядра. риск снижения стабильности системы минимален. дело в том, что до 4 (равно как и в настоящее время) ошибка вроде нарушения доступа ( ) в процессе подсистемы пользовательского режима (.) приводила к краху системы, потому что процесс подсистемы был и остается жизненно важным для функционирования всей системы. поскольку структуры данных, определяющие окна на экране, содержатся именно в этом процессе, его гибель приводит к уничтожению пользовательского интерфейса. однако даже при функционировании в качестве сервера без интерактивных процессов система не могла бы работать без , поскольку серверные процессы иногда используют оконные сообщения для контроля внутреннего состояния приложений. так что в ошибки вроде нарушения доступа в том же коде, только выполняемом в режиме ядра, просто быстрее приводят к краху - исключения в режиме ядра требуют прекращения работы системы.
 правда, теоретически появляется другая опасность. поскольку этот код выполняется в режиме ядра, ошибка (например, применение неверного указателя) может повредить защищенные структуры данных режима ядра. до 4 это могло привести к нарушению доступа, так как запись в страницы режима ядра из пользовательского режима не разрешается. результатом стал бы крах системы. теперь же при выполнении кода в режиме ядра запись на какую-либо страницу памяти по неверному указателю не обязательно вызовет немедленный крах системы. , если при этом будут повреждены какие-то структуры данных, крах скорее всего произойдет. тем не менее возникает риск, что из-за такого указателя будет повреждена не структура данных, а буфер памяти, и это приведет к возврату пользовательской программе или записи на диск неверных данных.
 существует еще одно негативное последствие перевода графических драйверов в режим ядра. ранее некоторые части графического драйвера выполнялись в , а остальные части - в режиме ядра. теперь весь драйвер работает только в режиме ядра. так как не все драйверы поддерживаемых графических устройств разрабатываются , она тесно сотрудничает с производителями оборудования, чтобы гарантировать разработку ими надежных и эффективных драйверов. все поставляемые с системой драйверы тестируются так же тщательно, как и другие компоненты исполнительной системы.
 наконец, важно понимать, что такая схема (при которой подсистема поддержки окон и графики выполняется в режиме ядра) не является принципиально рискованной. идентичный подход используется для многих других драйверов устройств (например, сетевых карт и жестких дисков). все эти драйверы, выполняемые в режиме ядра, никогда не снижали надежности 
 некоторые распространяют измышления насчет снижения эффективности вытесняющей многозадачности из-за перевода диспетчера окон и в режим ядра. теория, которая стоит за этой точкой зрения, - увеличивается время, затрачиваемое на дополнительную обработку в режиме ядра. это мнение возникло в результате ошибочного понимания архитектуры . действительно, во многих других операционных системах, формально поддерживающих вытесняющую многозадачность, планировщик никогда не вытесняет потоки, выполняемые в режиме ядра, или вытесняет, но лишь в отдельных ситуациях. однако в любые потоки, выполняемые в режиме ядра, планируются и вытесняются так же, как и потоки пользовательского режима, - код исполнительной системы полностью реентерабелен. помимо многих других соображений, это просто необходимо для достижения высокого уровня масштабируемости системы на оборудовании с поддержкой .
 другое направление спекуляций касалось снижения масштабируемости в результате уже описанных изменений. теоретические обоснования были такими: раньше во взаимодействии между приложением и диспетчером окон или участвовали два потока-, один - в приложении и один - в .. поэтому в -системах, где эти потоки могут выполняться параллельно, пропускная способность возрастает. это свидетельствует о непонимании технологий, применявшихся до 4. большинстве случаев клиентские приложения вызывают процесс подсистемы синхронно, т. е. клиентский поток полностью блокируется в ожидании обработки вызова серверным потоком и возобновляется только после этого. так что никакой параллелизм в -системах недостижим. это явление легко наблюдать в -системах на примере приложений, интенсивно работающих с графикой. при этом обнаружится, что в двухпроцессорной системе каждый процессор загружен на 50 %; также легко заметить единственный поток , отделенный от потока приложения. действительно, поскольку два потока тесно взаимодействуют и находятся в сходном состоянии, для поддержания синхронизации процессорам приходится постоянно сбрасывать кэш. именно по этой причине однопоточные графические приложения в -системах под управлением 3.51 обычно выполняются медленнее, чем в однопроцессорных системах.
 результате изменений, внесенных в 4, удалось повысить пропускную способность -систем для приложений, интенсивно использующих диспетчер окон и , - особенно когда в приложении работает более одного потока. при наличии двух потоков приложения на двухпроцессорной машине под управлением 3.51 за процессорное время конкурируют в общей сложности четыре потока (два - в приложении и два - в ). хотя в каждый момент к выполнению готовы, как правило, лишь два потока, их рассогласованность ведет к потере локальности ссылок и синхронизации кэша. это происходит скорее всего из-за переключения потоков приложения с одного процессора на другой. 4 каждый из двух потоков приложения по сути имеет собственный процессор, а механизм автоматической привязки потоков в пытается постоянно выполнять данный поток на одном и том же процессоре, максимально увеличивая локальность ссылок и сводя к минимуму потребность в синхронизации кэш-памяти индивидуальных процессоров.
 заключение отметим, что повышение производительности в результате перевода диспетчера окон и из пользовательского режима в режим ядра достигнуто без сколько-нибудь значимого снижения стабильности и надежности системы - даже в случае нескольких сеансов, созданных в конфигурации с поддержкой .
подсистема 
 , название которой представляет собой аббревиатуру от « » (переносимый интерфейс операционной системы на основе ), - это совокупность международных стандартов на интерфейсы операционных систем типа . стандарты стимулировали производителей поддерживать совместимость реализуемых ими -подобных интерфейсов, тем самым позволяя программистам легко переносить свои приложения между системами.
 реализован лишь один из многих стандартов , а именно ., который официально называется / 9945-1:1990, или стандарта 1003 1-1990. этот стандарт изначально был включен в основном для соответствия требованиям правительства сша, установленным во второй половине 80-х годов. федеральном стандарте () 151-2, разработанном государственным институтом стандартов и технологий (), содержится требование совместимости с . 3.5, 3.51 и 4 прошли тестирование на соответствие 151-2.
 поскольку совместимость с . 1 была одной из обязательных целей, в включена необходимая базовая поддержка подсистемы 1 - например, функция , реализованная в исполнительной системе , и поддержка файловой системой жестких файловых связей ( ). однако . определяетлишь ограниченный набор сервисов (управление процессами, взаимодействие между процессами, простой символьный ввод-вывод и т. д.), и поэтому подсистема в не является полноценной средой программирования. так как вызов функций из разных подсистем невозможен, набор функций, доступный приложениям по умолчанию, строго ограничен сервисами, определяемыми 1. смысл этих ограничений в следующем: приложение не может создать поток или окно в , а также использовать или сокеты.
 для преодоления этого ограничения предназначен продукт , включающий (в версии 3.5) улучшенную подсистему окружения , которая предоставляет около 2000 функций и 300 инструментов и утилит в стиле . (детали см. на ./ //.). 
 эта улучшенная подсистема реально помогает переносить -приложения в . однако, поскольку эти программы все равно связаны с исполняемыми файлами , -функции им недоступны. чтобы -приложения, переносимые в , могли использовать -функции, нужно приобрести специальные пакеты для переноса -программ в , подобные продуктам , разработанные компанией . (..). тогда -приложения можно перекомпилировать и заново собрать как исполняемые файлы и начать постепенный переход на «родные» -функции.
 эксперимент: наблюдаем старт подсистемы 
 подсистема по умолчанию сконфигурирована на запуск в момент начала выполнения приложения . таким образом, старт подсистемы можно наблюдать, запустив какую-нибудь программу , например одну из утилит из (небольшой набор утилит вы найдете и в каталоге \\ на компакт-диске ресурсов 2000; они не устанавливаются как часть ресурсов). для запуска подсистемы следуйте инструкциям, приведенным ниже.
 1. откройте окно командной строки.
 2. запустите и убедитесь, что подсистема еще не запущена (т. е. процесса . в системе нет). также убедитесь, что отображает список процессов как дерево (нажмите +).
 3. запустите -программу (например или , поставляемую с ) или утилиту из ресурсов 2000, например \\\..
 4. вернитесь в и обратите внимание на новый процесс ., являющийся дочерним процессом . (который в зависимости от выбранного интервала подсветки может какое-то время оставаться выделенным как новый процесс).
 для компиляции и сборки приложения в нужны заголовочные файлы и библиотеки из . исполняемые файлы связываются с библиотекой подсистемы , .. поскольку по умолчанию сконфигурирована на запуск подсистемы только по требованию, при первом запуске приложения должен запуститься процесс подсистемы (.). его выполнение продолжается до перезагрузки системы. (если вы завершите процесс подсистемы , запуск приложений станет невозможен до следующей перезагрузки системы.) приложение не выполняется самостоятельно; для него запускается специальный файл поддержки ., создающий дочерний процесс, из которого и запускаются приложения .
подсистема /2
 подсистема окружения /2, как и подсистема , обладает довольно ограниченной функциональностью и поддерживает лишь 16-разрядные приложения /2 версии 1.2 с символьным или графическим вводом-выводом. кроме того, запрещает прикладным программам прямой доступ к оборудованию и поэтому не поддерживает приложения /2, использующие расширенный ввод-вывод видео или включающие сегменты привилегированного ввода-вывода, которые пытаются выполнять инструкции / (для доступа к некоторым аппаратным устройствам). приложения, выдающие машинные команды /, могут работать в , но на время выполнения команды все другие приложения /2 в системе и потоки процессов /2, выдающих команды , приостанавливаются.
 как показано на рис. 2-5, подсистема /2, использующая 32-разрядное виртуальное адресное пространство , может предоставить приложениям /2 версии 1.2 до 512 мб памяти, снимая тем самым исходное ограничение этой версии на объем адресуемой памяти (до 16 мб).
 мозаичная область ( ) - это 512 мб заранее резервируемого виртуального адресного пространства, откуда передается и куда возвращается память, выделяемая под сегменты, которыми пользуются 16-разрядные приложения. для каждого процесса подсистема /2 ведет таблицу локальных дескрипторов ( , ), в которой сегменты разделяемой памяти занимают один и тот же -слот для всех процессов /2.
 как будет детально показано в главе 6, потоки являются элементами выполняемой программы и, как таковые, подлежат планированию (подключению к процессору по определенной схеме). /2 всего 64 уровня приоритетов (от 0 до 63), а в - 32 (от 0 до 31). несмотря на это, 64 уровня приоритетов /2 проецируются на динамические приоритеты с 1-го по 15-й. потоки /2, выполняемые в , никогда не получают приоритеты реального времени (16-31).
 как и подсистема , подсистема /2 автоматически запускается при первой активизации /2-совместимого образа и продолжает выполняться до перезагрузки всей системы.
 подробнее о выполнении приложений и /2 в см. главу 6.
.
 . - специальная библиотека системной поддержки, нужная в основном при использовании подсистем. она содержит функции двух типов:
  интерфейсы диспетчера системных сервисов ( ) к сервисам исполнительной системы ;
  внутренние функции поддержки, используемые подсистемами, подсистем и другими компонентами операционной системы. первая группа функций предоставляет интерфейс к сервисам исполнительной системы , которые можно вызывать из пользовательского режима. таких функций более 200, например , и т. д. как уже говорилось, большинство из них доступно через (однако некоторые из них предназначены только для применения внутри самой операционной системы).
 для каждой из этих функций в существует точка входа с тем же именем. код внутри функции содержит специфичную для конкретной аппаратной архитектуры команду перехода в режим ядра для вызова диспетчера системных сервисов (о нем рассказывается в главе 3), который после проверки некоторых параметров вызывает уже настоящий сервис режима ядра из ..
 также включает множество функций поддержки, например загрузчик образов (функции, имена которых начинаются с ), диспетчер куч, функции для взаимодействия с процессом подсистемы (функции, имена которых начинаются с ), а также универсальные процедуры библиотек периода выполнения (функции, имена которых начинаются с ). там же находится диспетчер ( ) пользовательского режима и диспетчер исключений. (подробнее об и исключениях см. главу 3.)
исполнительная система
 исполнительная система () находится на верхнем уровне . (ядро располагается на более низком уровне). ее состав входят функции следующего типа.
  экспортируемые функции, доступные для вызова из пользовательского режима. эти функции называются системными сервисами и экспортируются через . большинство сервисов доступно через или других подсистем окружения. однако некоторые из них недоступны через документированные функции (примером могут служить , функции запросов вроде , специализированные функции типа и т. д.).
  функции драйверов устройств, вызываемые через функцию -. последняя является универсальным интерфейсом от пользовательского режима к режиму ядра для вызова функций в драйверах устройств, не связанных с чтением или записью.
  экспортируемые функции, доступные для вызова только из режима ядра и документированные в или () (см. .///..). 
  экспортируемые функции, доступные для вызова только из режима ядра, но не описанные в или (например, функции, которые используются видеодрайвером, работающим на этапе загрузки, и чьи имена начинаются с ). 
  функции, определенные как глобальные, но не экспортируемые символы. включают внутренние функции поддержки, вызываемые в ; их имена начинаются с (функции поддержки диспетчера ввода-вывода) или с (функции поддержки управления памятью).
  внутренние функции в каком-либо модуле, не определенные как глобальные символы. исполнительная система состоит из следующих основных компонентов (каждый из них подробно рассматривается в последующих главах книги).
  диспетчер конфигурации (см. главу 4), отвечающий за реализацию и управление системным реестром.
  диспетчер процессов и потоков (см. главу 6), создающий и завершающий процессы и потоки. низкоуровневая поддержка процессов и потоков реализована в ядре , а исполнительная система дополняет эти низкоуровневые объекты своей семантикой и функциями.
  монитор состояния защиты (см. главу 8), реализующий политики безопасности на локальном компьютере. он охраняет ресурсы операционной системы, осуществляя аудит и контролируя доступ к объектам в период выполнения.
  диспетчер ввода-вывода (см. главу 9), реализующий аппаратно-независимый ввод-вывод и отвечающий за пересылку ввода-вывода нужным драйверам устройств для дальнейшей обработки.
  диспетчер (см. главу 9), определяющий, какие драйверы нужны для поддержки конкретного устройства, и загружающий их. требования каждого устройства в аппаратных ресурсах определяются в процессе перечисления. зависимости от требований каждого устройства диспетчер распределяет такие ресурсы, как порты ввода-вывода, , каналы и области памяти. он также отвечает за посылку соответствующих уведомлений об изменениях в аппаратном обеспечении системы (при добавлении или удалении устройств).
  диспетчер электропитания (см. главу 9), который координирует события, связанные с электропитанием, и генерирует уведомления системы управления электропитанием, посылаемые драйверам. когда система не занята, диспетчер можно настроить на остановку процессора для снижения энергопотребления. изменение энергопотребления отдельных устройств возлагается на их драйверы, но координируется диспетчером электропитания.
  подпрограммы (см. главу 4), позволяющие драйверам публиковать информацию о своих рабочих характеристиках и конфигурации, а также получать команды от службы
 пользовательского режима. потребители информации могут находиться как на локальной машине, так и на любом компьютере в сети.
  диспетчер кэша (см. главу 11), повышающий производительность файлового ввода-вывода за счет сохранения в основной памяти дисковых данных, к которым недавно было обращение (это также уменьшает число обращений к диску для записи, поскольку модифицированные данные предварительно накапливаются в памяти в течение определенного периода). как вы увидите, диспетчер кэша выполняет эту задачу, используя поддержку проецируемых файлов со стороны диспетчера памяти.
  диспетчер памяти (см. главу 7), реализующий виртуальную память - схему управления памятью, позволяющую выделять каждому процессу большое закрытое адресное пространство, объем которого может превышать доступную физическую память. диспетчер памяти также обеспечивает низкоуровневую поддержку диспетчера кэша.
  средство логической предвыборки (см. главу 7), ускоряющее запуск системы и процессов за счет оптимизации загрузки данных, к которым происходит обращение при запуске системы или процессов. кроме того, в состав исполнительной системы входят четыре основные группы функций поддержки, используемые вышеперечисленными компонентами. примерно треть из них описана в , поскольку драйверы тоже используют их. вот что представляют собой четыре категории функций поддержки.
  диспетчер объектов - создает, управляет и удаляет объекты и абстрактные типы данных исполнительной системы, используемые для представления таких ресурсов операционной системы, как процессы, потоки и различные синхронизирующие объекты. подробнее о диспетчере объектов см. главу 3-
  механизм (см. главу 3) - передает сообщения между клиентским и серверным процессами на одном компьютере. является гибкой, оптимизированной версией ( ), стандартного механизма взаимодействия между клиентскими и серверными процессами через сеть.
  большой набор стандартных библиотечных функций для обработки строк, арифметических операций, преобразования типов данных и обработки структур безопасности.
  подпрограммы поддержки исполнительной системы, например для выделения системной памяти (пулов подкачиваемых и неподкачиваемых страниц), доступа к памяти со взаимоблокировкой, а также два специальных типа синхронизирующих объектов: ресурс () и быстродействующий мьютекс ( ).
ядро
 ядро состоит из набора функций в ., предоставляющих фундаментальные механизмы (в том числе планирования потоков и синхронизации), которые используются компонентами исполнительной системы и низкоуровневыми аппаратно-зависимыми средствами поддержки (диспетчеризации прерываний и исключений), различными в каждой процессорной архитектуре. код ядра написан в основном на с, а ассемблер использовали лишь для решения специфических задач, трудно реализуемых на с.
 как и функции поддержки исполнительной системы, упоминавшиеся в предыдущем разделе, часть функций ядра описана в (см. функции, чьи имена начинаются с ), поскольку они необходимы для реализации драйверов устройств.
объекты ядра
 ядро состоит из низкоуровневых, четко определенных и хорошо предсказуемых примитивов и механизмов операционной системы, позволяющих компонентам исполнительной системы более высокого уровня выполнять свои функции. ядро отделено от остальной части исполнительной системы; оно реализует системные механизмы и не участвует в принятии решений, связанных с системной политикой. практически все такие решения, кроме планирования и диспетчеризации потоков, принимаются исполнительной системой.
 вне ядра исполнительная система представляет потоки и другие разделяемые ресурсы в виде объектов. управление этими объектами требует определенных издержек, так как нужны описатели, позволяющие манипулировать объектами, средства защиты и квоты ресурсов, резервируемых при их создании. ядре можно избежать таких издержек, поскольку оно реализует набор более простых объектов, называемых объектами ядра ( ). эти объекты позволяют ядру контролировать обработку данных процессором и поддерживают объекты исполнительной системы. большинство объектов уровня исполнительной системы инкапсулирует один или более объектов ядра, включая в себя их атрибуты, определенные ядром.
 одна из групп объектов ядра, называемых управляющими ( ), определяет семантику управления различными функциями операционной системы. эту группу входят объекты , ( ) и несколько объектов, используемых диспетчером ввода-вывода (например, объект прерывания).
 другая группа объектов под названием объекты диспетчера ( ) реализует средства синхронизации, позволяющие изменять планирование потоков. группу таких объектов входят поток ядра ( ), мьютекс (), событие (), семафор (), таймер (), ожидаемый таймер ( ) и некоторые другие. помощью функций ядра исполнительная система создает объекты ядра, манипулирует ими и конструирует более сложные объекты, предоставляемые в пользовательском режиме. объекты подробно рассматриваются в главе 3, а процессы и потоки - в главе 6.
поддержка оборудования
 другая важная задача ядра - абстрагирование или изоляция исполнительной системы и драйверов устройств от различий между аппаратными архитектурами, поддерживаемыми (т. е. различий в обработке прерываний, диспетчеризации исключений и синхронизации между несколькими процессорами).
 архитектура ядра нацелена на максимальное обобщение кода - даже в случае аппаратно-зависимых функций. ядро поддерживает набор семантически идентичных и переносимых между архитектурами интерфейсов. большая часть кода, реализующего переносимые интерфейсы, также идентична для разных архитектур.
 одна часть этих интерфейсов по-разному реализуется на разных архитектурах, а другая включает код, специфичный для конкретной архитектуры. архитектурно-независимые интерфейсы могут быть вызваны на любой машине, причем семантика интерфейса будет одинаковой - независимо от специфического кода для той или иной архитектуры. некоторые интерфейсы ядра (например, процедуры спин-блокировки, описанные в главе 3) на самом деле реализуются в (см. следующий раздел), поскольку их реализация может отличаться даже в пределах семейства процессоров с одинаковой архитектурой.
 ядре также содержится небольшая порция кода с х86-специфичными интерфейсами, необходимыми для поддержки старых программ -. эти интерфейсы не являются переносимыми в том смысле, что их нельзя вызывать на машине с другой архитектурой, где они попросту отсутствуют. этот х86-специфичный код, например, поддерживает манипуляции с ( ) и ( ) - аппаратными средствами 86.
 другим примером архитектурно-специфичного кода ядра может служить интерфейс, предоставляющий поддержку буфера трансляции и процессорного кэша. эта поддержка требует разного кода на разных архитектурах, поскольку кэш в них реализуется различным образом.
 еще один пример - переключение контекста. хотя на высоком уровне для выбора потоков и переключения контекста применяется один и тот же алгоритм (сохраняется контекст предыдущего потока, загружается контекст нового и запускается новый поток), существуют архитектурные различия между его реализациями для разных процессоров. поскольку контекст описывается состоянием процессора (его регистров и т. д.), сохраняемая и загружаемая информация зависит от архитектуры.
уровень абстрагирования от оборудования
 как отмечалось в начале этой главы, одной из важнейших особенностей архитектуры является переносимость между различными аппаратными платформами. ключевой компонент, обеспечивающий такую переносимость, - уровень абстрагирования от оборудования ( , ). - это загружаемый модуль режима ядра (.), предоставляющий низкоуровневый интерфейс с аппаратной платформой, на которой выполняется . он скрывает от операционной системы специфику конкретной аппаратной платформы, в том числе ее интерфейсов ввода-вывода, контроллеров прерываний и механизмов взаимодействия между процессорами, т. е. все функции, зависимые от архитектуры и от конкретной машины.
 когда внутренним компонентам и драйверам устройств нужна платформенно-зависимая информация, они обращаются не к самому оборудованию, а к подпрограммам , что и обеспечивает переносимость этой операционной системы. по этой причине подпрограммы документированы в , где вы найдете более подробные сведения о и о его использовании драйверами.
 хотя в имеется несколько модулей (см. таблицу 2-6), при установке на жесткий диск компьютера копируется только один из них - .. ( других операционных системах, например в , нужный модуль выбирается при загрузке системы.) поскольку для поддержки разных процессоров требуются разные модули , системный диск от одной х86-установки скорее всего не подойдет для загрузки системы с другим процессором.
 таблица 2-6. список модулей для 86 в \ \\\386\. 
 примечание базовой системе 2003 нет , специфических для конкретных вендоров. 
 эксперимент: просмотр базовых , включенных в 
 для просмотра , включенных в , откройте файл . в соответствующем подкаталоге, специфичном для конкретной архитектуры, в каталоге \\ . (например, для систем 86 имя этого файла - \\ \386\..) прокрутите список до файлов, начинающихся с «», и вы увидите файлы, перечисленные в таблице 2-6.
 эксперимент: определяем используемый модуль 
 определить, какой модуль используется на вашей машине, можно двумя способами.
 1. откройте файл \\\., найдите строку с . имя файла, стоящее в этой строке после знака равенства, соответствует имени модуля , извлеченного из . с дистрибутивного носителя.
 2. откройте (диспетчер устройств): щелкните правой кнопкой мыши значок (мой компьютер) на рабочем столе, выберите команду (свойства), откройте вкладку (оборудование) и щелкните кнопку (диспетчер устройств). проверьте имя «драйвера» для устройства (компьютер).
 эксперимент: просмотр зависимостей и 
 вы можете просмотреть взаимосвязи образов ядра и , изучив их таблицы импорта и экспорта с помощью утилиты (.), которая содержится в и . для исследования файла в откройте его командой из меню .
 вот пример вывода этой утилиты при просмотре зависимостей в .
 обратите внимание, что связан с , который в свою очередь связан с (оба используют функции друг у друга). также связан с ., видеодрайвером, используемым для вывода заставки при запуске . и выше вы увидите в списке дополнительную , .. она содержит код инфраструктуры отладчика ядра, который раньше был частью ..
 подробное описание информации, выводимой , см. в справочном файле этой утилиты (.).
драйверы устройств
 драйверы устройств подробно описываются в главе 9, а здесь мы даем краткий обзор их типов и поясняем, как перечислить установленные драйверы, загруженные в системе.
 драйверы устройств являются загружаемыми модулями режима ядра (как правило, это файлы с расширением. ); они образуют интерфейс между диспетчером ввода-вывода и соответствующим оборудованием. эти драйверы выполняются в режиме ядра в одном из трех контекстов:
  в контексте пользовательского потока, инициировавшего функцию ввода-вывода;
  в контексте системного потока режима ядра;
  как результат прерывания (а значит, не в контексте какого-либо процесса или потока, который был текущим на момент прерывания). как было сказано в предыдущем разделе, в драйверы устройств не управляют оборудованием напрямую - вместо этого они вызывают функции . драйверы, как правило, пишутся на (иногда на ++), поэтому при правильном использовании процедур они являются переносимыми между поддерживаемыми архитектурами на уровне исходного кода, а на уровне двоичных файлов - внутри семейства с одинаковой архитектурой. существует несколько типов драйверов устройств.
  драйверы аппаратныхустройств, которые управляют (через ) оборудованием, записывают на них выводимые данные и получают вводимые данные от физического устройства или из сети. есть множество типов таких драйверов - драйверы шин, интерфейсов, устройств массовой памяти и т. д.
  драйверы файловой системы - это драйверы , принимающие запросы на файловый ввод-вывод и транслирующие их в запросы ввода-вывода для конкретного устройства.
  драйверы фильтра файловой системы, которые обеспечивают зеркали-рование и шифрование дисков, перехват ввода-вывода и некоторую дополнительную обработку информации перед передачей ее на следующий уровень.
  сетевые редиректоры и серверы, являющиеся драйверами файловых систем, которые передают запросы файловой системы на ввод-вывод другим компьютерам в сети и принимают от них аналогичные запросы.
  драйверы протоколов, реализующие сетевые протоколы вроде /, и /.
  драйверы потоковых фильтров ядра, действующие по цепочке для обработки потоковых данных, например при записи и воспроизведении аудио- и видеоинформации.
 поскольку установка драйвера устройства - единственный способ добавления в систему стороннего кода режима ядра, некоторые программисты пишут драйверы просто для того, чтобы получить доступ к внутренним функциям или структурам данных операционной системы, недоступным из пользовательского режима (но документированным и поддерживаемым в ). например, многие утилиты с .. представляют собой комбинацию -приложений с драйверами устройств, используемыми для сбора сведений о состоянии внутрисистемных структур и вызова функций, доступных только в режиме ядра.
усовершенствования в модели драйверов 
 2000 была введена поддержка и энергосберегающих технологий, а также расширена модель драйверов , называемая (). 2000 и более поздние версии могут работать с унаследованными драйверами 4, но, поскольку они не поддерживают и энергосберегающие технологии, функциональность системы в этом случае будет ограничена. точки зрения , существует три типа драйверов.
  драйвер шины ( ), обслуживающий контроллер шины, адаптер, мост или любые другие устройства, имеющие дочерние устройства. драйверы шин нужны для работы системы и в общем случае поставляются . для каждого типа шины (, и ) в системе имеется свой драйвер. сторонние разработчики создают драйверы для поддержки новых шин вроде , и .
  функциональный драйвер ( ) - основной драйвер устройства, предоставляющий его функциональный интерфейс. обязателен, кроме тех случаев, когда устройство используется без драйверов (т. е. ввод-вывод осуществляется драйвером шины или драйверами фильтров шины, как в случае ). функциональный драйвер по определению обладает наиболее полной информацией о своем устройстве. обычно только этот драйвер имеет доступ к специфическим регистрам устройства.
  драйвер фильтра ( ), поддерживающий дополнительную функциональность устройства (или существующего драйвера) или изменяющий запросы на ввод-вывод и ответы на них от других драйверов (это часто используется для коррекции устройств, предоставляющих неверную информацию о своих требованиях к аппаратным ресурсам). такие драйверы не обязательны, и их может быть несколько. они могут работать как на более высоком уровне, чем функциональный драйвер или драйвер шины, так и на более низком. обычно эти драйверы предоставляются -производителями или независимыми поставщиками оборудования ().
 среде один драйвер не может контролировать все аспекты устройства: драйвер шины информирует диспетчер об устройствах, подключенных к шине, в то время как функциональный драйвер управляет устройством.
 большинстве случаев драйвер фильтра более низкого уровня модифицирует поведение устройства. например, если устройство сообщает драйверу своей шины о том, что ему нужно 4 порта ввода-вывода, тогда как на самом деле ему требуется 16, драйвер фильтра может перехватить список аппаратных ресурсов, направляемый драйвером шины диспетчеру и исправить число портов.
 драйвер фильтра более высокого уровня обычно придает устройству дополнительную функциональность. так, высокоуровневый драйвер фильтра для клавиатуры может обеспечивать дополнительную защиту.
 обработка прерываний описывается в главе 3. подробнее о диспетчере ввода-вывода, , и энергосберегающих технологиях см. главу 9.
 эксперимент: просмотр установленных драйверов устройств 
 чтобы вывести список установленных драйверов, запустите оснастку (управление компьютером). для этого выберите из меню (пуск) команду (программы), затем (администрирование) и (управление компьютером) или откройте (панель управления) и дважды щелкните значок . окне раскройте (сведения о системе), затем (программная среда) и (драйверы). ниже приведен пример списка драйверов.
 этом окне выводится список драйверов, определенных в реестре, а также их тип и состояние - (работает) или (остановлена). драйверы устройств и процессы -сервисов определяются в разделе реестра \\\. однако они отличаются по коду типа, например 1 соответствует драйверу режима ядра. (полный список хранящихся в реестре сведений, которые относятся к драйверам, см. в таблице 4-7.)
 список загруженных в текущий момент драйверов можно просмотреть и с помощью утилиты (. в ресурсах 2000) или (. в , 2003 , ресурсах 2000 и ). ниже приведен листинг части выходной информации утилиты .
 утилита перечисляет все загруженные компоненты режима ядра (, и драйверы устройств) и сообщает размеры разделов в каждом образе.
 также выводит список загруженных драйверов, но только после списка процессов и потоков в каждом процессе. она показывает один вид очень важной информации, не сообщаемой утилитой : адрес загрузки модуля в системном пространстве. как вы еще увидите, этот адрес нужен для увязки выполняемых системных потоков с драйвером, в котором они существуют.
недокументированные интерфейсы
 просмотр имен экспортируемых или глобальных символов в ключевых системных файлах (., . или .) может оказаться полезным: вы получите представление о том, что умеет делать в сравнении с документированной и поддерживаемой частью. конечно, знание имен этих функций еще не означает, что вы сможете или должны их вызывать. эти интерфейсы не документированы и могут быть изменены. мы предлагаем рассмотреть эти функции только для лучшего понимания внутренних функций , а не для обхода поддерживаемых интерфейсов.
 например, просмотрев список функций в ., вы сможете сравнить список всех системных сервисов, которые предоставляет -модулям подсистем пользовательского режима, с их подмножеством, предоставляемым каждой подсистемой. хотя многие из этих функций точно соответствуют документированным и поддерживаемым -функциям, некоторые из них недоступны через (см. статью « » на .). 
 другой стороны, было бы интересно выяснить, что импортируют -модули подсистемы (скажем, 32. или -32.) и какие функции они вызывают в .
 также представляет интерес содержимое .: хотя в документированы многие экспортируемые подпрограммы, используемые драйверами режима ядра, немалая их часть не описана. возможно, вас заинтересует содержимое таблицы импорта для и , где перечислены функции , используемые , и наоборот.
 таблице 2-7 приведено большинство общеупотребительных префиксов имен функций в компонентах исполнительной системы. каждом из таких компонентов также используются слегка модифицированные префиксы, обозначающие внутренние функции: либо за первой буквой префикса указывается / (от ), либо префикс заканчивается на букву (от ). так, относится к внутренним функциям ядра, - к внутренним функциям поддержки процессов.
 понимая схему именования системных процедур , расшифровывать имена экспортируемых функций гораздо легче. общий формат выглядит так:
 ‹префикс›‹операция›‹объект› 
 где префикс - внутренний компонент, экспортирующий процедуру, операция - название операции, выполняемой над объектом или ресурсом, а объект - объект, над которым проводится эта операция.
 например, является процедурой поддержки исполнительной системы, которая выделяет память из пула подкачиваемых или неподкачиваемых страниц. представляет собой процедуру для создания и инициализации объекта ядра «поток».
системные процессы
 каждой системе выполняются перечисленные ниже процессы. (два из них, и , не являются процессами в строгом смысле этого слова, поскольку они не выполняют какой-либо код пользовательского режима.)
  процесс (включает по одному потоку на процессор для учета времени простоя процессора).
  процесс (содержит большинство системных потоков режима ядра).
  диспетчер сеансов (.).
  подсистема (.).
  процесс входа в систему (.).
  диспетчер управления сервисами (.) и создаваемые им дочерние процессы сервисов (например, универсальный процесс для хостинга сервисов, .).
  серверный процесс локальной аутентификации (.).
 чтобы понять взаимоотношения этих процессов, полезно просмотреть «дерево» процессов, отражающее связи между родительскими и дочерними процессами. увидев, кем создается тот или иной процесс, вам будет легче понять, откуда берется каждый процесс. рис. 2-6 показана часть экранного снимка дерева процессов с комментариями по нескольким первым процессам. ( позволяет добавлять комментарии для индивидуальных процессов и выводить их как дополнительную колонку в окне.)
 следующих разделах поясняются основные системные процессы, перечисленные на рис. 2-6. хотя в этих разделах дается краткое описание последовательности запуска данных процессов, подробно все этапы загрузки рассматриваются в главе 5.
процесс 
 первый процесс, показанный на рис. 2-6, является процессом простоя системы ( ). как будет показано в главе 6, процессы идентифицируются по именам их образов. однако этот процесс (как и процесс ) не выполняет реальный код пользовательского режима (в том смысле, что в каталоге \ нет « .»). кроме того, разные утилиты из-за особенностей реализации по-разному именуют его. таблице 2-8 приводится несколько имен процесса (с идентификатором 0); подробнее о нем рассказывается в главе 6.
 теперь рассмотрим системные потоки и предназначение каждого системного процесса, выполняющего реальный код.
прерывания и 
 две строки, помеченные как и , отражают время, затраченное на обслуживание прерываний и обработку отложенных вызовов процедур ( , ). эти механизмы объясняются в главе 3. заметьте: хотя показывает эти строки в списке процессов, они не имеют отношения к процессам. они выводятся потому, что ведут учет процессорного времени, не выделенного какому-либо процессу. (диспетчер задач) рассматривает время, затраченное на обработку преры-
 ваний и , как время простоя системы. поэтому система, занятая интенсивной обработкой прерываний, будет выглядеть в так, будто она ничем не занимается.
процесс и его потоки
 процесс (с идентификатором 8 в 2000 и идентификатором 4 в и 2003) служит носителем особых потоков, работающих только в режиме ядра, - системных потоков режима ядра (- ). у системных потоков имеются все атрибуты и контексты обычных потоков пользовательского режима (например, контекст оборудования, приоритет и т. д.), но они отличаются тем, что выполняются только в режиме ядра внутри системного кода, загруженного в системное пространство, - будь то . или какой-либо драйвер устройства. кроме того, у системных потоков нет адресного пространства пользовательского процесса, и поэтому нужная им динамическая память выделяется из куч памяти операционной системы, например из пула подкачиваемых или неподкачиваемых страниц.
 системные потоки создаются функцией (документирована в ), вызываемой только в режиме ядра. , как и драйверы устройств, создает системные потоки при инициализации системы для выполнения действий, требующих получения контекста потока, например для выдачи и ожидания запросов на ввод-вывод или опроса устройства. скажем, диспетчер памяти использует системные потоки для реализации таких функций, как запись измененных страниц в страничный файл ( ) или в спроецированные файлы, загрузки процессов в память или выгрузки из нее и т. д. ядро создает системный поток под названием «диспетчер настройки баланса» ( ), активизируемый раз в секунду для инициации при необходимости различных событий, связанных с планированием и управлением памятью. диспетчер кэша также использует системные потоки для реализации как опережающего чтения, так и отложенной записи. драйвер файл-сервера (.) с помощью системных потоков отвечает на сетевые запросы ввода-вывода применительно к файлам на общих дисковых разделах, доступных в сети. даже драйвер дисковода гибких дисков создает свой системный поток для опроса этого устройства (это повышает эффективность опроса, потому что драйвер дисковода гибких дисков, управляемый прерываниями, расходует много системных ресурсов). подробнее о конкретных системных потоках см. главы, где рассматриваются соответствующие компоненты.
 по умолчанию владельцем системных потоков является процесс , но драйверы могут создавать системные потоки в любом процессе. например, драйвер подсистемы (32.) создает системные потоки в процессе подсистемы (.), чтобы облегчить доступ к данным в адресном пространстве этого процесса в пользовательском режиме.
 если вы занимаетесь поиском причин неполадок или системным анализом, полезно сопоставить выполнение индивидуальных системных потоков с создавшими их драйверами или даже с подпрограммой, содержащей соответствующий код. так, на сильно загруженном файл-сервере процесс скорее всего потребляет значительную часть процессорного времени. для определения того, какой именно драйвер или компонент операционной системы выполняется, просто знать, что процесс в данный момент выполняет «какой-то системный поток», недостаточно.
 так что, если в процессе выполняются потоки, сначала определите, какие это потоки (например, с помощью оснастки ). найдя такой поток (или потоки), посмотрите, в каком драйвере началось выполнение системного потока (это по крайней мере укажет на наиболее вероятного создателя потока), либо проанализируйте стек вызовов (или хотя бы текущий адрес) интересующего вас потока, что позволит определить, в каком месте он сейчас выполняется.
 оба этих метода демонстрируются следующими экспериментами.
 эксперимент: идентификация системных потоков в процессе 
 вы можете убедиться, что потоки внутри процесса должны быть потоками режима ядра, поскольку стартовый адрес каждого из них больше адреса начала системного пространства (которое по умолчанию начинается с 080000000, если система загружена без параметра /3 в .). кроме того, обратив внимание на процессорное время, выделяемое этим потокам, вы увидите, что они занимают процессорное время только при выполнении в режиме ядра. чтобы определить драйвер, создавший системный поток, найдите стартовый адрес потока (с помощью .) и ищите драйвер с базовым адресом, ближайшим (с меньшей стороны) к этому стартовому адресу. утилита в конце своих выходных данных, как и команда ! отладчика ядра, сообщает базовые адреса каждого загруженного драйвера устройства.
 чтобы быстро найти текущий адрес потока, воспользуйтесь командой ! 0 отладчика ядра. ниже приводится образец вывода, полученный на работающей системе с помощью .
 первом столбце выводятся идентификаторы процесса и потока (в виде «идентификатор процесса. идентификатор потока»). втором сообщается текущий адрес потока, в третьем - состояние потока: ожидает, готов или выполняется (о состояниях потоков см. главу 6). последнем столбце показывается адрес вершины стека потока. эта информация помогает определить драйвер, в котором началось выполнение того или иного потока. имя функции потока в дает дополнительную подсказку о том, что именно делает поток.
 однако, если выполняемый поток является одним из рабочих потоков системы (), вы не сможете точно сказать, что он делает, поскольку любой драйвер может давать задания рабочему потоку системы. этом случае единственный выход - поставить точку прерывания в . по достижении этой точки введите ! __ +4 . эта команда даст вам первый аргумент функции , представляющий собой указатель на структуру рабочего элемента, которая в свою очередь содержит адрес процедуры рабочего потока, вызываемой в его контексте. качестве альтернативы можно использовать команду отладчика ядра, которая сообщает текущее содержимое стека вызовов. это подскажет, какой драйвер отправил задание рабочему потоку.
 эксперимент: увязка системного потока с драйвером устройства 
 этом эксперименте мы посмотрим, как увязать активность процессора в процессе с системным потоком (и драйвером, к которому он относится), вызывающим эту активность. это важно: чтобы по-настоящему понять, что происходит, нужно перейти на уровень потоков процесса . данном случае мы вызовем активность системного потока, создав нагрузку файлового сервера на компьютере. (драйвер файл-сервера . создает системные потоки для обработки входящих запросов на файловый ввод-вывод. подробнее об этом компоненте см. главу 13.)
 1. откройте окно командной строки.
 2. создайте список всех каталогов на диске с, используя сетевой путь для доступа к этому диску. например, если имя вашего компьютера - , введите \\\$ /. (ключ / заставляет перечислять все подкаталоги.)
 3. запустите и дважды щелкните процесс .
 4. откройте вкладку .
 5. отсортируйте список по столбцу (разница по числу переключений контекста). вы должны увидеть один или более потоков в ., как показано на следующей иллюстрации.
 если вы видите работающий системный поток и не уверены, какой это драйвер, нажмите кнопку , которая открывает окно свойств для файла. например, нажатие кнопки при выбранном, как на предыдущей иллюстрации, потоке в . выводит результаты в следующем окне.
диспетчер сеансов ()
 диспетчер сеансов ( ) (\\32\.) является первым процессом пользовательского режима, создаваемым в системе. он порождается системным потоком режима ядра, отвечающим за последний этап инициализации исполнительной системы и ядра.
 диспетчер сеансов отвечает за некоторые важные этапы запуска , такие как создание дополнительных страничных файлов, выполнение отложенных операций по копированию, переименованию и удалению файлов, а также создание системных переменных окружения. он также запускает процессы подсистем (обычно только .) и , который в свою очередь создает остальные системные процессы.
 значительная часть сведений о конфигурации, хранящихся в реестре и используемых при инициализации , находится в \\-\\ . некоторые из этих данных поясняются в главе 5 в разделе по . (более подробное описание разделов и параметров см. в справочном файле . из ресурсов 2000).
 после выполнения этих этапов инициализации главный поток переходит к бесконечному ожиданию описателей процессов и . так как от них зависит функционирование , при неожиданном завершении любого из них вызывает крах системы (с кодом _ _, или 0000021). также ожидает запросы на загрузку, события отладки и запросы на запуск новых сеансов сервера терминала. (описание служб терминала см. в главе 1.)
 сеанс создается . когда получает запрос на создание сеанса, он сначала вызывает с запросом на настройку сеансовых структур данных режима ядра. это приводит к вызову внутренней функции диспетчера памяти , настраивающей виртуальное адресное пространство сеанса, которое будет содержать пул подкачиваемой памяти для сеанса и сеансовые структуры данных, создаваемые подсистемой (а точнее, ее частью, работающей в режиме ядра), а также другими драйверами устройств. (детали см. в главе 7). затем создает экземпляр и для данного сеанса.
, и 
 процесс входа (\\32\.) обрабатывает интерактивный вход пользователя в систему и выход из нее. при нажатии комбинации клавиш ( ) получает уведомление о запросе пользователя на вход в систему. по умолчанию в представляет собой комбинацию клавиш ++. назначение - защита пользователя от программ перехвата паролей, имитирующих процесс входа в систему, так как эту комбинацию клавиш нельзя перехватить в приложении пользовательского режима.
 идентификация и аутентификация при входе в систему реализованы в заменяемой под названием ( ). стандартная , ., реализует интерфейс для входа в систему по умолчанию. однако разработчики могут включать свои , реализующие другие механизмы аутентификации и идентификации вместо стандартного метода на основе проверки имени и пароля пользователя - например, на основе распознавания образцов голоса. кроме того, может загружать дополнительные компонентов сетевого доступа для дальнейшей аутентификации. эта функция позволяет нескольким компонентам доступа к сетям единовременно собирать все необходимые регистрационные данные в процессе обычного входа в систему.
 после ввода имя и пароль пользователя посылаются для проверки серверному процессу локальной аутентификации ( , ) (\\32\., описываемому в главе 8). вызывает соответствующую функциональность (реализованную в виде ) для проверки соответствия введенного пароля с тем, что хранится в активном каталоге или (части реестра, содержащей определения пользователей и групп).
 после успешной аутентификации вызывает какую-либо функцию в мониторе состояния защиты (например , ), чтобы сгенерировать объект «маркер доступа» ( ), содержащий профиль безопасности пользователя. впоследствии использует его для создания начального процесса оболочки. информация о начальном процессе (или процессах) хранится в параметре в разделе реестра \ \\ \\. (по умолчанию начальным процессом считается ., но в списке может быть более одного образа.)
 выполняет некоторые действия по инициализации пользовательской среды (например, запускает сценарии регистрации и активизирует групповые политики), а затем ищет в реестре параметр (в указанном выше разделе ) и создает процесс для запуска определенной системной оболочки (по умолчанию - .). после этого процесс завершается. вот почему для . не показывается родительский процесс - он уже завершился. иначе говоря, является «внучатым» процессом . (имена процессов, чьи родительские процессы уже завершены, в списке выравниваются по левому краю.)
 активен не только при входе и выходе пользователя, но и при перехвате ввода с клавиатуры. например, когда вы нажимаете ++ после входа в систему, открывает диалоговое окно (безопасность ), предлагающее на выбор выход из системы, запуск , блокировку рабочей станции, завершение работы системы и т. д.
 полное описание этапов процесса входа см. в разделе «, и » главы 5. подробнее об аутентификации см. главу 8. подробнее о вызываемых функциях интерфейса (чьи имена начинаются с ) см. документацию .
диспетчер управления сервисами ()
 вспомните, что термин «сервисы» в обозначает как серверные процессы, так и драйверы устройств. этом разделе обсуждаются сервисы, являющиеся процессами пользовательского режима. они похожи на демоны или обособленные процессы в том смысле, что могут быть сконфигурированы на автоматический запуск при загрузке системы, не требуя интерактивного входа. их также можно запустить вручную, например, с помощью оснастки (службы) или вызовом -функции -. как правило, сервисы не взаимодействуют с вошедшим в систему пользователем, хотя при особых условиях это возможно (см. главу 4).
 этими сервисами управляет специальный системный процесс, диспетчер управления сервисами ( ) (\\32\-.), отвечающий за запуск, остановку процессов сервисов и взаимодействие с ними. сервисы представляют собой просто -образы исполняемых программ, вызывающие особые -функции для взаимодействия с диспетчером управления сервисами и с его помощью выполняющие такие операции, как регистрация успешного запуска сервиса, ответы на запросы о состоянии, приостановку или завершение работы сервиса. сервисы определяются в разделе реестра \\\. сведения о подразделах и параметрах, относящихся к сервисам, см. в справочном файле . в ресурсах .
 учтите, что у сервисов есть три имени: имя процесса, выполняемого в системе, внутреннее имя в реестре и так называемое отображаемое имя ( ), которое можно увидеть в оснастке (службы). ( у каждого сервиса есть отображаемое имя, и в случае его отсутствия используется внутреннее имя.) сервисы также содержат поле описания, где находится более подробная информация о том, что делает конкретный сервис.
 чтобы выяснить, какие именно сервисы содержатся в том или ином процессе, введите команду /. заметьте, что иногда один процесс совместно используется несколькими сервисами. код типа в реестре позволяет узнать, какие сервисы имеют собственные процессы и какие из них делят процессы с другими сервисами данного образа файла.
 виде сервисов реализуются некоторые компоненты , например диспетчер очереди печати (спулер), журнал системных событий, планировщик задач, а также ряд сетевых компонентов.
 эксперимент: вывод списка установленных сервисов 
 чтобы вывести список установленных сервисов (служб), дважды щелкните значок (администрирование) в окне (панель управления) и выберите (службы). вы должны увидеть что-нибудь в таком роде:
 для просмотра детальных сведений о сервисе щелкните правой кнопкой мыши имя сервиса и выберите команду (свойства). ниже показан пример окна свойств для службы (диспетчер очереди печати).
 обратите внимание, что поле (исполняемый файл) указывает на программу, включающую данный сервис. помните, что некоторые сервисы разделяют процессы с другими сервисами, поэтому число сервисов и используемых ими процессов не всегда находится в соотношении «один к одному».
 эксперимент: просмотр сервисов внутри сервисных процессов 
 выделяет процессы, которые являются хостами одного и более сервисов. (для настройки поведения выберите в меню .) дважды щелкнув процесс - хост сервисов, вы откроете вкладку , где перечисляются сервисы внутри этого процесса. при этом по каждому сервису выводится имя раздела реестра, где определен данный сервис, отображаемое имя, видимое администратору, и текст описания для этого сервиса (если такой текст есть). например, в список сервисов в процессе ., выполняемом под учетной записью , выглядит следующим образом.
 подробнее о сервисах рассказывается в главе 4.
резюме
 этой главе мы познакомились с общими аспектами системной архитектуры . мы также рассмотрели ключевые компоненты и принципы их взаимодействия. следующей главе будет подробнее рассказано о базовых системных механизмах, на которые опираются эти компоненты, в том числе о синхронизации и диспетчере объектов.
 гл 3  системные механизмы
 существует несколько базовых механизмов, которыми пользуются компоненты режима ядра: исполнительная система (), ядро и драйверы устройств. этой главе описываются следующие системные механизмы (а также способы их использования):
  диспетчеризация ловушек ( ), в том числе прерываний, ( ), ( ), исключений и системных сервисов;
  диспетчер объектов исполнительной системы;
  синхронизация, в том числе спин-блокировки, объекты диспетчера ядра ( ) и реализация механизмов ожидания;
  системные рабочие потоки;
  различные механизмы вроде поддержки глобальных флагов ;
  ( );
  ;
  64.
диспетчеризация ловушек
 прерывания и исключения - такие ситуации в операционной системе, в которых нормальный поток выполнения кода процессором прерывается. эти ситуации обнаруживаются как программным, так и аппаратным обеспечением. термин ловушка () относится к механизму, благодаря которому при прерывании или исключении процессор перехватывает контроль над выполняемым потоком и передает управление определенной части операционной системы. процессор передает управление обработчику ловушек ( ) - функции, специфичной для конкретного прерывания или исключения. рис. 3-1 иллюстрирует некоторые ситуации, в которых активизируются обработчики ловушек.
 ядро различает прерывания и исключения: прерывание () является асинхронным событием (т. е. оно может произойти в любой момент независимо от текущих команд, выполняемых процессором). прерывания в основном генерируются устройствами ввода-вывода и таймерами. их можно включать и отключать. исключение (), напротив, представляет собой синхронное событие, являющееся результатом выполнения конкретной команды. повторный запуск программы в аналогичных условиях с теми же данными позволит воспроизвести исключение. примерами исключений могут служить нарушения доступа (ошибки защиты памяти), выполнение некоторых команд отладчика, а также попытки деления на нуль. ядро также считает исключениями вызовы системных сервисов (хотя с точки зрения технической реализации это системные ловушки).
 прерывания и исключения можно генерировать как программно, так и аппаратно. например, исключение « » (ошибка шины) возникает из-за аппаратной ошибки, а причиной исключения «--» (деление на нуль) является ошибка в программе. аналогичным образом прерывания могут генерироваться устройствами ввода-вывода или самим ядром (такие программные прерывания, как, например, или ).
 при аппаратном прерывании или исключении процессор записывает статусную информацию в стек ядра для прерванного потока, чтобы впоследствии можно было вернуться к исходной точке в потоке управления и продолжить выполнение команд так, будто ничего не произошло. если поток выполнялся в пользовательском режиме, переключается на стек режима ядра для потока. затем создает в стеке ядра прерванного потока фрейм ловушки ( ), в котором сохраняет информацию о состоянии потока. фрейм ловушки является подмножеством полного контекста потока (см. главу 6), и вы можете просмотреть его определение, введя в отладчике ядра команду !__. программное прерывание ядро обслуживает либо при обработке аппаратного прерывания, либо синхронно - при вызове потоком функции ядра, относящейся к данному программному прерыванию.
 большинстве случаев ядро устанавливает функции, выполняющие общую обработку ловушек до и после передачи управления другим функциям, которые ставят ловушки. например, когда устройство генерирует прерывание, обработчик ловушек аппаратных прерываний (принадлежащий ядру) передает управление процедуре обслуживания прерывания ( , ), предоставленной драйвером соответствующего устройства. если прерывание возникло в результате вызова системного сервиса, обработчик ловушек общесистемных сервисов передает управление функции указанного системного сервиса в исполнительной системе. ядро также устанавливает обработчики для ловушек, которые оно не ожидает или не обрабатывает. эти обработчики, как правило, выполняют системную функцию . она останавливает компьютер, если ядро обнаруживает в работе системы отклонения, способные привести к повреждению данных (подробнее об этом см. главу 14). диспетчеризация прерываний, исключений и системных сервисов детальнее описывается в следующих разделах.
диспетчеризация прерываний
 аппаратные прерывания обычно генерируются устройствами ввода-вывода, которые таким образом уведомляют процессор о необходимости уделить им внимание. устройства, управляемые на основе прерываний, позволяют операционной системе максимально полно использовать процессор, совмещая основную обработку с обслуживанием ввода-вывода. выдав запрос на ввод-вывод, поток может заняться другой работой, пока устройство выполняет запрошенную операцию. закончив, устройство генерирует прерывание, и процессор переключается на обслуживание этого устройства. прерываниями управляются, как правило, координатные устройства, принтеры, клавиатуры, дисковые устройства и сетевые платы.
 системное программное обеспечение также может генерировать прерывания. ядро способно отключать прерывания, чтобы не прерывать работу процессора, однако это делается нечасто - только в критические моменты, например при обработке прерываний или диспетчеризации исключения.
 для обработки аппаратных прерываний ядро устанавливает обработчики ловушек прерываний, которые передают управление внешней процедуре (), обрабатывающей прерывание, или внутренней процедуре ядра, реагирующей на прерывание. драйверы устройств предоставляют для обслуживания прерываний от своих устройств, а ядро - внутренние процедуры для обработки других типов прерываний.
 далее мы рассмотрим, как процессор уведомляется об аппаратных прерываниях, какие типы прерываний поддерживаются ядром и как драйверы устройств взаимодействуют с ядром (в процессе обработки прерываний). кроме того, мы поговорим о распознавании ядром программных прерываний и об объектах, используемых для реализации таких прерываний.
обработка аппаратных прерываний
 аппаратных платформах, поддерживаемых , прерывания, связанные с внешним вводом-выводом, поступают по одной из линий контроллера прерываний. контроллер в свою очередь связан с процессором единственной линией, по которой и уведомляет о прерывании. как только процессор прерывается, он требует от контроллера запрос прерывания ( , ). контроллер транслирует в номер прерывания, используемый как индекс в структуре, называемой таблицей диспетчеризации прерываний ( , ), и передает управление соответствующей процедуре. при загрузке заносит в указатели на процедуры ядра, обрабатывающие каждое прерывание и исключение.
 эксперимент: просмотр 
 просмотреть содержимое , включая сведения об обработчиках ловушек, которые назначила прерываниям, можно с помощью команды ! отладчика ядра. команда ! без флагов показывает векторы, которые сопоставлены с адресами в модулях, отличных от ..
 ниже показано, что выводит команда !. 
 системе, задействованной в этом эксперименте, номер прерывания 03 - с драйвера клавиатуры (8042.), а прерывание 03 совместно используется несколькими устройствами, в том числе видеоадаптером, шиной , портами и 1394, а также сетевым адаптером.
 увязывает аппаратные с номерами прерываний в . эта таблица используется системой и при конфигурировании обработчиков ловушек для исключений. так, номер исключения для ошибки страницы на 86 и 64 (это исключение возникает, когда поток пытается получить доступ к отсутствующей или не определенной в виртуальной памяти странице) равен 0. следовательно, запись 0 в указывает на системный обработчик ошибок страниц. хотя архитектуры, поддерживаемые , допус-каютдо 256 элементов в , число на конкретной машине определяется архитектурой используемого в ней контроллера прерываний.
 у каждого процессора имеется своя , так что разные процессоры могут при необходимости выполнять разные . например, в многопроцессорной системе каждый процессор получает прерывания системного таймера, но обновление значения системного таймера в результате обработки этого прерывания осуществляется только одним процессором. однако все процессоры используют это прерывание для измерения кванта времени, выделенного потоку, и для инициации новой процедуры планирования по истечении этого кванта. аналогичным образом в некоторых конфигурациях может понадобиться, чтобы определенные аппаратные прерывания обрабатывал конкретный процессор.
контроллеры прерываний на платформе 86
 большинстве систем 86 применяется либо программируемый контроллер прерываний ( , ) 8259, либо его разновидность, усовершенствованный программируемый контроллер прерываний ( , ) 82489. новые компьютеры, как правило, оснащаются стандарт был разработан для оригинальных работает только в однопроцессорных системах и имеет 15 линий прерываний. и (о нем чуть позже) способен работать в многопроцессорных системах и предлагает 256 линий прерываний. совместно с другими компаниями создали спецификацию () , стандарт для многопроцессорных систем 86, основанный на использовании для совместимости с однопроцессорными операционными системами и загрузочным кодом, запускающим многопроцессорную систему в однопроцессорном режиме, поддерживает -совместимый режим с 15 линиями прерываний и передачей прерываний лишь главному процессору. архитектура показана на рис. 3-2. самом деле состоит из нескольких компонентов: ввода-вывода, принимающего прерывания от устройств, локальных , принимающих прерывания от ввода-вывода по выделенной шине и прерывающих -ботутого процессора, с которым они связаны, а также 18259а-совместимого контроллера прерываний, транслирующего входные сигналы в соответствующие -эквиваленты. ввода-вывода отвечает за реализацию алгоритмов перенаправления прерываний, и операционная система выбирает нужный ей алгоритм (в выбор возлагается на ). эти алгоритмы равномерно распределяют между процессорами нагрузку, связанную с обработкой прерываний от устройств, и в максимальной мере используют все преимущества локальности, направляя такие прерывания процессору, который только что обрабатывал прерывания аналогичного типа.
контроллеры прерываний на платформе 64
 поскольку архитектура 64 совместима с операционными системами для 86, системы на базе 64 должны предоставлять те же контроллеры прерываний, что и на базе 86. однако х64-версии не будут работать на системах без (т. е. они не поддерживают ).
контроллеры прерываний на платформе 64
 архитектуре 64 используется контроллер прерываний () - результат эволюционного развития главное различие между архитектурами и в том, что ввода-вывода в -системе направляет прерывания локальным по выделенной шине , тогда как в системе прерывания передаются по шине ввода-вывода и системы (/ ) для большего быстродействия. еще одно различие - перенаправление прерываний и балансировка нагрузки в -системе обрабатывается самой шиной , а в -системе, где нет выделенной шины , требуется, чтобы соответствующая поддержка была запрограммирована в микрокоде (прошивке). , даже если эта поддержка имеется в микрокоде, не использует ее - вместо этого она статически назначает прерывания процессорам по принципу карусели.
 эксперимент: просмотр конфигурации и 
 конфигурацию в однопроцессорной системе и в многопроцессорной системе можно просмотреть с помощью команд ! или ! отладчика ядра. (для этого эксперимента не годится, так как она не может напрямую обращаться к оборудованию.) ниже показан образец вывода команды ! в однопроцессорной системе (учтите, что команда ! не работает в системе, использующей ).
 следующем листинге приводится выходная информация команды ! в системе, использующей . префикс «0:» в командной строке отладчика говорит о том, что текущие команды выполняются на процессоре 0, поэтому данный листинг относится к ввода-вывода процессора 0.
 теперь взгляните на образец вывода команды !, показывающей конфигурацию ввода-вывода:
 уровни запросов программных прерываний 
 хотя контроллеры прерываний различают уровни приоритетов прерываний, использует свою схему приоритетов прерываний, известную под названием уровни запросов прерываний ( , ). внутри ядра представляются в виде номеров 0-31 в системах 86 и 0-15 в системах 64 и 64, причем больший номер соответствует прерыванию с более высоким приоритетом. ядро определяет стандартный набор для программных прерываний, увязывает с номерами аппаратных прерываний. , определенные для архитектуры 86, показаны на рис. 3-3, а аналогичные сведения для архитектур 64 и 64 - на рис. 3-4.
 примечание уровень _, используемый многопроцессорными версиями ядра для защиты доступа к индивидуальным для каждого процессора блокам ( ), не показан на этих схемах, так как его значение варьируется в разных версиях . описание _ и его возможных значений см. в главе 6. 
 рис. 3-4. уровни запросов прерываний () в системах 64 и 64 
 прерывания обслуживаются в порядке их приоритета, и прерывания с более высоким приоритетом вытесняют обработку прерываний с меньшим приоритетом. при возникновении прерывания с высоким приоритетом процессор сохраняет информацию о состоянии прерванного потока и активизирует сопоставленный с данным прерыванием диспетчер ловушки. последний повышает и вызывает процедуру обслуживания прерывания (). после выполнения диспетчер прерывания понижает процессора до исходного уровня и загружает сохраненные ранее данные о состоянии машины. прерванный поток возобновляется с той точки, где он был прерван. когда ядро понижает , могут «материализоваться» ранее замаскированные прерывания с более низким приоритетом. тогда вышеописанный процесс повторяется ядром для обработки и этих прерываний.
 уровни приоритетов имеют совершенно иной смысл, чем приоритеты в схеме планирования потоков (см. главу 6). приоритет в этой схеме является атрибутом потока, тогда как - атрибутом источника прерывания, например клавиатуры или мыши. кроме того, каждого процессора меняется во время выполнения команд операционной системы.
 значение определяет, какие прерывания может получать данный процессор. также используется для синхронизации доступа к структурам данных режима ядра (о синхронизации мы поговорим позже). при выполнении поток режима ядра повышает или понижает процессора либо напрямую (вызовом соответственно или ), либо - что бывает гораздо чаще - опосредованно (через функции, которые обращаются к синхронизирующим объектам ядра). как показано на рис. 3-5, прерывания от источника с , превышающим текущий уровень, прерывают работу процессора, а прерывания от источников, которых меньше или равен текущему уровню , маскируются до тех пор, пока выполняемый поток не понизит .
 поскольку доступ к - операция довольно медленная, в , использующих , реализован механизм оптимизации «отложенный » ( ), который избегает обращений к когда повышается, - вместо того чтобы изменять маску прерывания - просто отмечает новый . если вслед за этим возникает прерывание с более низким приоритетом, устанавливает маску прерывания в соответствии с первым и откладывает обработку прерывания с более низким приоритетом до понижения . таким образом, если при повышенном не возникнет прерываний с более низким приоритетом, не потребуется обращаться к .
 поток режима ядра повышает и понижает процессора, на котором он выполняется, в зависимости от того, что именно делает этот поток. например, обработчик ловушки (или сам процессор) при прерывании повышает процессора до источника прерывания. результате все прерывания с более низким или равным маскируются (только на этом процессоре), что не дает прерыванию с таким же или более низким помешать процессору обработать текущее прерывание. замаскированные прерывания либо обрабатываются другим процессором, либо откладываются до понижения . поэтому все системные компоненты, в том числе ядро и драйверы устройств, пытаются удерживать на уровне («пассивный»), иногда называемом низким уровнем. если бы долго оставался неоправданно высоким, драйверы устройств не смогли бы оперативно реагировать на аппаратные прерывания.
 примечание прерывания _ являются исключением из правила, которое гласит, что повышение блокирует прерывания такого же уровня и ниже. если поток повышает до уровня _ , а затем отключается от процессора из-за появления прерывания _, то система может доставить ему прерывание _, как только он вновь получит процессорное время. таким образом, _ можно считать , локальным для потока. 
 эксперимент: определяем 
 если вы работаете с отладчиком ядра в 2003, то можете определить процессора командой !: 
 ›! 
 00 - 0 (0_) 
 заметьте, что в структуре данных, называемой ( ), и ее расширении - ( ) имеется поле с именем . эти структуры содержат информацию о состоянии каждого процессора в системе, в том числе текущий , указатель на аппаратную , сведения о текущем потоке и потоке, который будет выполняться следующим. ядро и используют эту информацию для выполнения операций, специфичных для данной машины и ее архитектуры. отдельные части структур и открыто определены в заголовочном файле . (в ). загляните в него, чтобы получить представление об этих структурах.
 для просмотра содержимого воспользуемся командой ! отладчика ядра.
 сожалению, не поддерживает поле на платформах, не использующих отложенные , поэтому в большинстве систем это поле всегда содержит 0.
 так как изменения процессора существенно влияют на функционирование системы, они возможны только в режиме ядра. потоки пользовательского режима не могут изменять процессора. это значит, что при выполнении потоков пользовательского режима значение процессора всегда равно . только при выполнении кода режима ядра может быть выше этого уровня.
 каждый уровень прерывания имеет определенное назначение. так, ядро генерирует межпроцессорное прерывание ( , ), чтобы потребовать выполнения какой-либо операции от другого процессора, например, при диспетчеризации некоего потока или обновлении кэша ассоциативного буфера трансляции [ - () ]. системный таймер через регулярные промежутки генерирует прерывания, на которые ядро реагирует обновлением системного времени, и это используется для измерения продолжительности выполнения потока. если аппаратная платформа поддерживает два таймера, то для измерения производительности ядро добавляет еще один уровень прерываний от таймера. поддерживает несколько уровней запросов прерываний для устройств, управляемых прерываниями; конкретное число таких уровней зависит от процессора и конфигурации системы. ядро использует программные прерывания для инициации планирования потоков и асинхронного вмешательства в выполнение потока.
увязка прерываний с 
 уровни и запросы прерываний () - вещи разные. концепция в архитектурах, на которых работает , не реализована аппаратно. тогда возникает вопрос как определяет, какой следует присвоить прерыванию? ответ нужно искать в . за определение устройств на конкретной шине (, и т. д.) и назначение им прерываний отвечают драйверы устройств особого типа - драйверы шин. драйвер шины сообщает эту информацию диспетчеру , и тот, учитывая приемлемые для других устройств прерывания, принимает решение о конкретных прерываниях, выделяемых каждому устройству. далее он вызывает -функцию , которая увязывает прерывания со значениями .
 этот алгоритм неодинаков в различных версиях . однопроцессорных х86-системах выполняет прямую трансляцию: данного вектора прерывания вычисляется путем вычитания значения вектора из 27. таким образом, если устройство использует 5-й вектор прерывания, его выполняется при , равном 22. многопроцессорной х86-системе преобразования более сложны. поддерживает более 200 векторов прерываний, поэтому при трансляции «один в один» имеющихся окажется недостаточно. многопроцессорная версия присваивает векторам прерываний, циклически перебирая значения из диапазона устройств ( , ). итоге на многопроцессорной х86-системе не так-то просто предсказать или выяснить , назначаемый . наконец, в 64- и а64-системах вычисляет для путем деления вектора прерывания, назначенного данному , на 16.
предопределенные 
 давайте повнимательнее приглядимся к предопределенным , начиная с самого верхнего уровня схемы, представленной на рис. 3-5.
  уровень «» (высокий) используется ядром, только если оно останавливает систему в функции и маскирует все прерывания.
  уровень « » (отказ электропитания) был заложен еще в самый первый проект он определяет поведение системы при отказе электропитания, но никогда не применялся.
  уровень « » (межпроцессорное прерывание) используется для того, чтобы запрашивать от другого процессора выполнение какой-либо операции, например, при постановке в очередь прерывания _ для планирования конкретного потока к выполнению, при обновлении кэша , завершении работы или крахе системы.
  уровень «» (часы) используется для системных часов, с помощью которых ядро отслеживает время суток, измеряет и распределяет процессорное время между потоками.
  уровень «» (профиль) используется системным таймером реального времени, если активизирован механизм профилирования ядра ( ), т. е. измерения его производительности. когда он активен, обработчик ловушки профилирования регистрирует адрес команды, выполнявшейся на момент прерывания. временем создается таблица адресов, которую можно извлечь и проанализировать с помощью соответствующих утилит. вы можете скачать утилиту , позволяющую просматривать статистику, полученную при использовании механизма профилирования ядра. подробнее об этой утилите см. описание эксперимента с .
  уровень «» (устройство) применяется для задания приоритетов прерываний от устройств (о принципах увязки аппаратных прерываний с см. предыдущий раздел).
  прерывания уровней «/» и «» являются программными; они генерируются ядром и драйверами устройств (о и будет рассказано позже).
  самый низкий уровень , «» (пассивный), на самом деле вообще не является уровнем прерывания. при этом значении потоки выполняются обычным образом и могут возникать любые прерывания.
 эксперимент: применение утилиты 
 утилита профилирования ядра () позволяет включать таймер профилирования системы, собирать образцы кода, выполняемого при срабатывании таймера, и выводить сводную информацию, отражающую распределение процессорного времени по образам файлов и функциям. можно использовать для отслеживания процессорного времени, потребляемого индивидуальными процессами, и/или времени, проведенного в режиме ядра независимо от процессов (например, для выполнения процедур обслуживания прерываний). профилирование ядра полезно, когда вы хотите выявить точки, в которых на выполнение кода тратится больше всего процессорного времени.
 своей простейшей форме сообщает, сколько процессорного времени было использовано каждым модулем ядра (, драйверами и т. д.). попробуйте, к примеру, выполнить следующие операции.
 1. откройте окно командной строки.
 2. введите : \ \\. 
 3. введите . (вы увидите образы для каждой платформы.)
 4. запустите образ, который подходит для вашей платформы (без аргументов или ключей). например, _386_. - это образ для на платформе 86.
 5. пока выполняется, поделайте что-нибудь в системе. скажем, запустите и проиграйте музыку, запустите игру, интенсивно работающую с графикой, или перечислите содержимое каталога на удаленном сетевом ресурсе.
 6. нажмите +, чтобы остановить . это заставит вывести статистику за прошедший период.
 ниже приведена часть вывода , когда выполнялся , воспроизводивший дорожку с компакт-диска.
 сводные данные показывают, что система провела 11,7 % времени в режиме ядра, 30,2 % в пользовательском режиме, 58,1 % в простое, 6,4 % на уровне и 1,3 % на уровне прерываний ( ). модуль, чаще всего требовавший к себе внимания, был 3., драйвер процессора для (семейства ). он используется для сбора информации о производительности, поэтому и оказался на первом месте. модуль, занявший второе место, - ., драйвер звуковой платы на компьютере, где проводился тест. это вполне объяснимо, учитывая, что основную нагрузку в системе создавал , посылавший звуковой ввод-вывод этому драйверу.
 если у вас есть файлы символов, вы можете исследовать индивидуальные модули и посмотреть, сколько времени было затрачено каждой из их функций. например, профилирование системы в процессе быстрого перемещения окна по экрану давало такой вывод (здесь приведена лишь его часть):
 : \ \\›_386_. - - 32 
 данном случае самым «прожорливым» был модуль 32., драйвер системы, отвечающей за работу с окнами. второй в списке - видеодрайвер. и действительно, основная нагрузка в системе была связана с рисованием окна на экране. детальном выводе для 32. видно, что наиболее активна была его функция , основная -функция для рисования на экране.
 код, выполняемый на уровне «/» и выше, накладывается важное ограничение: он не может ждать освобождения объекта, если такое ожидание заставило бы планировщик подключить к процессору другой поток (а это недопустимая операция, так как планировщик синхронизирует свои структуры данных на уровне «/» и, следовательно, не может быть активизирован для выполнения перераспределения процессорного времени). другое ограничение заключается в том, что при уровне «/ » или выше доступна только неподкачиваемая память. самом деле второе ограничение является следствием первого, так как обращение к отсутствующей в оперативной памяти странице вызывает ошибку страницы. тогда диспетчер памяти должен был бы инициировать операцию дискового ввода-вывода, после чего ждать, когда драйвер файловой системы загрузит эту страницу с диска. это в свою очередь вынудило бы планировщик переключить контекст (возможно, на поток простоя, если нет ни одного пользовательского потока, ждущего выполнения). результате было бы нарушено правило, запрещающее вызов планировщика в таких ситуациях (поскольку при чтении с диска все еще остается на уровне «/» или выше). при нарушении любого из этих двух ограничений происходит крах системы с кодом завершения ____ (подробнее о кодах завершения при крахе системы см. главу 4). кстати, нарушение этих ограничений является довольно распространенной ошибкой в драйверах устройств. локализовать причину ошибок такого типа помогает утилита , о которой будет подробно рассказано в разделе «утилита » главы 7.
объекты «прерывание» ( )
 ядро предоставляет переносимый (портируемый) механизм - объект прерывания, позволяющий драйверам устройств регистрировать для своих устройств. этот объект содержит всю информацию, необходимую ядру для назначения конкретного уровня прерывания для устройства, включая адрес , устройства и запись в ядра, с которой должна быть сопоставлена . при инициализации в объект прерывания из шаблона обработки прерываний, -, копируется несколько ассемблерных инструкций - код диспетчеризации. этот код выполняется при возникновении прерывания.
 код, хранящийся в объекте прерывания, вызывает реальный диспетчер прерываний, которым обычно является процедура ядра или , и передает ему указатель на объект прерывания. обслуживает векторы прерываний, для которых зарегистрирован только один объект прерывания, - векторы, разделяемые несколькими объектами прерываний. объекте прерывания содержится информация, необходимая процедуре для поиска и корректного вызова драйвера. объект прерывания также хранит значение , сопоставленное с данным прерыванием, так что или может перед вызовом повысить до нужного уровня и вернуть его к исходному после завершения . этот двух-этапный процесс необходим из-за того, что при начальной диспетчеризации нельзя передать указатель (или какой-либо иной аргумент) объекту прерывания, так как она выполняется не программно, а аппаратно. многопроцессорных системах ядро создает и инициализирует объект прерывания для каждого процессора, позволяя их локальным принимать конкретные прерывания. рис. 3-6 показана типичная схема обслуживания прерываний, сопоставленных с объектами прерываний.
 эксперимент: изучение внутреннего устройства прерываний 
 помощью отладчика ядра вы можете просмотреть детальные сведения об объекте прерывания, в том числе его , адрес и собственный код диспетчеризации прерывания ( ). во-первых, введите команду ! и найдите запись со ссылкой на 8042 - процедуру для устройства «2-клавиатура»:
 31: 8393 8042!8042 ( 83900) 
 для просмотра содержимого объекта, сопоставленного с прерыванием, введите !_, указав адрес, следующий за :
 этом примере , назначенный прерыванию, - 01 (или 26 в десятичной системе). поскольку вывод получен на однопроцессорной х86-системе, равно 1 ( в таких системах вычисляются путем вычитания из 27). это можно проверить, открыв (диспетчер устройств) [на вкладке (оборудование) в окне свойств системы)], найдя /2-клавиатуру и посмотрев назначенные ей ресурсы, как показано на следующей иллюстрации.
 многопроцессорных х86-системах назначается в основном случайным образом, а в 64- или а64-системе вы увидите, что - это номер вектора прерываний [031 (49 в десятичной системе)], деленный на 16.
 адрес для объекта прерывания хранится в поле (его и показывает ! в своем выводе), а код прерывания, срабатывающий при появлении этого прерывания, - в массиве в конце объекта прерывания. этот код программируется так, чтобы создавать фрейм ловушки в стеке и потом вызывать функцию, хранящуюся в поле (в нашем примере это }, с передачей ей указателя на объект прерывания.
 и обработка данных в реальном времени
 средам, предназначенным для работы в реальном времени, предъявляются либо жесткие, либо очень жесткие требования к максимальному времени реакции. реакция системы реального времени, к которой предъявляются очень жесткие требования (например, системы управления атомной электростанцией), должна быть исключительно быстрой, иначе неизбежны катастрофы, опасные не только для оборудования, но и для жизни людей. менее ответственные системы реального времени (например, система экономичного расхода топлива автомобиля) могут в какой-то мере отклоняться от этих требований, но их соблюдение все же желательно. системах реального времени устройствами ввода служат датчики, а устройствами вывода - управляющие устройства. проектировщик компьютерных систем реального времени должен знать величину максимально допустимого запаздывания между моментом генерации прерывания устройством ввода и ответом управляющего устройства, контролируемого драйвером. анализ самых неблагоприятных вариантов должен учитывать как запаздывание операционной системы, так и запаздывание драйверов и приложений.
 поскольку проконтролировать расстановку приоритетов устройств операционной системой нельзя, а пользовательские приложения выполняются лишь при уровня «», не всегда подходит для обработки данных в реальном времени. максимальное запаздывание определяется в конечном счете устройствами и драйверами системы, а не самой . этот фактор становится проблемой при использовании готового оборудования, имеющегося в продаже. проектировщик может столкнуться с трудностями при определении максимального времени выполнения или драйвера готового устройства. даже после тестирования он не сможет гарантировать, что запаздывание ни при каких обстоятельствах не превысит заданного предела. более того, суммарное запаздывание системных и , как правило, существенно превосходит значения, приемлемые для чувствительных к задержкам систем.
 хотя ко многим типам встраиваемых систем (например, к принтерам и автомобильным компьютерам) предъявляются требования, как к системам реального времени, не обладает соответствующими характеристиками. это просто версия , которая создана с использованием технологии, лицензированной у компании , и способна работать в системах с ограниченными ресурсами. так, для устройства без сетевых функций исключается вся функциональность , связанная с поддержкой работы в сетях, включая средства управления сетью, драйверы стека протокола и сетевого адаптера.
 тем не менее третьи фирмы поставляют версии ядра реального времени для . их подход заключается в том, что они встраивают ядро реального времени в собственный и выполняют как задачу в операционной системе реального времени. , выполняемая в таком виде, служит в качестве пользовательского интерфейса системы и имеет меньший приоритет по сравнению с задачами, ответственными за управление нужным устройством. пример расширения ядра реального времени можно увидеть на -сайте .. .
 сопоставление с конкретным уровнем прерывания называется подключением объекта прерывания, а разрыв связи между и записью в - отключением. эти операции, выполняемые функциями ядра - и , позволяют драйверу устройства «включать» после своей загрузки и «отключать» , если он не загружен.
 применение объекта прерывания для регистрации позволяет драйверам устройств избегать прямого взаимодействия с контроллером прерываний (разным на разных процессорных архитектурах) и исключает необходимость детального знания . это дает возможность создавать переносимые драйверы устройств, поскольку благодаря такой функциональности ядра программировать драйверы устройств на ассемблере и учитывать в них особенности конкретных процессоров больше не нужно.
 использование объекта прерывания дает и другие преимущества: ядро может синхронизировать выполнение с другими частями драйвера устройства, которые могут разделять данные с . (подробнее о том, как драйверы устройств реагируют на прерывания, см. главу 9.)
 более того, объекты прерывания позволяют ядру легко вызывать более одной для любого уровня прерывания. если несколько драйверов создают объекты прерывания и сопоставляют их с одной записью в , то при прерывании на определенной линии диспетчер вызывает каждую из этих процедур (). такая функциональность позволяет ядру поддерживать конфигурации в виде цепочек, когда несколько устройств совместно используют одну линию прерывания. когда одна из объявляет диспетчеру о захвате прерывания, происходит разрыв цепочки. если несколько устройств, разделяющих одну линию прерывания, одновременно запрашивают обслуживание, то устройства, не получившие подтверждения от своих , будут вновь генерировать прерывания, как только диспетчер понизит . связывание устройств в цепочку разрешается, только если все драйверы устройств, стремящиеся использовать одно и то же прерывание, сообщат ядру о своей способности разделять данное прерывание. если они не в состоянии совместно использовать это прерывание, диспетчер переназначит с учетом запросов каждого устройства. если разделяемым является вектор прерываний, объект прерывания вызывает , которая поочередно обращается к каждого зарегистрированного объекта прерывания, пока один из них не сообщит, что прерывание вызвано им, или пока все они не будут выполнены. одном из предыдущих примеров вывода ! вектор 03 был подключен к нескольким объектам прерываний, связанным в цепочку ( ).
программные прерывания
 хотя большинство прерываний генерируется аппаратно, ядро тоже может генерировать прерывания - только они являются программными. этот вид прерываний служит для решения многих задач, в том числе:
  инициации диспетчеризации потоков;
  обработки прерываний, не критичных по времени;
  обработки событий таймеров;
  асинхронного выполнения какой-либо процедуры в контексте конкретного потока;
  поддержки асинхронного ввода-вывода. эти задачи подробно рассматриваются ниже.
прерывания или диспетчеризации
 когда дальнейшее выполнение потока невозможно, например из-за его завершения или перехода в ждущее состояние, ядро напрямую обращается к диспетчеру, чтобы вызвать немедленное переключение контекста. однако иногда ядро обнаруживает, что перераспределение процессорного времени () должно произойти при выполнении глубоко вложенных уровней кода. этой ситуации ядро запрашивает диспетчеризацию, но саму операцию откладывает до выполнения текущих действий. такую задержку удобно организовать с помощью программного прерывания ( ).
 при необходимости синхронизации доступа к разделяемым структурам ядра последнее всегда повышает процессора до уровня «/» или выше. при этом дополнительные программные прерывания и диспетчеризация потоков запрещаются. обнаружив необходимость в диспетчеризации, ядро генерирует прерывание уровня «/». поскольку уже находится на этом уровне или выше, процессор откладывает обработку этого прерывания. когда ядро завершает свои операции, оно определяет, что должно последовать снижение ниже уровня "/", и проверяет, не ожидают ли выполнения отложенные прерывания диспетчеризации. если да, понижается до уровня «/», и эти отложенные прерывания обрабатываются. активизация диспетчера потоков через программное прерывание - способ отложить диспетчеризацию до подходящего момента. однако использует программные прерывания для отложенного выполнения и других операций.
 при этом ядро обрабатывает не только диспетчеризацию потоков, но и - это функция, выполняющая системную задачу, менее критичную по времени в сравнении с текущей. эти функции называются отложенными (), так как не требуют немедленного выполнения.
 позволяют операционной системе генерировать прерывания и выполнять системные функции в режиме ядра. ядро использует для обработки прерываний по таймеру (и освобождения потоков, ждущих на таймерах), а также для перераспределения процессорного времени по истечении кванта времени, отведенного текущему потоку. драйверы устройств используют для выполнения запросов ввода-вывода. для своевременного обслуживания аппаратных прерываний - во взаимодействии с драйверами устройств - пытается удерживать текущий ниже устройств. один из способов достижения этой цели заключается в следующем. должна выполнять минимум действий по обслуживанию своего устройства, сохранять переменные данные о состоянии прерывания и откладывать передачу данных или выполнение других не столь критичных по времени операций, как , до снижения к уровню «/» (подробнее о и системе ввода-вывода см. главу 9).
 представляется -объектом, управляющим объектом ядра, невидимым программам пользовательского режима, но видимым драйверам и системному коду. наиболее важной частью информации -объекта является адрес системной функции, которую ядро должно вызвать для обработки прерывания -процедуры, ожидающие выполнения, хранятся в управляемых ядром очередях (по одной на каждый процессор). эти очереди называются очередями запрашивая , системный код вызывает ядро для инициализации -объекта и помещает его в очередь 
 по умолчанию ядро помещает -объекты в конец очереди процессора, на котором был запрошен (как правило, это процессор, на котором выполняется ). однако драйвер устройства может изменить это, указав приоритет (низкий, средний или высокий; по умолчанию - средний) или направив конкретному процессору. , направленный конкретному процессору, называется целевым ( ). если у низкий или средний приоритет, ядро помещает -объект в конец очереди, а если у высокий приоритет, то - в начало.
 когда процессора вот-вот понизится с уровня «/» или более высокого до уровня «» или «», ядро переходит к обработке всех оставляет на уровне «/» и извлекает все -объекты из очереди данного процессора (т. е. ядро опустошает очередь), поочередно вызывая каждую -функцию. ядро разрешает уменьшить ниже уровня «/» для продолжения выполнения обычных потоков только после опустошения очереди. схема обработки показана на рис. 3-7.
 приоритеты могут влиять на поведение системы и иным способом. обычно ядро начинает опустошение очереди с прерывания уровня «/». такое прерывание генерируется ядром, только если направлен на процессор, на котором выполняется , и имеет средний или высокий приоритет. если у низкий приоритет, ядро генерирует прерывание, только если число незавершенных запросов превышает пороговое значение или если число , запрошенных на процессоре за установленный период, невелико. если направлен другому процессору (не тому, на котором выполняется ) и его приоритет высокий, ядро немедленно посылает ему диспетчерское , сигнализируя целевому процессору о необходимости опустошения его очереди если приоритет средний или низкий, для появления прерывания «/» число в очереди целевого процессора должно превышать пороговое значение. системный поток простоя также опустошает очередь процессора, на котором он выполняется. хотя уровни приоритета и направление являются довольно гибкими средствами, у драйверов устройств редко возникает необходимость в изменении заданного по умолчанию поведения своих -объектов. таблице 3-1 даются сведения о ситуациях, в которых начинается опустошение очереди 
 поскольку потоки пользовательского режима выполняются при низком , вероятность того, что прервет выполнение обычного пользовательского потока, довольно велика. -процедуры выполняются независимо от того, какой поток работает в настоящий момент. это означает, что выполняемая -процедура не в состоянии предугадать текущий размер спроецированного адресного пространства процесса. -процедуры могут вызывать функции ядра, но не могут обращаться к системным сервисам, генерировать ошибки страницы, создавать или ждать объекты диспетчера. однако они способны получать доступ к неподкачиваемым областям системной памяти, поскольку системное адресное пространство всегда спроецировано независимо от того, что представляет собой текущий процесс.
 используются не только драйверами, но и ядром. ядро чаще всего применяет для обработки ситуации, когда истекает выделенный квант времени. при каждом такте системного таймера генерируется прерывание с -уровнем «». обработчик прерываний таймера (выполняемый при , равном «») обновляет системное время и уменьшает значение счетчика, отслеживающего время выполнения текущего потока. когда значение счетчика обнуляется, квант времени, отведенный потоку, заканчивается, и ядру может понадобиться перераспределить процессорное время - эта задача имеет более низкий приоритет и должна выполняться при , равном «/». обработчик прерываний таймера ставит в очередь, чтобы инициировать диспетчеризацию потоков, после чего завершает свою работу и понижает процессора. поскольку приоритет прерываний ниже, чем аппаратных, перед генерацией прерывания сначала обрабатываются все аппаратные прерывания, возникающие до завершения обработки прерывания таймера.
 эксперимент: мониторинг активности прерываний и 
 позволяет вести мониторинг активности прерываний и , добавив столбец и наблюдая за процессами и это не настоящие процессы, они показываются как процессы просто для удобства и не вызывают переключений контекста. счетчик переключений контекста в для этих псевдопроцессов отражает число возникновений каждого из них в течение предыдущего интервала обновления ( ). вы можете имитировать активность прерываний и , быстро перемещая курсор мыши по экрану.
 вы также можете проследить выполнение конкретных процедур обслуживания прерываний () и отложенных вызовов процедур (), используя встроенную поддержку трассировки событий (подробнее об этом будет рассказано позже) в 2 или 2003 1 (и выше).
 1. инициируйте захват событий, введя команду:
 - - . - 64 - - 8 0307 04084 0 0 0 0 0 0 
 2. остановите захват событий, введя: - 
 3. создайте отчеты по захваченным событиям, набрав команду: . - - о - 
 это приведет к генерации двух файлов: . и ..
 4. откройте . и вы увидите сводные сведения о времени, проведенном драйверами каждого типа в - и -процедурах.
 5. откройте файл ., созданный на этапе 3; найдите строки, где во втором значении встречается ‹‹» или «». например, следующие три строки из . показывают таймера, и :
 первый адрес относится к , вызванному срабатыванием таймера, который был поставлен в очередь клиентским драйвером редиректора файловой системы ( ). второй относится к вызванному срабатыванием универсального таймера ( ). наконец, третий - это адрес для порт-драйвера . более подробные сведения см. по ссылке ://. ////.. 
прерывания 
 ( ) позволяет выполнять пользовательские программы и системный код в контексте конкретного пользовательского потока (а значит, и в адресном пространстве конкретного процесса). посколькудля выполнения в контексте конкретного потока ставятся в очередь и выполняются при ниже «/», на их работу не налагаются ограничения, свойственные арс-процедура может обращаться к ресурсам (объектам), ждать освобождения описателей объектов, генерировать ошибки страниц и вызывать системные сервисы.
 описывается управляющим объектом ядра - лрс-объектом. , ждущие выполнения, находятся в очереди лрс ( ), управляемой ядром. очереди - в отличие от общесистемной очереди - специфичны для конкретного потока, так как у каждого потока своя очередь при запросе на постановку в очередь ядро помещает его () в очередь того потока, который будет выполнять арс-процедуру. далее ядро генерирует программное прерывание с уровнем , и поток, когда он в конечном счете начинает выполняться, обрабатывает 
 бывают двух видов: режима ядра и пользовательского режима. режима ядра для выполнения в контексте целевого потока не нужно «разрешение» со стороны этого потока, тогда как для пользовательского режима это обязательно. режима ядра прерывает поток и выполняет процедуру без вмешательства или согласия потока. режима ядра тоже бывают двух типов: обычные () и специальные (). поток может отключить все режима ядра, повысив до уровня _ или вызвав , которая впервые появилась в 2003. отключает доставку , устанавливая поле - в структуре вызвавшего потока (об этой структуре см. главу 6). поток также может отключить только обычные режима ядра вызовом , которая устанавливает поле в структуре потока.
 исполнительная система использует режима ядра для тех задач операционной системы, которые нужно выполнить в адресном пространстве (контексте) конкретного потока. так, через специальные режима ядра она может указать потоку прекратить выполнение системного сервиса, допускающего прерывание, или записать результаты операции асинхронного ввода-вывода в адресное пространство этого потока. подсистемы окружения используют такие , чтобы приостановить поток или завершить себя, а также чтобы получить или установить контекст пользовательского потока. подсистема эмулирует через режима ядра передачу -сигна-лов процессам .
 драйверы устройств также применяют режима ядра. например, если инициирована операция ввода-вывода и поток переходит в состояние ожидания, к процессору может быть подключен другой поток из другого процесса. по завершении передачи данных устройством система ввода-вывода должна как-то вернуться в контекст потока, инициировавшего эту операцию ввода-вывода, чтобы он мог скопировать ее результаты в буфер в адресном пространстве своего процесса. система ввода-вывода использует для выполнения подобных действий специальные режима ядра (применение в системе ввода-вывода подробно рассматривается в главе 9).
 некоторые -функции вроде , и - вызывают пользовательского режима. так, функции и позволяют вызывающей программе указать процедуру завершения ввода-вывода ( ), которая будет вызвана по окончании операции ввода-вывода. процедура завершения ввода-вывода реализуется помещением в очередь потока, выдавшего запрос на ввод-вывод. однако обратный вызов процедуры завершения не обязательно происходит в момент постановки в очередь, поскольку пользовательского режима передаются потоку, только если он находится в состоянии тревожного ожидания ( ). поток может перейти в такое состояние, вызвав одну из -функций: либо , либо -. обоих случаях, как только в очереди появится пользовательского режима, ядро прервет поток, передаст управление арс-процедуре и возобновит его выполнение лишь после завершения арс-процедуры. отличие от режима ядра, которые выполняются на уровне «», пользовательского режима выполняются на уровне «».
 появление может переупорядочить очереди ожидания - списки, определяющие, какие потоки ждут, в каком порядке и на каких объектах (см. раздел по синхронизации далее в этой главе). если в момент появления поток находится в состоянии ожидания, то после обработки арс-процедуры поток возвращается в состояние ожидания, но перемещается в конец списка потоков, ждущих те же объекты.
диспетчеризация исключений
 отличие от прерываний, которые могут возникать в любой момент, исключения являются прямым следствием действий выполняемой программы. вводит понятие структурной обработки исключений ( , ), позволяющей приложениям получать управление при возникновении исключений. при этом приложение может исправить ситуацию, которая привела к исключению, провести раскрутку стека (завершив таким образом выполнение подпрограммы, вызвавшей исключение) или уведомить систему о том, что данное исключение ему не известно, и тогда система продолжит поиск подходящего обработчика для данного исключения. этом разделе мы исходим из того, что вы знакомы с базовыми концепциями структурной обработки исключений ; в ином случае сначала прочитайте соответствующую часть справочной документации из или главы 23-25 из четвертого издания книги джеффри рихтера « для профессионалов». учтите: хотя обработка исключений возможна через расширения языка программирования (например, с помощью конструкции_ в ++), она является системным механизмом и поэтому не зависит от конкретного языка.
 системах типа 86 все исключения имеют предопределенные номера прерываний, прямо соответствующие записям в , ссылающимся на обработчики ловушек конкретных исключений. таблице 3-2 перечислены исключения, определенные для систем типа 86, с указанием номеров прерываний. как уже говорилось, первая часть используется для исключений, а аппаратные прерывания располагаются за ней.
 все исключения, кроме достаточно простых, которые могут быть разрешены обработчиком ловушек, обслуживаются модулем ядра - диспетчером исключений ( ). его задача заключается в поиске обработчика, способного «справиться» с данным исключением. примерами независимых от архитектуры исключений могут служить нарушения доступа к памяти, целочисленное деление на нуль, переполнение целых чисел, исключения при операциях с плавающей точкой и точки прерывания отладчика. полный список независимых от архитектуры исключений см. в справочной документации .
 ядро перехватывает и обрабатывает некоторые из этих исключений прозрачно для пользовательских программ. так, если при выполнении отлаживаемой программы встретилась точка прерывания, генерируется исключение, обрабатываемое ядром за счет вызова отладчика. ряд исключений ядро обрабатывает, просто возвращая код неудачной операции.
 определенные исключения могут передаваться в неизменном виде пользовательским процессам. например, при ошибке доступа к памяти или при переполнении в ходе арифметической операции генерируется исключение, не обрабатываемое операционной системой. для обработки этих исключений подсистема окружения может устанавливать обработчики исключений на основе -фрейма (далее для краткости - обработчик -фрейма). этим термином обозначается обработчик исключения, сопоставленный с вызовом конкретной процедуры. при активизации такой процедуры в стек заталкивается стековый фрейм, представляющий вызов этой процедуры. стековым фреймом можно сопоставить один или несколько обработчиков исключений, каждый из которых защищает определенный блок кода исходной программы. при возникновении исключения ядро ищет обработчик, сопоставленный с текущим стековым фреймом. если его нет, ядро ищет обработчик, сопоставленный с предыдущим стековым фреймом, - и так до тех пор, пока не будет найден подходящий обработчик. если найти обработчик исключения не удалось, ядро вызывает собственные обработчики по умолчанию.
 когда происходит исключение (аппаратное или программное), цепочка событий начинается в ядре. процессор передает управление обработчику ловушки в ядре, который создает фрейм ловушки по аналогии с тем, как это происходит при прерывании. фрейм ловушки позволяет системе после обработки исключения возобновить работу с той точки, где она была прервана. обработчик ловушки также создает запись исключения, содержащую сведения о ее причине и другую сопутствующую информацию.
 если исключение возникает в режиме ядра, то для его обработки диспетчер исключений просто вызывает процедуру поиска подходящего обработчика -фрейма. поскольку необработанные исключения режима ядра были бы фатальными ошибками операционной системы, диспетчер всегда находит какой-нибудь обработчик.
 если исключение возникает в пользовательском режиме, диспетчер исключений предпринимает более сложные действия. как поясняется в главе 6, подсистема предусматривает порт отладчика ( ) и порт исключений ( ) для приема уведомлений об исключениях пользовательского режима в -процессах. они применяются ядром при обработке исключений по умолчанию, как показано на рис. 3-8.
 точки прерывания в отлаживаемой программе являются распространенной причиной исключений. поэтому диспетчер исключений первым делом проверяет, подключен ли к процессу, вызвавшему исключение, отладчик. если подключен и системой является 2000, диспетчер исключений посылает отладчику через первое предупреждение. (это уведомление на самом деле сначала поступает диспетчеру сеансов, а тот пересылает его соответствующему отладчику.) и 2003 диспетчер исключений посылает сообщение объекта отладчика ( ) объекту отладки ( ), сопоставленному с процессом (который внутри системы рассматривается как порт).
 если к процессу не подключен отладчик или если отладчик не в состоянии обработать данное исключение, диспетчер исключений переключается в пользовательский режим, копирует фрейм ловушки в пользовательский стек, имеющий формат структуры данных (документирована в ), и вызывает процедуру поиска обработчика -фрейма. если поиск не дал результатов, диспетчер возвращается в режим ядра и снова вызывает отладчик, чтобы пользователь мог продолжить отладку. при этом посылается второе (и последнее) предупреждение.
 если отладчик не запущен и обработчики -фреймов не найдены, ядро посылает сообщение в порт исключений, сопоставленный с процессом потока. этот порт (если таковой есть) регистрируется подсистемой окружения, контролирующей данный поток. порт исключений дает возможность подсистеме окружения (прослушивающей этот порт) транслировать исходное исключение в уведомление или исключение, специфичное для ее окружения. (/ - ) просто выводит окно сообщения, уведомляющее пользователя о сбое, и завершает процесс. когда подсистема получает от ядра сообщение о том, что один из потоков вызвал исключение, эта подсистема посылает вызвавшему исключение потоку сигнал в стиле . , если ядро уже дошло до этого этапа в обработке исключения, а подсистема не способна обработать данное исключение, выполняется обработчик ядра по умолчанию, просто завершающий процесс, поток которого вызвал исключение.
необработанные исключения
 вершине стека любого -потока объявляется обработчик, имеющий дело с необработанными исключениями. за объявление отвечает внутренняя -функция -- или --. функция -- срабатывает в момент начала выполнения первого потока процесса. она вызывает главную точку входа в образе. функция -- выполняется при создании дополнительных потоков в процессе и вызывает стартовую процедуру, указанную в вызове . 
 эксперимент: определение истинного стартового адреса -потоков 
 тот факт, что выполнение каждого -потока начинается с системной (а не пользовательской) функции, объясняет, почему у каждого -процесса стартовый адрес нулевого потока одинаков (как и стартовые адреса вторичных потоков). стартовый адрес нулевого потока -процессов соответствует -функции ~-, а стартовые адреса остальных потоков являются адресом -функции --. для определения адреса пользовательской функции применим утилиту из . для получения детальной информации о процессе наберите имя процесса или идентификатор процесса. например, сравним стартовый адрес процесса , сообщаемый утилитой (из ), и стартовый адрес .
 стартовый адрес нулевого потока, сообщаемый , соответствует внутренней -функции --, а стартовые адреса потоков 1-3 указывают адреса внутренних -функций --. другой стороны, показывает стартовый адрес пользовательской функции, вызываемой внутренней стартовой -функцией.
 поскольку большинство потоков в -процессах начинается в одной из системных функций-оболочек, , показывая стартовые адреса потоков в процессе, пропускает фрейм начального вызова, представляющий функцию-оболочку, и вместо этого отображает второй фрейм в стеке. например, обратите внимание на стартовый адрес потока в процессе, выполняющем ..
 не выводит всю иерархию вызовов при отображении стека вызовов. вот что вы получите, щелкнув кнопку .
 строке 12 на этой иллюстрации показан первый фрейм в стеке - начало процесса-оболочки. второй фрейм (строка 11) является основной точкой входа в ..
 базовый код внутренних стартовых функций выглядит так:
 32( 
 __ , ){ 
 __ { 
 заметьте: если при выполнении потока возникает исключение, не обрабатываемое этим потоком, вызывается -фильтр необработанных исключений. эта функция реализует поведение системы, когда та обнаруживает необработанное исключение. поведение зависит от содержимого раздела реестра \\\ \\. нем есть два важных параметра: и . сообщает фильтру необработанных исключений, надо ли автоматически запускать отладчик или спросить у пользователя, что делать. по умолчанию этому параметру присваивается 1, что подразумевает автоматический запуск отладчика. однако после установки средств разработки вроде его значение меняется на 0. параметр является строкой, которая указывает путь к исполняемому файлу отладчика, который следует запускать при появлении необработанного исключения.
 отладчик по умолчанию - \\32\32. (. -), который на самом деле является не отладчиком, а утилитой, сохраняющей сведения о рухнувшем приложении в фарше журнала (32.) и обрабатывающей файл аварийного дампа (.). оба этих файла по умолчанию помещаются в папку \ \ \ \. для просмотра или изменения конфигурации утилиту . можно запустить в интерактивном режиме; при этом выводится окно с текущими параметрами (пример для 2000 показан на рис. 3-9).
 файл журнала содержит такую базовую информацию, как код исключения, имя рухнувшего образа, список загруженных , а также содержимое стека и последовательность команд потока, вызвавшая исключение. более подробные сведения о содержимом этого файла можно получить, запустив . и щелкнув кнопку (справка) в его окне.
 файл аварийного дампа записывается содержимое закрытых страниц процесса на момент возникновения исключения (но страницы кода из -и -модулей не включаются). этот файл можно открыть с помощью - - -отладчика, поставляемого с пакетом или с 2003 и выше). файл аварийного дампа перезаписывается при каждом крахе процесса. поэтому, если его предварительно не скопировать или не переименовать, в нем будет содержаться информация лишь о последнем крахе процесса.
 2000 визуальное уведомление включено по умолчанию. окно сообщения, представленное на рис. 3-10, выводится . после того, как он сгенерирует аварийный дамп и запишет информацию в свой файл журнала.
 процесс . остается до тех пор, пока не будет закрыто это окно, и именно поэтому в 2000 визуальное уведомление по умолчанию отключено. дело вот в чем. обычно сервер находится в отдельной комнате и возле него никто не сидит. если на сервере рушится какое-то приложение, то подобное окно просто некому закрыть. по этой причине серверные приложения должны регистрировать ошибки в журнале событий .
 2000, если параметр установлен в 0, отображается окно, приведенное на рис. 3-11.
 после щелчка кнопки процесс завершается. если вы нажимаете кнопку , запускается системный отладчик (заданный параметром в реестре).
 эксперимент: необработанные исключения 
 чтобы увидеть образец файла журнала . , запустите программу .. эта программа вызовет нарушение доступа (ошибку защиты памяти) при попытке записи по нулевому адресу, всегда недей-твитльнм для-пцв (см. таблицу 7-6 в главе 7).
 1. запустите (редактор реестра) и найдите раздел \ \\ \\.
 2. если значение параметра равно «32 - % - % - », ваша система настроена на использование . в качестве отладчика по умолчанию. переходите в п. 4.
 3. если в параметре не указан 32., вы все равно можете протестировать . , временно установив его, а затем восстановив исходные параметры своего отладчика:
  сохраните где-нибудь текущее значение параметра (например, в файле или в буфере обмена);
  выберите из меню (пуск) команду (выполнить) и введите команду 32 - (чтобы инициализировать параметр для запуска . ).
 4. запустите тестовую программу ..
 5. вы должны увидеть одно из окон, описанных ранее (в зависимости от версии , в которой вы работаете).
 6. если вы используете параметры . по умолчанию, то теперь сможете изучить файл журнала и файл дампа в каталоге файлов дампов. для просмотра параметров . , запустите -32 без аргументов. (выберите из меню команду и введите 32.) 
 7.  качестве альтернативы щелкните последнюю запись в списке (ошибки приложения) и нажмите кнопку (показать) - будет выведена часть файла журнала . , содержащая сведения о нарушении доступа, вызванном .. если вас интересуют детали формата файла журнала, щелкните кнопку (справка) и выберите раздел . (обзор файла журнала доктора ватсона).
 8. если . не был отладчиком по умолчанию, восстановите исходное значение, сохраненное в п. 1.
 проведите еще один эксперимент: попробуйте перенастроить параметр на другую программу, например . (блокнот) или . (). снова запустите .. обратите внимание, что запускается любая программа, указанная в параметре . есть система не проверяет, действительно ли указанная в этом параметре программа является отладчиком. обязательно восстановите исходные значения параметров реестра (введите 32 - ). 
-поддержка отчетов об ошибках
 и 2003 появился новый, более изощренный механизм отчетов об ошибках, называемый . он автоматизирует передачу информации о крахе как в пользовательском режиме, так и в режиме ядра. (как применить этот механизм для получения сведений о крахе системы, см. главу 14.)
 можно настроить, последовательно выбрав (мой компьютер), (свойства), (дополнительно) и (отчет об ошибках) (на экране появится диалоговое окно, показанное на рис. 3-12); то же самое можно сделать через параметры локальной или доменной политики группы, которые хранятся в разделе реестра \\\\.
 перехватив необработанное исключение (об этом шла речь в предыдущем разделе), фильтр необработанных исключений выполняет начальную проверку, чтобы решить, надо ли запустить механизм . если параметр реестра \\\ \ \\ установлен в 0 или строка содержит текст «32», фильтр необработанных исключений загружает в аварийный процесс библиотеку \\32\. и вызывает ее функцию . эта функция проверяет конфигурацию механизма отчетов об ошибках, которая хранится в разделе \\\\ , и определяет, следует ли формировать отчет для данного процесса и, если да, то как. обычном случае создает процесс, выполняющий \\32\., который выводит окно, где пользователь уведомляется о крахе процесса и где ему предоставляется возможность передать отчет об ошибках в (рис. 3-13).
 при щелчке кнопки (послать отчет), отчет об ошибках (минидамп и текстовый файл с детальными сведениями о номерах версий , загруженных в рухнувший процесс) передается на онлайновый сервер анализа аварийных ситуаций, ... ( отличие от краха системы в режиме ядра здесь нет возможности найти какое-либо решение на момент отправки отчета.) затем фильтр необработанных исключений создает процесс для запуска отладчика (обычно 32.), который по умолчанию создает свой файл дампа и запись в журнале. отличие от 2000 этот файл содержит не полный дамп, а минидамп. поэтому в ситуации, где для отладки рухнувшего приложения нужен полный дамп памяти процесса, вы можете изменить конфигурацию . , запустив его без аргументов командной строки, как было описано в предыдущем разделе.
 средах, где системы не подключены к интернету или где администратор хочет контролировать, какие именно отчеты об ошибках посылаются в , эти отчеты можно передавать на внутренний файл-сервер. предоставляет опытным заказчикам утилиту , которая понимает структуру каталогов, создаваемую , и позволяет администратору задавать условия, при которых отчеты формируются и передаются в . (подробности см. по ссылке :// ..///.) 
диспетчеризация системных сервисов
 как показано на рис. 3-1, обработчики ловушек ядра обслуживают прерывания, исключения и вызовы системных сервисов. из предыдущих разделов вы знаете, как проводится обработка прерываний и исключений. здесь будет рассказано о вызовах системных сервисов. диспетчеризация системных сервисов начинается с выполнения инструкции, закрепленной за такой диспетчеризацией. эта инструкция зависит от процессора, на котором работает .
диспетчеризация 32-разрядных системных сервисов
 процессорах 86 до использовалась инструкция 02 (десятичное значение 46). результате выполнения этой инструкции срабатывает ловушка, и заносит в запись под номером 46 указатель на диспетчер системных сервисов (см. таблицу 3-1). эта ловушка заставляет выполняемый поток переключиться в режим ядра и войти в диспетчер системных сервисов. номер запрошенного системного сервиса указывается числовым аргументом, переданным в регистр процессора . содержимое регистра указывает на список параметров, передаваемый системному сервису вызывающей программой.
 х86-процессорах и выше использует инструкцию , которую специально определил для быстрой диспетчеризации системных сервисов. для поддержки этой инструкции сохраняет на этапе загрузки адрес процедуры ядра - диспетчера системных сервисов в регистре, сопоставленном с данной инструкцией. выполнение инструкции приводит к переключению в режим ядра и запуску диспетчера системных сервисов. номер системного сервиса передается в регистре процессора , а регистр указывает на список аргументов, предоставленных вызвавшим кодом. для возврата в пользовательский режим диспетчер системных сервисов обычно выполняет инструкцию . ( некоторых случаях, например, когда в процессоре включен флаг -, диспетчер системных сервисов использует вместо инструкцию .) 
 32-разрядных процессорах кб и выше применяет специальную инструкцию , которая функционирует аналогично х86-ин-струкции ; записывает в регистр процессора, связанный с инструкцией , адрес диспетчера системных сервисов ядра. номер системного вызова передается в регистре , а в стеке хранятся аргументы, предоставленные вызвавшим кодом. после диспетчеризации ядро выполняет инструкцию . 
 при загрузке распознает тип процессора, на котором она работает, и выбирает подходящий системный код. этот код для в пользовательском режиме выглядит так:
 !: 
 7758 87000000 ,07 
 775 00037 ,070300 
 7752 2 
 7754 22400 024 
 номер системного сервиса - 07 (183 в десятичной форме), инструкция вызова выполняет код диспетчеризации системного сервиса, установленный ядром, который в данном примере находится по адресу 070300. поскольку пример взят для , используется . 
 !: 70300 84 , 
 70302 034 
 70304 сз 
диспетчеризация 64-разрядных системных сервисов
 архитектуре 64 операционная система использует инструкцию , которая работает аналогично инструкции на процессорах кб. передает номер системного вызова в регистре , первые четыре параметра в других регистрах, а остальные параметры (если они есть) в стеке:
 архитектуре 64 для тех же целей применяется инструкция ( ). первые восемь аргументов системного вызова передаются в регистрах, а остальное в стеке.
диспетчеризация системных сервисов режима ядра
 как показано на рис. 3-14, ядро использует номер системного сервиса для поиска информации о нем в таблице диспетчеризации системных сервисов ( ). эта таблица похожа на описанную ранее таблицу и отличается от нее тем, что каждый ее элемент содержит указатель на системный сервис, а не на процедуру обработки прерывания.
 примечание номера системных сервисов могут различаться в разных сервисных пакетах ( ) - время от времени добавляет или удаляет некоторые системные сервисы, а их номера генерируются автоматически при компиляции ядра. 
 диспетчер системных сервисов, , копирует аргументы вызвавшего кода из стека потока пользовательского режима в свой стек режима ядра (поэтому вызвавший код не может изменить значения аргументов после того, как они переданы ядру) и выполняет системный сервис. если переданные системному сервису аргументы содержат ссылки на буферы в пользовательском пространстве, код режима ядра проверяет возможность доступа к этим буферам, прежде чем копировать в них (или из них) данные.
 как будет показано в главе 6, у каждого потока есть указатель на таблицу системных сервисов. располагает двумя встроенными таблицами системных сервисов, но поддерживает до четырех. диспетчер системных сервисов определяет, в какой таблице содержится запрошенный сервис, интерпретируя 2-битное поле 32-битного номера системного сервиса как указатель на таблицу. младшие 12 битов номера системного сервиса служат индексом внутри указанной таблицы. эти поля показаны на рис. 3-15.
таблицы дескрипторов сервисов
 главная таблица по умолчанию, , определяет базовые сервисы исполнительной системы, реализованные в .. другая таблица, , включает в себя сервисы и , реализованные в 32. - той части подсистемы , которая работает в режиме ядра. когда -поток впервые вызывает сервис или , адрес таблицы системных сервисов потока меняется на адрес таблицы, содержащей сервисы и . функция позволяет 32. и другим драйверам добавлять новые таблицы системных сервисов. если в 2000 установлены службы (), их драйвер поддержки (.) после загрузки определяет дополнительную таблицу сервисов. так что после этого стороннее программное обеспечение может определить только одну дополнительную таблицу. таблица сервисов, добавляемая (кроме таблицы 32.), копируется в таблицы и -. поддерживает добавление лишь двух таблиц системных сервисов помимо главной и таблиц 32.
 примечание 2003 1 и выше не поддерживает добавление таблиц системных сервисов, если не считать те, которые включаются 32., так что этот способ не годится для расширения функциональности этой системы. 
 инструкции для диспетчеризации сервисов исполнительной системы содержатся в системной библиотеке .. -модули подсистем окружения вызывают функции из . для реализации своих документированных функций. исключением являются функции и - здесь инструкции для диспетчеризации системных сервисов реализованы непосредственно в 32. и 32., а не в .. эти два случая иллюстрирует рис. 3-6.
 как показано на рис. 3-6, -функция в 32. вызывает функцию из .. она в свою очередь выполняет соответствующую инструкцию, вызывающую срабатывание ловушки системного сервиса и передающую номер системного сервиса . далее диспетчер системных сервисов (функция в .) вызывает истинную для обработки запроса на ввод-вывод. для функций и диспетчер системных сервисов вызывает функции из 32., той части подсистемы , которая работает в режиме ядра.
 эксперимент: наблюдение за частотой вызова системных сервисов 
 вы можете наблюдать за частотой вызова системных сервисов с помощью счетчика / (системных вызовов/сек) объекта (система). откройте оснастку (производительность) и щелкните кнопку (добавить), чтобы добавить на график счетчик. выберите объект и счетчик /, затем щелкните кнопки и (закрыть).
диспетчер объектов
 как говорилось в главе 2, реализованная в модель объектов позволяет получать согласованный и безопасный доступ к различным внутренним сервисам исполнительной системы. этом разделе описывается диспетчер объектов ( ) - компонент исполнительной системы, отвечающий за создание, удаление, защиту и отслеживание объектов.
 эксперимент: исследование диспетчера объектов 
 этом разделе будут предлагаться эксперименты, которые покажут вам, как просмотреть базу данных диспетчера объектов. них будут использоваться перечисленные ниже инструменты, которые вам нужно освоить (если вы их еще не освоили).
  можно скачать с сайта . . она показывает пространство имен диспетчера объектов. другая версия этой утилиты есть в (\ \ \\ \.). однако версия с . сообщает более детальную информацию об объектах (например, счетчик ссылок, число открытых описателей, дескрипторы защиты и т. д.).
  и . отображают открытые описатели для процесса.
  . (имеется в ресурсах ) выводит открытые описатели для процесса, но требует предварительной установки специального глобального флага.
  команда / (в и 2003) отображает открытые описатели для процесса, но требует предварительной установки специального глобального флага.
  команда ! отладчика ядра отображает открытые описатели для процесса.
 средство просмотра объектов позволяет изучить пространство имен, поддерживаемое диспетчером объектов (имена есть не у всех объектов). попробуйте запустить нашу версию утилиты и проанализировать полученный результат (см. иллюстрацию ниже).
 как уже отмечалось, утилита и команда / требуют установки глобального флага «поддержка списка объектов» ( ). ( глобальных флагах см. соответствующий раздел далее в этой главе.) установит этот флаг, если он еще не задан. чтобы узнать, включен ли данный флаг, введите /. вы можете включить его командой / . любом случае нужно перезагрузить систему, чтобы новый параметр вступил в силу. ни , ни не требуют включения слежения за объектами, потому что для получения соответствующей информации они используют драйвер устройства.
 при разработке диспетчера объекта был выдвинут ряд требований, в соответствии с которыми он должен:
  реализовать общий, унифицированный механизм использования системных ресурсов;
  изолировать защиту объектов в одном участке операционной системы для соответствия требованиям безопасности класса 2;
  предоставлять механизм учета использования объектов процессами, позволяющий устанавливать лимиты на выделение процессам системных ресурсов;
  поддерживать такую схему именования объектов, которая позволяла бы легко включать как существующие объекты (устройства, файлы и каталоги файловой системы), так и независимые наборы объектов;
  соответствовать требованиям различных подсистем окружения операционной системы - например, поддерживать наследование ресурсов родительских процессов дочерними (необходимо в и ) и имена файлов, чувствительные к регистру букв (требуется в );
  устанавливать единообразные правила сохранения объектов в памяти (т. е.
 объект должен быть доступен, пока используется какими-либо процессами).
 существует два вида внутренних объектов: объекты исполнительной системы ( ) и объекты ядра ( ). первые реализуются различными компонентами исполнительной системы (диспетчером процессов, диспетчером памяти, подсистемой ввода-вывода и т. д.). вторые являются более примитивными объектами, которые реализуются ядром . эти объекты, невидимые коду пользовательского режима, создаются и используются только в исполнительной системе. объекты ядра поддерживают фундаментальную функциональность (например, синхронизацию), на которую опираются объекты исполнительной системы. так, многие объекты исполнительной системы содержат (инкапсулируют) один или несколько объектов ядра, как показано на рис. 3-17.
 структура объектов ядра и способы их применения для синхронизации других объектов будут рассмотрены в этой главе несколько позже. сейчас мы сосредоточимся на принципах работы диспетчера объектов, а также на структуре объектов исполнительной системы, описателях и таблицах описателей. вопросы, связанные с использованием этих объектов для управления доступом в , здесь затрагиваются лишь вскользь - подробнее на эту тему см. главу 8.
объекты исполнительной системы
 каждая подсистема окружения проецирует на свои приложения разные образы операционной системы. объекты исполнительной системы и сервисы объектов - именно те примитивы, из которых подсистемы окружения конструируют собственные версии объектов и других ресурсов.
 как правило, объекты исполнительной системы создаются подсистемой окружения в интересах пользовательских приложений или компонентов операционной системы в процессе обычной работы. так, для создания файла -приложение вызывает -функцию , реализованную в подсистемы , 32.. после проверки и инициализации в свою очередь вызывает , встроенный сервис , для создания объекта «файл» исполнительной системы.
 набор объектов, предоставляемый приложениям подсистемой окружения, может быть больше или меньше того набора, который предоставляется исполнительной системой. подсистема использует объекты исполнительной системы для экспорта собственных объектов, многие из которых прямо соответствуют объектам исполнительной системы. например, -объекты «мьютекс и «семафор» основаны непосредственно на объектах исполнительной системы (которые в свою очередь базируются на соответствующих объектах ядра). кроме того, подсистема предоставляет именованные каналы и почтовые ящики - ресурсы, созданные на основе объектов «файл» исполнительной системы. некоторые подсистемы вроде вообще не поддерживают объекты как таковые. подсистема использует объекты и сервисы исполнительной системы просто как основу для -процессов, каналов и других ресурсов, которые она предоставляет своим приложениям.
 таблице 3-3 кратко описываются основные объекты, предоставляемые исполнительной системой. подробнее об объектах исполнительной системы см. главы, в которых рассматриваются соответствующие компоненты исполнительной системы (а также справочную документацию , если речь идет об объектах исполнительной системы, напрямую экспортируемых в ).
 примечание 2000 исполнительная система реализует в общей сложности 27 типов объектов, а в и 2003 - 29- ( эти более новые версии добавлены объекты и .) многие из таких объектов предназначены только для использования компонентами исполнительной системы, которая и определяет их. эти объекты недоступны напрямую. пример таких объектов - , и . 
 примечание мьютекс - это название объектов «мутант» () в ; объект ядра, на котором основан мьютекс, имеет внутреннее имя мутант. 
структура объектов
 как показано на рис. 3-18, у каждого объекта есть заголовок и тело. диспетчер объектов управляет заголовками объектов, а телами объектов управляют владеющие ими компоненты исполнительной системы. кроме того, каждый заголовок объекта указывает на список процессов, которые открыли этот объект, и на специальный объект, называемый объектом типа ( ), - он содержит общую для всех экземпляров информацию.
заголовки и тела объектов
 диспетчер объектов использует данные, хранящиеся в заголовке, для управления объектами независимо от их типа. стандартные атрибуты заголовка кратко описываются в таблице 3-4.
 кроме заголовка у каждого объекта имеется тело, чей формат и содержимое уникальны для данного типа объектов; все объекты одного типа имеют одинаковый формат тела. создавая тип объектов и предоставляя для него сервисы, компонент исполнительной системы может контролировать манипуляции с данными в телах всех объектов этого типа.
 диспетчер объектов предоставляет небольшой набор базовых сервисов, которые работают с атрибутами заголовка объекта и применимы к объектам любого типа (хотя некоторые базовые сервисы не имеют смысла для отдельных объектов). эти сервисы, часть которых доступна -приложениям через подсистему , перечислены в таблице 3-5.
 базовые сервисы поддерживаются для всех типов объектов, но у каждого объекта есть свои сервисы для создания, открытия и запроса. так, подсистема ввода-вывода реализует сервис создания файлов для объектов «файл», а диспетчер процессов - сервис создания процессов для объектов «процесс». конечно, можно было бы реализовать единый сервис создания объектов, но подобная процедура оказалась бы весьма сложной, так как набор параметров, необходимых для инициализации объекта «файл», значительно отличается, скажем, от параметров инициализации объекта «процесс». при вызове потоком сервиса объекта для определения его типа и обращении к соответствующей версии сервиса диспетчер объектов каждый раз сталкивался бы с необходимостью обработки дополнительных данных. силу этих и иных причин сервисы, обеспечивающие создание, открытие и запросы, для каждого типа объектов реализованы отдельно.
объекты типа
 заголовках объектов содержатся общие для всех объектов атрибуты, но их значения могут меняться у конкретных экземпляров данного объекта. так, у каждого объекта есть уникальное имя и может быть уникальный дескриптор защиты. однако некоторые атрибуты объектов остаются неизменными для всех объектов данного типа. например, при открытии описателя объекта можно выбрать права доступа из набора, специфичного для объектов данного типа. исполнительная система предоставляет в том числе атрибуты доступа «завершение» () и «приостановка» () для объектов «поток», а также «чтение» (), «запись» (), «дозапись» () и «удаление» () для объектов «файл». другой пример атрибута, специфичного для типа объектов, - синхронизация, о которой мы кратко расскажем ниже.
 чтобы сэкономить память, диспетчер объектов сохраняет статические атрибуты, специфичные для конкретного типа объектов, только при создании нового типа объектов. для записи этих данных он использует собственный объект типа. как показано на рис. 3-19, если установлен отладочный флаг отслеживания объектов (описываемый в разделе «глобальные флаги » далее в этой главе), все объекты одного типа (в данном случае - «процесс») связываются между собой с помощью объекта типа, что позволяет диспетчеру объектов при необходимости находить их и перечислять.
 эксперимент: просмотр заголовков объектов и объектов типа 
 вы можете увидеть список объектов типа, объявленных диспетчеру объектов, с помощью утилиты . далее в откройте каталог \, как показано на следующей иллюстрации.
 чтобы просмотреть структуру данных типа объектов «процесс» в отладчике ядра, сначала идентифицируйте этот объект командой !: 
 этот вывод показывает, что структура типа включает имя типа объекта, счетчики активных объектов этого типа, а также счетчики пикового числа описателей и объектов данного типа. поле хранится указатель на структуру данных, в которой содержатся атрибуты, общие для всех объектов этого типа, а также указатели на методы типа:
 объектами типов нельзя управлять из пользовательского режима из-за отсутствия соответствующих сервисов диспетчера объектов. некоторые из определяемых ими атрибутов видимы через отдельные системные сервисы и функции . атрибуты, хранящиеся в объектах типа, описываются в таблице 3-6.
 синхронизация, один из атрибутов, видимых -приложениям, относится к способности потока синхронизировать свое выполнение, ожидая изменения состояния определенного объекта. поток можно синхронизировать по таким объектам исполнительной системы, как задание, процесс, поток, файл, событие, семафор, мьютекс и таймер. другие объекты исполнительной системы не поддерживают синхронизацию. способность объекта к синхронизации зависит от того, содержит ли он встроенный объект диспетчера - объект ядра, который будет рассмотрен далее в этой главе.
методы объекта
 атрибут «методы», последний из перечисленных в таблице 3-6, состоит из набора внутренних процедур, похожих на конструкторы и деструкторы ++, т. е. на процедуры, автоматически вызываемые при создании или уничтожении объекта. диспетчере объектов эта идея получила дальнейшее развитие: он вызывает методы объекта и в других ситуациях, например при открытии или закрытии описателя объекта или при попытке изменения параметров защиты объекта. некоторых типах объектов методы определяются в зависимости от того, как должен использоваться данный тип объектов.
 при создании нового типа объектов компонент исполнительной системы может зарегистрировать у диспетчера объектов один или несколько методов. после этого диспетчер объектов вызывает методы на определенных этапах жизненного цикла объектов данного типа - обычно при их создании, удалении или модификации. поддерживаемые диспетчером объектов методы перечислены в таблице 3-7.
 диспетчер объектов вызывает метод всякий раз, когда создает описатель объекта (что происходит при создании или открытии объекта). однако метод определен только в одном типе объектов - . этот метод необходим таким объектам для того, чтобы 32. мог использовать часть памяти совместно с процессом, который служит в качестве пула памяти, связанного с объектом «рабочий стол».
 пример использования метода можно найти в подсистеме ввода-вывода. диспетчер ввода-вывода регистрирует метод для объектов типа «файл», а диспетчер объектов вызывает метод при закрытии каждого описателя объекта этого типа. метод проверяет, не осталось ли у процесса, закрывающего описатель файла, каких-либо блокировок для файла, и, если таковые есть, снимает их. диспетчер объектов не может и не должен самостоятельно проверять наличие блокировок для файла.
 перед удалением временного объекта из памяти диспетчер объектов вызывает метод , если он зарегистрирован. например, диспетчер памяти регистрирует для объектов типа «раздел» метод , освобождающий физические страницы, используемые данным разделом. перед удалением объекта «раздел» этот метод также проверяет различные внутренние структуры данных, выделенные для раздела диспетчером памяти. диспетчер объектов не мог бы сделать эту работу, поскольку он ничего не знает о внутреннем устройстве диспетчера памяти. методы других объектов выполняют аналогичные функции.
 если диспетчер объектов находит существующий вне его пространства имен объект, метод (по аналогии с методом ) позволяет этому диспетчеру передавать управление вторичному диспетчеру объектов. когда диспетчер объектов анализирует имя объекта, он приостанавливает анализ, встретив объект с сопоставленным методом , и вызывает метод , передавая ему оставшуюся часть строки с именем объекта. кроме пространства имен диспетчера объектов, в есть еще два пространства имен: реестра (реализуемое диспетчером конфигурации) и файловой системы (реализуемое диспетчером ввода-вывода через драйверы файловой системы). диспетчере конфигурации см. главу 5; о диспетчере ввода-вывода и драйверах файловой системы см. главу 9.
 например, когда процесс открывает описатель объекта с именем \\ 0\\., диспетчер объектов просматривает свое дерево имен и ищет объект с именем . обнаружив, что с этим объектом сопоставлен метод , он вызывает его, передавая ему остаток строки с именем объекта (в данном случае - строку \\.). метод объектов «устройство» ( ) является процедурой ввода-вывода, которая регистрируется диспетчером ввода-вывода при определении типа объекта «устройство». процедура диспетчера ввода-вывода принимает строку с именем и передает ее соответствующей файловой системе, которая ищет файл на диске и открывает его.
 подсистема ввода-вывода также использует метод , аналогичный методу . он вызывается каждый раз, когда поток пытается запросить или изменить параметры защиты файла. эта информация для файлов отличается от таковой для других объектов, поскольку хранится в самом файле, а не в памяти. поэтому для поиска, считывания или изменения параметров защиты нужно обращаться к подсистеме ввода-вывода.
описатели объектов и таблица описателей, принадлежащая процессу
 когда процесс создает или открывает объект по имени, он получает описатель (), который дает ему доступ к объекту. ссылка на объект по описателю работает быстрее, чем по имени, так как при этом диспетчер объектов может сразу найти объект, не просматривая список имен. процессы также могут получать описатели объектов, во-первых, путем их наследования в момент своего создания (если процесс-создатель разрешает это, указывая соответствующий флаг при вызове , и если описатель помечен как наследуемый либо в момент создания, либо позднее, вызовом -функции ), а во-вторых, за счет приема дублированного описателя от другого процесса (см. описание -функции ). 
 чтобы потоки процесса пользовательского режима могли оперировать объектом, им нужен описатель этого объекта. идея применения описателей для управления ресурсами сама по себе не нова. например, стандартные библиотеки языков с, (и других) при открытии файла возвращают его описатель. описатели служат косвенными указателями на системные ресурсы, что позволяет прикладным программам избегать прямого взаимодействия с системными структурами данных.
 примечание компоненты исполнительной системы и драйверы устройств могут обращаться к объектам напрямую, поскольку выполняются в режиме ядра и ввиду этого имеют доступ к структурам объектов в системной памяти. однако они должны объявлять о своем использовании объектов, увеличивая значение счетчика ссылок, что гарантирует сохранность нужного объекта (см. раздел «хранение объектов в памяти» далее в этой главе). 
 описатели дают и другие преимущества. во-первых, описатели файлов, событий или процессов совершенно одинаковы - просто ссылаются на разные объекты. это дает возможность создать унифицированный интерфейс для ссылок на объекты любого типа. во-вторых, только диспетчер объектов имеет право физически создавать описатели и искать их объекты, а значит, он может проанализировать любое действие с объектом в пользовательском режиме и решить, позволяет ли профиль защиты вызывающей программы выполнить над объектом запрошенную операцию.
 эксперимент: просмотр открытых описателей 
 запустите и убедитесь, что в его окне нижняя секция включена и настроена на отображение открытых описателей. (выберите , и .) затем откройте окно командной строки и просмотрите таблицу описателей для нового процесса .. вы должны увидеть открытый описатель файла - текущего каталога. например, если текущий каталог - : \, выводит следующее.
 если вы теперь смените текущий каталог командой , то покажет, что описатель предыдущего каталога закрыт и открыт описатель нового текущего каталога. предыдущий описатель ненадолго выделяется красным цветом, а новый - зеленым. длительность подсветки настраивается щелчком кнопки и регулировкой параметра .
 такая функциональность упрощает наблюдение за изменениями в таблице описателей. например, если в процессе происходит утечка описателей, просмотр таблицы описателей в позволяет быстро увидеть, какой описатель (или описатели) открывается, но не закрывается. эта информация помогает программисту обнаружить утечку описателей.
 таблицу открытых описателей также можно вывести, используя командную строку утилиты . например, обратите внимание на следующий фрагмент вывода , где показана таблица описателей для процесса . до и после смены каталога:
 описатель объекта представляет собой индекс в таблице описателей, принадлежащей процессу. нее указывает блок процесса исполнительной системы (), рассматриваемый в главе 6. индекс первого описателя равен 4, второго - 8 и т. д. таблица содержит указатели на все объекты, описатели которых открыты данным процессом. эти таблицы реализованы по трехуровневой схеме аналогично тому, как блок управления памятью в системах типа 86 реализует трансляцию виртуальных адресов в физические, поддерживая более 16 000 000 описателей на каждый процесс (см. главу 7).
 при создании процесса в 2000 диспетчер объектов формирует верхний уровень таблицы описателей, содержащий указатели на таблицы среднего уровня; средний уровень содержит первый массив указателей на таблицы вторичных описателей, а нижний - первую таблицу вторичных описателей. рис. 3-20 показана структура таблицы описателей в 2000. этой операционной системе диспетчер объектов интерпретирует младшие 24 бита описателя объекта как три 8-битных поля, являющиеся индексами для каждого из трех уровней таблицы описателей. и 2003 при создании процесса создается лишь таблица описателей нижнего уровня - остальные уровни формируются по мере необходимости. 2000 таблица вторичных описателей состоит из 255 элементов. и 2003 такая же таблица включает столько элементов, сколько помещается на страницу памяти минус один элемент, который используется для аудита описателей ( ). например, на х86-системах размер страницы составляет 4096 байтов. делим это значение на размер элемента (8 байтов), вычитаем 1 и получаем всего 511 элементов в таблице описателей нижнего уровня. наконец, таблица описателей среднего уровня в и 2003 содержит полную страницу указателей на таблицы вторичных описателей, поэтому количество таблиц вторичных описателей зависит от размеров страницы и указателя на конкретной аппаратной платформе.
 эксперимент: создание максимального количества описателей 
 тестовая программа (../.) позволяет открывать описатели объекта до тех пор, пока не будет исчерпан их лимит. ее помощью вы увидите, сколько описателей можно создать в одном процессе в вашей системе. поскольку память под таблицу описателей выделяется из пула подкачиваемых страниц, этот пул может быть исчерпан до того, как вы достигнете предельного числа описателей, допустимых в одном процессе.
 1. скачайте файл . по только что упомянутой ссылке и раз-архивируйте его в какой-нибудь каталог.
 2. запустите , щелкните , затем . обратите внимание на текущий и максимальный размеры пула подкачиваемой памяти. (для вывода максимальных размеров пулов нужно настроить на доступ к символам для образа ядра, ..) пусть эта информация отображается, когда вы запустите программу .
 3. откройте окно командной строки.
 4. запустите программу с ключом ~ (для этого введите - ). когда не удастся открыть очередной описатель, она сообщит общее число созданных ею описателей. если это значение окажется меньше, чем около 16 миллионов, то, вероятно, вы исчерпали пул подкачиваемой памяти до достижения теоретически предельного числа описателей.
 5. закройте окно командной строки; это приведет к завершению процесса и автоматическому закрытию всех открытых описателей.
 как показано на рис. 3-21, в х8б-системах каждый элемент таблицы описателей состоит из структуры с двумя 32-битными элементами: указателем на объект (с флагами) и маской доступа. 64-разрядных системах каждый элемент имеет размер 12 байтов и состоит из 64-битного указателя на заголовок объекта и 32-битной маски доступа (маски доступа описываются в главе 8).
 2000 первый 32-битный элемент содержит указатель на заголовок объекта и четыре флага. поскольку заголовки объектов всегда выравниваются по границе 8 байтов, в качестве флагов используются младшие 3 бита и один старший. старший бит является флагом блокировки (). когда диспетчер объектов транслирует описатель в указатель на объект, он блокирует соответствующую запись на время трансляции. так как все объекты находятся в системном адресном пространстве, старший бит указателя на объект устанавливается в 1. (гарантируется, что адреса всегда будут превышать 080000000 даже на системах, запускаемых с ключом загрузки /3.) так что, пока элемент таблицы описателей не заблокирован, диспетчер объектов может сбросить старший бит в 0. при блокировке элемента таблицы диспетчер объектов устанавливает этот бит и получает корректное значение указателя. диспетчер блокирует всю таблицу описателей (используя специальную блокировку, сопоставляемую с каждым процессом), только если процесс создает новый описатель или закрывает существующий. и 2003 флаг блокировки хранится в младшем бите указателя на объект. флаг, который в 2000 хранился в этом бите, теперь хранится в ранее зарезервированном бите маски доступа.
 первый флаг указывает, имеет ли право вызывающая программа закрывать данный описатель. второй определяет, получат ли процессы, созданные данным процессом, копию этого описателя. (как уже отмечалось, наследование описателя можно указать при его создании или позже, через -функцию . этот флаг тоже можно задать вызовом -) третий задает, будет ли генерироваться сообщение аудита при закрытии объекта. (этот флаг не предоставляется в и предназначен для внутреннего использования диспетчером объектов.)
 системным компонентам и драйверам устройств зачастую нужно открывать описатели объектов, доступа к которым у приложений пользовательского режима нет. это достигается созданием описателей в таблице описателей ядра ( ) (внутреннее имя - ). описатели в этой таблице доступны только в режиме ядра в контексте любого процесса. это значит, что функции режима ядра могут ссылаться на эти описатели из контекста любого процесса без ущерба для производительности. диспетчер объектов распознает ссылки на описатели в таблице описателей ядра, когда старший бит в них установлен, т. е. когда в таких ссылках содержатся значения, превышающие 080000000. 2000 таблица описателей ядра является независимой таблицей описателей, но в и 2003 она служит и таблицей описателей для процесса .
 эксперимент: просмотр таблицы описателей с помощью отладчика ядра 
 команда ! отладчика ядра допускает следующие аргументы:
 ! ‹индекс_описателя› ‹флаги› ‹идентификатор_процесса› 
 индекс описателя определяет элемент в таблице описателей (0 - вывод всех описателей). индекс первого описателя равен 4, второго - 8 и т. д. например, введя ! 4, вы увидите первый описатель в текущем процессе.
 вы можете указывать флаги, являющиеся битовыми масками, где бит 0 означает, что нужно вывести лишь информацию из элемента таблицы, бит 1 - показать не только используемые, но и свободные описатели, а бит 2 - сообщить информацию об объекте, на который ссылается описатель. следующая команда выводит полную информацию о таблице описателей в процессе с идентификатором 0408.
защита объектов
 открывая файл, нужно указать, для чего это делается - для чтения или записи. если вы попытаетесь записать что-нибудь в файл, открытый для чтения, то получите ошибку. аналогичным образом действует и исполнительная система: когда процесс создает объект или открывает описатель существующего объекта, он должен указывать набор желательных прав доступа ( ), сообщая тем самым, что именно он собирается делать с объектом. процесс может запросить либо набор стандартных прав доступа (чтение, запись, выполнение), применимых ко всем объектам, либо специфические права доступа, различные для объектов разного типа. так, в случае объекта «файл» процесс может запросить права на удаление файла или дозапись, а в случае объекта «поток» - права на приостановку потока или его завершение.
 когда процесс открывает описатель объекта, диспетчер объектов вызывает так называемый монитор состояния защиты* ( ), часть подсистемы защиты, работающую в режиме ядра, и посылает ему уведомление о наборе желательных для процесса прав доступа. монитор состояния защиты проверяет, разрешает ли дескриптор защиты объекта запрашиваемый тип доступа. если да, монитор состояния защиты возвращает процессу набор предоставленных прав доступа ( ), информацию о которых диспетчер объектов сохраняет в создаваемом им описателе объекта. как подсистема защиты определяет, кто и к каким объектам может получать доступ, рассматривается в главе 8.
 * самом деле этот компонент представляет собой нечто вроде монитора запросов к подсистеме защиты. - прим. перев. 
 после этого всякий раз, когда потоки процесса используют описатель, диспетчер объектов может быстро проверить, соответствует ли набор предоставленных прав доступа, хранящихся в описателе, действиям, которые намеревается выполнить вызванный потоками сервис объекта. так, если вызывающая программа запросила доступ для чтения к объекту «раздел», а затем вызывает сервис для записи в этот объект, последний сервис не выполняется.
хранение объектов в памяти
 объекты бывают двух типов: временные () и постоянные (). большинство объектов временные, т. е. они хранятся, пока используются, и освобождаются, как только необходимость в них отпадает. постоянные объекты существуют до тех пор, пока они не освобождаются явным образом. поскольку большинство объектов временные, остальная часть этого раздела будет посвящена тому, как диспетчер объектов реализует хранение объектов в памяти ( ), т. е. сохранение временных объектов лишь до тех пор, пока они используются, с их последующим удалением. так как для доступа к объекту все процессы пользовательского режима должны сначала открыть его описатель, диспетчер объектов может легко отслеживать, сколько процессов и даже какие именно из них используют объект. учет описателей является одним из механизмов, реализующих хранение объектов в памяти. этот механизм двухфазный. первая фаза называется хранением имен ( ) и контролируется числом открытых описателей объекта. каждый раз, когда процесс открывает описатель объекта, диспетчер увеличивает значение счетчика открытых описателей в заголовке объекта. по мере того как процессы завершают использование объекта и закрывают его описатели, диспетчер уменьшает значение этого счетчика. когда счетчик обнуляется, диспетчер удаляет имя объекта из своего глобального пространства имен. после этого новые процессы уже не смогут открывать описатели данного объекта.
 вторая фаза заключается в том, что прекращается хранение тех объектов, которые больше не используются (т. е. они удаляются). так как код операционной системы обычно обращается к объектам по указателям, а не описателям, диспетчер объектов должен регистрировать и число указателей объектов, переданных процессам операционной системы. при каждой выдаче указателя на объект он увеличивает значение счетчика ссылок на объект. компоненты режима ядра, прекратив использовать указатель, вызывают диспетчер объектов для уменьшения счетчика ссылок. система также увеличивает счетчик ссылок при увеличении счетчика описателей, а при уменьшении счетчика описателей соответственно уменьшает счетчик ссылок, поскольку описатель тоже является подлежащей учету ссылкой на объект (подробнее об этих механизмах см. описание функции или - в ).
 рис. 3-22 показаны два задействованных объекта-события. процесс открыл первый объект, а процесс - оба объекта. кроме того, на первый объект ссылается какая-то структура режима ядра, и его счетчик ссылок вен 3. так что, даже если оба процесса закроют свои описатели первого объекта, он по-прежнему будет существовать, поскольку его счетчик ссылок еще не обнулится. , когда процесс закроет свой описатель второго объекта, этот объект будет удален.
 таким образом, даже если счетчик открытых описателей объекта обну-лится, счетчик ссылок может превышать нулевое значение, указывая, что операционная система еще использует объект. конце концов счетчик ссылок тоже обнулится, и тогда диспетчер удалит соответствующий объект из памяти.
 такой механизм позволяет хранить объект и его имя в памяти, просто не закрывая его описатель. программистам, создающим приложения с двумя и более взаимодействующими процессами, не приходится беспокоиться о том, что один из процессов удалит объект в то время, когда он еще используется другим процессом. кроме того, закрытие описателей объекта, принадлежащих приложению, еще не означает, что этот объект будет немедленно удален, - он может использоваться операционной системой. например, какой-то процесс создает второй процесс для выполнения программы в фоновом режиме, после чего немедленно закрывает описатель созданного процесса. так как второй процесс еще не закончил свою работу и выполняется операционной системой, она поддерживает ссылку на этот объект «процесс». диспетчер сможет обнулить счетчик ссылок на второй процесс и удалить его, только когда завершится выполнение этого процесса.
учет ресурсов
 учет ресурсов, как и хранение объектов, тесно связан с использованием описателей объектов. положительное значение счетчика открытых описателей указывает на то, что данный ресурс задействован какими-то процессами. когда счетчик описателей и счетчик ссылок на некий объект обнуляются, процессы, использовавшие этот объект, больше не занимают память, отведенную под него.
 многих операционных системах для ограничения доступа процессов к системным ресурсам применяется система квот. однако типы устанавливаемых для процессов квот иногда весьма разнообразны, а отслеживающий квоты код распределен по всей операционной системе. так, в некоторых операционных системах компонент ввода-вывода может регистрировать и ограничивать число файлов, которые может открыть процесс, а компонент управления памятью может накладывать ограничения на объем памяти, выделяемой потокам процесса. компонент, отвечающий за управление процессами, способен ограничивать максимальное число новых процессов или новых потоков процесса. каждое из этих ограничений отслеживается и реализуется в различных частях операционной системы.
 диспетчер объектов , напротив, представляет собой компонент централизованного учета ресурсов. заголовке каждого объекта содержится атрибут квоты, определяющий, насколько диспетчер объектов уменьшает квоту подкачиваемой или неподкачиваемой памяти процесса при открытии его потоком описателя этого объекта.
 у каждого процесса в имеется структура квот, регистрирующая лимиты и текущее количество используемой памяти из подкачиваемого и неподкачиваемого пулов, а также из страничного файла. (введите !_ __ в отладчике ядра, чтобы увидеть формат этой структуры.) значения данных квот по умолчанию равны 0 (ограничений нет), но их можно указать, модифицировав параметры в реестре (см. параметры , и в разделе \\\ \ ). заметьте, что все процессы в интерактивном сеансе используют один и тот же блок квот (документированного способа создания процессов с собственными блоками квот нет).
имена объектов
 важное условие для создания множества объектов - эффективная система учета. для учета диспетчеру объектов нужна следующая информация:
  способ, которым можно было бы отличать один объект от другого;
  метод поиска и получения конкретного объекта.
 первое требование реализуется за счет присвоения имен объектам. это расширение обычной для большинства операционных систем функциональности, в которых отдельным системным ресурсам, например файлам, каналам или блокам разделяемой памяти, можно присваивать имена. исполнительная система, напротив, позволяет именовать любой объект, представляющий ресурс. второе требование (поиск и получение объектов) также реализуется через именование объектов. если диспетчер хранит объекты в соответствии с их именами, он может быстро найти объект по его имени.
 имена объектов отвечают и третьему требованию, не упомянутому в предыдущем списке: процессам должна быть предоставлена возможность совместного использования объектов. пространство имен объектов исполнительной системы является глобальным, видимым любому процессу в системе. если один процесс создает объект и помещает его имя в глобальное пространство имен, то другой процесс может открыть описатель этого объекта, указав нужное имя. если объект не предназначен для совместного использования, процесс-создатель просто не присваивает ему имя.
 для большей эффективности диспетчер объектов не ищет имя объекта при каждой попытке его использования. поиск по имени ведется только в двух случаях. во-первых, при создании процессом именованного объекта: перед тем как сохранить имя объекта в глобальном пространстве имен, диспетчер проверяет, нет ли в нем такого же имени. во-вторых, открывая описатель именованного объекта, диспетчер ищет объект по имени и возвращает его описатель, который затем используется для ссылки на объект. диспетчер позволяет выбирать, надо ли при поиске учитывать регистр букв. эта функциональность поддерживается и другими подсистемами окружения, в которых имена файлов чувствительны к регистру букв.
 где именно хранятся имена объектов, зависит от типа объектов. таблице 3-8 перечислены стандартные каталоги объектов, имеющиеся на всех системах под управлением . пользовательским программам видны только каталоги \ и \?? (\?? в 2000).
 поскольку имена базовых объектов ядра вроде мьютексов, событий, семафоров, ожидаемых таймеров и разделов хранятся в одном каталоге, они не должны совпадать, даже если относятся к объектам разных типов. это ограничение подчеркивает, насколько осторожно надо выбирать имена, чтобы они не конфликтовали с другими (используйте, например, префиксы имен в виде названия вашей компании и программного продукта).
 имена объектов глобальны в пределах компьютера (или всех процессоров на многопроцессорной системе) и невидимы через сеть. однако метод диспетчера объектов позволяет получать доступ к именованным объектам, существующим на других компьютерах. так, диспетчер ввода-вывода, предоставляющий сервисы объектов «файл», расширяет функции диспетчера объектов для работы с файлами на удаленных компьютерах. при запросе на открытие объекта «файл» на удаленном компьютере диспетчер объектов вызывает метод , что позволяет диспетчеру ввода-вывода перехватить запрос и направить его сетевому редиректору - драйверу, обращающемуся к файлам через сеть. серверный код на удаленной -системе вызывает диспетчер объектов и диспетчер ввода-вывода на этой системе для поиска нужного объекта «файл» и возврата данных через сеть.
 эксперимент: просмотр именованных базовых объектов 
 список именованных базовых объектов можно просмотреть с помощью утилиты . запустите . и щелкните каталог \, как показано ниже.
 именованные объекты отображаются справа. тип объектов обозначается следующими значками:
  «» - мьютексы;
  в виде микросхем памяти - разделы (объекты «проекция файла»);
  в виде восклицательного знака - события;
  похожие на светофоры - семафоры;
  в виде изогнутой стрелки - символьные ссылки.
объекты «каталоги объектов» ( )
 помощью этих объектов диспетчер объектов поддерживает иерархическую структуру пространства имен. этот объект аналогичен каталогу файловой системы и содержит имена других объектов, а также другие каталоги объектов. он включает информацию, достаточную для трансляции имен объектов в указатели на сами объекты. диспетчер использует указатели для создания описателей объектов, возвращаемых программам пользовательского режима. каталоги для хранения объектов могут создаваться как кодом режима ядра (включая компоненты исполнительной системы и драйверы устройств), так и кодом пользовательского режима (в том числе подсистемами). например, диспетчер ввода-вывода создает каталог объектов \ с именами объектов, представляющих устройства ввода-вывода.
символьные ссылки ( )
 некоторых файловых системах (например, и отдельных -системах) с помощью символьной ссылки можно создать имя файла или каталога, которое при использовании будет транслироваться операционной системой в другое имя файла или каталога. символьные ссылки - простой метод неявного разделения файлов или каталогов за счет создания перекрестных ссылок между различными каталогами в обычной иерархической структуре каталогов.
 диспетчер объектов реализует объект «символьная ссылка», который выполняет аналогичную функцию в отношении имен объектов в пространстве имен. символьная ссылка может находиться в любом месте строки с именем объекта. когда вызывающая программа ссылается на имя объекта «символьная ссылка», диспетчер просматривает пространство имен в поисках такого объекта. далее он анализирует содержимое символьной ссылки и находит строку, которую надо подставить вместо ссылки. после этого начинается поиск другого объекта, соответствующего полученному имени.
 исполнительная система использует такие объекты при трансляции имен устройств в стиле - во внутренние имена устройств . пользователь обращается к гибким и жестким дискам по именам :, :, с: и т. д. или к последовательным портам по именам , 2 и т. п. подсистема делает эти объекты «символьная ссылка» в защищенные глобальные данные, помещая их в каталог объектов \?? (в 2000) или \?? (в и 2003).
пространство имен сеанса
 изначально создавалась в расчете на регистрацию в системе одного интерактивного пользователя и выполнение лишь одного экземпляра любого из интерактивных приложений. добавление в 2000 и поддержки быстрого переключения пользователей в потребовало некоторых изменений в модели пространства имен диспетчера объектов для поддержки множества интерактивных пользователей одновременно. (базовые сведения о службах терминала и сеансах см. в главе 1.)
 пользователь, зарегистрированный в консольном сеансе, получает доступ к глобальному пространству имен, которое является первым экземпляром пространства имен. дополнительные сеансы получают свое (закрытое) представление пространства имен, называемое локальным пространством имен. части пространства имен, локальные для каждого сеанса, включают \-, \ и \. формирование раздельных копий одних и тех же частей называется созданием экземпляров () пространства имен. создание экземпляров каталога \ позволяет каждому пользователю обозначать сетевые дисковые устройства разными буквами и по-разному именовать такие объекты, как, например, последовательные порты. 2000 глобальный каталог \ называется \?? и является каталогом, на который указывает символьная ссылка \, а локальные каталоги \ идентифицируются по идентификатору для сеанса сервера терминала. и более поздних операционных системах глобальный каталог \ называется \?? и является каталогом, на который указывает \, а локальные каталоги \ определяются по идентификатору сеанса входа ( ).
 32. создает в каталоге \ интерактивный бъкт-, \0. среда может поддерживать несколько интерактивных пользователей, но для сохранения иллюзии доступа к предопределенному интерактивному объекту в каждому пользователю нужна собственная версия 0. наконец, в каталоге \ приложения и система создают разделяемые объекты, включая события, мьютексы и разделы. если приложение, создающее именованный объект, запущено двумя пользователями, то в каждом сеансе нужна своя версия этого объекта, чтобы два экземпляра приложения не мешали друг другу, обращаясь к одному объекту.
 диспетчер объектов реализует локальное пространство имен, создавая закрытые версии трех каталогов, которые находятся в каталоге, сопоставленном с сеансом пользователя (\\, где - идентификатор сеанса). например, когда некое -приложение во время удаленного сеанса номер 2 создает именованное событие, диспетчер объектов перенаправляет имя этого объекта из \ в \\2\.
 все функции диспетчера объектов, связанные с управлением пространством имен, знают о локальных экземплярах каталогов и участвуют в поддержании иллюзии того, что в удаленных сеансах используется то же пространство имен, что и в консольных. -модули подсистемы добавляют к именам, передаваемым -приложениями, которые ссылаются на объекты в \, префиксы \?? (например, : \ превращается в \??\: \). когда диспетчер объектов обнаруживает специальный префикс \?? предпринимаемые им действия зависят от версии , но при этом он всегда полагается на поле в объекте «процесс», создаваемом исполнительной системой ( ) (, о котором пойдет речь в главе 6). это поле указывает на структуру данных, разделяемую с другими процессами в том же сеансе. поле структуры указывает на каталог диспетчера объектов, представляющий локальный \ процесса. целевой каталог зависит от конкретной системы.
  если системой является 2000 и не установлены, поле в структуре процесса указывает на каталог \?? так как локальных пространств имен нет.
  если системой является 2000 и установлены, то, когда активным становится новый сеанс, система копирует все объекты из глобального каталога \?? в локальный для сеанса каталог \, и поле структуры указывает на этот локальный каталог.
  и 2003 система не копирует глобальные объекты в локальные каталоги . диспетчер объектов, встретив ссылку на \?? находит локальный для процесса каталог \, используя поле структуры . если нужного объекта в этом каталоге нет, он проверяет поле объекта «каталог» и, если это допустимо, ищет объект в каталоге, на который указывает поле структуры . этим каталогом всегда является \??.
 определенных обстоятельствах приложениям, поддерживающим , нужен доступ к объектам в консольном сеансе, даже если сами приложения выполняются в удаленном сеансе. это может понадобиться приложениям для синхронизации со своими экземплярами, выполняемыми в других удаленных или консольных сеансах. таких случаях для доступа к глобальному пространству имен приложения могут использовать специальный префикс \, поддерживаемый диспетчером объектов. так, объект \\, открываемый приложением в сеансе номер 2, направляется вместо каталога \\2\\- в каталог \\.
 и 2003 приложение, которому нужно обратиться к объекту в глобальном каталоге \, не требуется использовать префикс \, если только этого объекта нет в локальном каталоге \. это вызвано тем, что диспетчер объектов автоматически ищет объект в глобальном каталоге, не найдя его в локальном. однако приложение, работающее в 2000 с , должно всегда указывать префикс \ для доступа к объектам в глобальном каталоге \-.
 эксперимент: просмотр экземпляров пространства имен 
 вы можете увидеть, как диспетчер объектов создает экземпляры пространства имен, создав сеанс, отличный от консольного, и просмотрев таблицу описателей для процесса в этом сеансе. или в системе, которая не входит в домен, отключите консольный сеанс [откройте меню (пуск), щелкните (выход из системы) и выберите (смена пользователя) или нажмите комбинацию клавиш -+]. теперь войдите в систему под новой учетной записью. если вы работаете с 2000 , или , запустите клиент , подключитесь к серверу и войдите в систему.
 войдя в систему в новом сеансе, запустите , щелкните каталог \ и вы увидите подкаталог с числовым именем для каждого активного удаленного сеанса. открыв один из таких каталогов, вы обнаружите подкаталоги \, \ и \-, которые относятся к локальному пространству имен сеанса. одно из таких локальных пространств имен показано на иллюстрации ниже.
 далее запустите и выберите какой-нибудь процесс в новом сеансе (вроде .). просмотрите таблицу описателей, щелкнув , и . вы должны увидеть описатель \\\ под \\, где - идентификатор сеанса. объекты с глобальными именами появятся в \-\\.
синхронизация
 концепция взаимоисключения ( ) является одной из ключевых при разработке операционных систем. смысл в следующем: в каждый момент к конкретному ресурсу может обращаться один - и только один - поток. взаимоисключение необходимо, когда ресурс не предназначен для разделения или когда такое разделение может иметь непредсказуемые последствия. например, если бы два потока одновременно копировали данные в порт принтера, отпечатанный документ представлял бы собой нечитаемую мешанину. аналогичным образом, если бы один поток считывал какой-то участок памяти, когда другой записывал бы туда данные, первый поток получил бы непредсказуемый набор данных. общем случае доступные для записи ресурсы нельзя разделять без ограничений. рис. 3-23 иллюстрирует, что происходит, когда два потока, выполняемые на разных процессорах, одновременно записывают данные в циклическую очередь.
 поскольку второй поток получил значение указателя на конец очереди до того, как первый поток завершил его обновление, второй вставил свои данные в то же место, что и первый. таким образом, данные первого потока были перезаписаны другими данными, а один участок очереди остался пустым. хотя рис. 3-23 иллюстрирует, что могло бы случиться в многопроцессорной системе, аналогичную ошибку было бы нельзя исключить и в однопроцессорной системе - при переключении контекста на второй поток до того, как первый поток успел бы обновить указатель на конец очереди.
 разделы кода, обращающиеся к неразделяемым ресурсам, называются критическими секциями ( ). критической секции единовременно может выполняться только один поток. пока один поток записывает в файл, обновляет базу данных или модифицирует общую переменную, доступ к этому ресурсу со стороны других потоков запрещен. псевдокод, показанный на рис. 3-23, представляет собой критическую секцию, которая некорректно обращается к разделяемой структуре данных без взаимоисключения.
 взаимоисключение, важное для всех операционных систем, особенно значимо (и запутанно) в случае операционной системы с жестко связанной симметричной мультипроцессорной обработкой (- ), например в , в которой один и тот же системный код, выполняемый на нескольких процессорах одновременно, разделяет некоторые структуры данных, хранящиеся в глобальной памяти. поддержка механизмов, с помощью которых системный код может предотвратить одновременное изменение двумя потоками одной и той же структуры, возлагается на ядро. оно предоставляет специальные примитивы взаимоисключения, используемые им и остальными компонентами исполнительной системы для синхронизации доступа к глобальным структурам данных.
 так как планировщик синхронизирует доступ к своим структурам данных при уровня «/», ядро и исполнительная система не могут полагаться на механизмы синхронизации, которые могли бы привести к ошибке страницы или к перераспределению процессорного времени при уровня «/» или выше (эти уровни также известны под названием «высокий »). из следующих разделов вы узнаете, как ядро и исполнительная система используют взаимоисключение для защиты своих глобальных структур данных при высоком и какие механизмы синхронизации и взаимоисключения они применяют при низких уровнях (ниже «/»).
синхронизация ядра при высоком 
 ядро должно гарантировать, что в каждый момент только один процессор выполняет код в критической секции. критическими секциями ядра являются разделы кода, модифицирующие глобальные структуры данных, например базу данных диспетчера ядра или его очередь операционная система не смогла бы корректно работать, если бы ядро не гарантировало взаимоисключающий доступ потоков к этим структурам данных.
 этом плане больше всего проблем с прерываниями. так, в момент обновления ядром глобальной структуры данных может возникнуть прерывание, процедура обработки которого изменяет ту же структуру. простых однопроцессорных системах развитие событий по такому сценарию исключается путем отключения всех прерываний на время доступа к глобальным данным, однако в ядре реализовано более сложное решение. перед использованием глобального ресурса ядро временно маскирует прерывания, обработчики которых используют тот же ресурс. для этого ядро повышает процессора до самого высокого уровня, используемого любым потенциальным источником прерываний, который имеет доступ к глобальным данным. например, прерывание на уровне «/» приводит к запуску диспетчера ядра, использующего диспетчерскую базу данных. следовательно, любая другая часть ядра, имеющая дело с этой базой данных, повышает до уровня «/», маскируя прерывания того же уровня перед обращением к диспетчерской базе данных.
 эта стратегия хорошо работает в однопроцессорных системах, но не годится для многопроцессорных конфигураций. повышение на одном из процессоров не исключает прерываний на другом процессоре, а ядро должно гарантировать взаимоисключающий доступ на всех процессорах.
взаимоблокирующие операции
 простейшая форма механизмов синхронизации опирается на аппаратную поддержку безопасных операций над целыми значениями и выполнения сравнений в многопроцессорной среде. сюда относятся такие функции, как , , и -. скажем, функция , использует префикс х86-инструкции (например, ) для блокировки многопроцессорной шины на время операции вычитания, чтобы другой процессор, модифицирующий тот же участок памяти, не смог выполнить свою операцию в момент между чтением исходных данных и записью их нового (меньшего) значения. эта форма базовой синхронизации используется ядром и драйверами.
спин-блокировки
 механизм, применяемый ядром для взаимоисключения в многопроцессорных системах, называется спин-блокировкой (). спин-блокировка - это блокирующий примитив, сопоставленный с какой-либо глобальной структурой данных вроде очереди (рис. 3-24).
 перед входом в любую из критических секций, показанных на рис. 3-24, ядро должно установить спин-блокировку, связанную с защищенной очередью если спин-блокировка пока занята, ядро продолжает попытки установить спин-блокировку до тех пор, пока не достигнет успеха. термин получил такое название из-за поведения ядра (и соответственно процессора), которое «крутится» () в цикле, повторяя попытки, пока не захватит блокировку.
 спин-блокировки, как и защищаемые ими структуры данных, находятся в глобальной памяти. код для их установки и снятия написан на языке ассемблера для максимального быстродействия. многих архитектурах спин-блокировка реализуется аппаратно поддерживаемой командой --, которая проверяет значение переменной блокировки и устанавливает блокировку, выполняя всего одну атомарную команду. это предотвращает захват блокировки вторым потоком в промежуток между проверкой переменной и установкой блокировки первым потоком.
 всем спин-блокировкам режима ядра в назначен , всегда соответствующий уровню «/» или выше. поэтому, когда поток пытается установить спин-блокировку, все действия на этом или более низком уровне на данном процессоре прекращаются. поскольку диспетчеризация потоков осуществляется при уровне «/», поток, удерживающий спин-блокировку, никогда не вытесняется, так какданный маскирует механизмы диспетчеризации. такая маскировка не дает прервать выполнение критической секции кода под защитой спин-блокировки и обеспечивает быстрое ее снятие. спин-блокировки используются в ядре с большой осторожностью и устанавливаются на минимально возможное время.
 примечание поскольку - достаточно эффективный механизм синхронизации для однопроцессорных систем, функции установки и снятия спин-блокировки в однопроцессорных версиях на самом деле просто повышают и понижают . 
 ядро предоставляет доступ к спин-блокировкам другим компонентам исполнительной системы через набор функций ядра, включающий - и . например, драйверы устройств требуют спин-блокировки, чтобы система гарантировала единовременный доступ к регистрам устройства и другим глобальным структурам данных со стороны лишь одной части драйвера (и только с одного процессора). спин-блокировка не предназначена для пользовательских программ - они должны оперировать объектами, которые рассматриваются в следующем разделе.
 спин-блокировки ядра накладывают ограничения на использующий их код. как уже отмечалось, их всегда равен «/», поэтому установивший спин-блокировку код может привести к краху системы, если попытается заставить планировщик выполнить операцию диспетчеризации или вызовет ошибку страницы.
спин-блокировки с очередями
 некоторых ситуациях вместо стандартной спин-блокировки применяется особый тип спин-блокировки - с очередью ( ). спин-блокировка с очередью лучше масштабируется в многопроцессорных системах, чем стандартная. как правило, использует лишь стандартные спин-блокировки, когда конкуренция за спин-блокировку ожидается низкой.
 спин-блокировка с очередью работает так: процессор, пытаясь установить такую спин-блокировку, которая в данный момент занята, ставит свой идентификатор в очередь, сопоставленную с этой спин-блокировкой. освободив спин-блокировку, удерживавший ее процессор передает блокировку тому процессору, чей идентификатор стоит в очереди первым. между тем процессор, ожидающий занятую спин-блокировку, проверяет статус не самой спин-блокировки, а флага того процессора, чей идентификатор располагается в очереди прямо перед идентификатором ждущего процессора.
 тот факт, что спин-блокировка с очередью устанавливает флаги, а не глобальные блокировки, имеет два следствия. во-первых, уменьшается интенсивный трафик, связанный с межпроцессорной синхронизацией. во-вторых, вместо случайного выбора процессора из группы ожидающих спин-блокировку реализуется четкий порядок спин-блокировки по типу («первым вошел, первым вышел»). такой порядок позволяет достичь более согласованной работы процессоров, использующих одну и ту же блокировку.
 определяет ряд глобальных спин-блокировок с очередями, сохраняя указатели на них в массиве, который содержится в блоке ( ) каждого процессора. глобальную спин-блокировку можно получить вызовом с индексом в массиве , по которому сохранен указатель на эту спин-блокировку. количество глобальных спин-блокировок растет по мере появления новых версий операционной системы, и таблица их индексов публикуется в заголовочном файле ., поставляемом с .
 эксперимент: просмотр глобальных спин-блокировок с очередями 
 вы можете наблюдать за состоянием глобальных спин-блокировок с очередями, используя команду ! отладчика ядра. эта команда имеет смысл лишь в многопроцессорной системе, так как в однопроцессорной версии спин-блокировки не реализованы. следующем примере (подготовленном в 2000) спин-блокировка с очередью для базы данных диспетчера ядра удерживается процессором номер 1, а остальные спин-блокировки этого типа не затребованы (о базе данных диспетчера ядра см. главу 6).
внутристековые спин-блокировки с очередями
 помимо статических спин-блокировок с очередями, определяемых глобально, ядра и 2003 поддерживают динамически создаваемые спин-блокировки с очередями. для их создания предназначены функции и -. этот тип блокировок используется несколькими компонентами, в том числе диспетчером кэша, диспетчером пулов исполнительной системы ( ) и . упомянутые функции документированы в для сторонних разработчиков драйверов.
 принимает указатель на структуру данных спин-блокировки и описатель очереди спин-блокировки. этот описатель в действительности является структурой данных, в которой ядро хранит информацию о состоянии блокировки, в частности сведения о владельце блокировки и об очереди процессоров, ожидающих освобождения этой блокировки.
взаимоблокирующие операции в исполнительной системе
 ядро предоставляет ряд функций синхронизации, использующих спин-блокировки для более сложных операций, например для добавления и удаления элементов из одно- и двунаправленных связанных списков. таким функциям, в частности, относятся и (для однонаправленных связанных списков), и - (ддя двунаправленных связанных списков). все эти функции требуют передачи стандартной спин-блокировки в качестве параметра и интенсивно используются в ядре и драйверах устройств.
синхронизация при низком 
 компоненты исполнительной системы вне ядра также нуждаются в синхронизации доступа к глобальным структурам данных в многопроцессорной среде. например, у диспетчера памяти есть только одна база данных блоков страниц. обращение к ней осуществляется как к глобальной структуре данных, и драйверам устройств необходима гарантия получения монопольного доступа к своим устройствам. вызывая функции ядра, исполнительная система может создать спин-блокировку, установить ее и снять.
 однако спин-блокировка лишь частично удовлетворяет потребности исполнительной системы в синхронизации. поскольку спин-блокировка означает фактическую остановку процессора, она применяется только при двух условиях:
  требуется непродолжительное обращение к защищенным ресурсам без сложного взаимодействия с другим кодом;
  код критической секции нельзя выгрузить в страничный файл, он не ссылается на данные в подкачиваемой памяти, не вызывает внешние процедуры (включая системные сервисы) и не генерирует прерывания или исключения.
 эти противоречащие друг другу ограничения нельзя соблюсти одновременно ни при каких обстоятельствах. более того, кроме взаимоисключения, исполнительная система должна выполнять и другие алгоритмы синхронизации, а также предоставлять механизмы синхронизации пользовательскому режиму.
 существует несколько дополнительных механизмов синхронизации, применяемых, когда спин-блокировки не годятся:
  объекты диспетчера ядра ( );
  быстрые мьютексы ( ) и защищенные мьютексы ( -);
  блокировки с заталкиванием указателя ( );
  ресурсы исполнительной системы ( ).
 таблице 3-9 кратко сравниваются возможности этих механизмов и их взаимосвязь с доставкой режима ядра.
объекты диспетчера ядра
 ядро предоставляет исполнительной системе дополнительные механизмы синхронизации в форме объектов, в совокупности известных как объекты диспетчера ядра. синхронизирующие объекты, видимые из пользовательского режима, берут свое начало именно от этих объектов диспетчера ядра. каждый синхронизирующий объект, видимый из пользовательского режима, инкапсулирует минимум один объект диспетчера ядра. семантика синхронизации исполнительной системы доступна программистам через -функции и , реализуемые подсистемой на основе аналогичных системных сервисов, предоставляемых диспетчером объектов. поток в -приложении можно синхронизировать по таким -объектам, как процесс, поток, событие, семафор, мьютекс, ожидаемый таймер, порт завершения ввода-вывода или файл.
 еще один тип синхронизирующих объектов исполнительной системы назван (без особой на то причины) ресурсами исполнительной системы ( ). эти ресурсы обеспечивают как монопольный доступ (по аналогии с мьютексами), так и разделяемый доступ для чтения (когда несколько потоков-«читателей» обращается к одной структуре только для чтения). однако они доступны лишь коду режима ядра, а значит, недоступны через . ресурсы исполнительной системы являются не объектами диспетчера ядра, а скорее структурами данных, память для которых выделяется прямо из неподкачиваемого пула, имеющего свои специализированные сервисы для инициализации, блокировки, освобождения, запроса и ожидания. структура ресурсов исполнительной системы определена в ., а соответствующие процедуры описаны в .
 остальных подразделах мы детально обсудим, как реализуется ожидание на объектах диспетчера ядра.
ожидание на объектах диспетчера ядра
 поток синхронизируется с объектом диспетчера ядра, ожидая освобождения его описателя. при этом ядро приостанавливает поток и соответственно меняет состояние диспетчера, как показано на рис. 3-25. ядро удаляет поток из очереди готовых к выполнению потоков и перестает учитывать его в планировании.
 примечание рис. 3-25 показана схема перехода состояний с выделением состояний «готов» (), «ожидает» () и «выполняется» () - они относятся к ожиданию на объектах. прочие состояния описываются в главе 6. 
 любой момент синхронизирующий объект находится в одном из двух состояний: свободном () или занятом (). для синхронизации с объектом поток вызывает один из системных сервисов ожидания, предоставляемых диспетчером объектов, и передает описатель этого объекта. поток может ожидать на одном или нескольких объектах, а также указать, что ожидание следует прекратить, если объект (или объекты) не освободился в течение определенного времени. всякий раз, когда ядро переводит объект в свободное состояние, функция ядра проверяет, ждут ли этот объект какие-нибудь потоки и не ждут ли они каких-либо других объектов. если да, ядро выводит один или более потоков из состояния ожидания, после чего их выполнение может быть продолжено.
 взаимосвязь синхронизации с диспетчеризацией потоков иллюстрирует следующий пример с использованием объекта «событие».
  поток пользовательского режима ждет на описателе объекта «событие» (т. е. ждет перехода этого объекта в свободное состояние).
  ядро изменяет состояние потока с «готов» на «ожидает» и добавляет его в список потоков, ждущих объект «событие».
  другой поток устанавливает объект «событие».
  ядро просматривает список потоков, ожидающих этот объект. если условия ожидания какого-либо потока выполнены (см. примечание ниже), ядро переводит его из состояния «ожидает» в состояние «готов». если это поток с динамическим приоритетом, ядро может повысить его приоритет для выполнения.
  поскольку новый поток теперь готов к выполнению, происходит перераспределение процессорного времени. если при этом диспетчер обнаружит, что приоритет выполняемого потока ниже, чем приоритет потока, только что перешедшего в состояние «готов», он вытеснит поток с более низким приоритетом и выдаст программное прерывание для инициации переключения контекста на поток с более высоким приоритетом.
  если в данный момент вытеснение невозможно ни на одном из процессоров, диспетчер включает поток в свою очередь потоков, готовых к выполнению.
 примечание некоторые потоки могут ждать более одного объекта, и в таком случае их ожидание продолжается. 
условия перехода объектов в свободное состояние
 эти условия различны для разных объектов. например, объект «поток» находится в занятом состоянии в течение всего срока своей жизни и переводится ядром в свободное состояние лишь при завершении. аналогичным образом, ядро переводит объект «процесс» в свободное состояние в момент завершения последнего потока процесса. такой объект, как таймер, переводится в свободное состояние по истечении заданного времени.
 выбирая механизм синхронизации, вы должны учитывать в своей программе поведение синхронизирующих объектов. таблице 3-10 показано, когда переходят в свободное состояние синхронизирующие объекты различных типов.
 когда объект переводится в свободное состояние, ожидающие его потоки обычно немедленно выходят из ждущего состояния. однако, как показано на рис. 3-26, некоторые объекты диспетчера ядра и системные события ведут себя иначе.
 например, объект «событие уведомления» - в он называется событием со сбросом вручную ( ) - используется для уведомления о каком-либо событии. когда этот объект переводится в свободное состояние, все потоки, ожидающие его, освобождаются. исключением является тот поток, который ждет сразу несколько объектов: он может продолжать ожидание, пока не освободятся дополнительные объекты.
 отличие от события мьютекс предусматривает возможность владения. этот объект используется для взаимоисключающего доступа к ресурсу, поэтому единовременно только один поток может владеть мьютексом. при освобождении мьютекса ядро переводит его в свободное состояние и выбирает для выполнения один из ожидающих потоков. выбранный ядром поток захватывает мьютекс, а остальные потоки остаются в ожидании.
события с ключом и критические секции
 синхронизирующий объект, впервые появившийся в и названный событием с ключом ( ), заслуживает особого упоминания. он помогает процессам справляться с нехваткой памяти при использовании критических секций. это недокументированное событие позволяет потоку указать «ключ» в следующей ситуации-, данный поток должен пробуждаться, когда другой поток того же процесса освобождает событие с тем же ключом.
 -процессы часто используют функции критических секций - и - для синхронизации доступа потоков к личным ресурсам процесса. вызовы этих функций эффективнее прямого обращения к объектам «мьютекс», так как в отсутствие конкуренции они не заставляют переходить в режим ядра. при наличии конкуренции динамически создает объект «событие», и поток, которому нужно захватить критическую секцию, ждет, когда поток, владеющий этой секцией, освободит ее вызовом . 
 если создать объект «событие» для критической секции не удалось из-за нехватки системной памяти, использует глобальное событие с ключом - (в каталоге \- пространства имен диспетчера объектов). если ; вынуждена задействовать вместо стандартного события, поток, ждущий критическую секцию, использует адрес этой секции как ключ. это обеспечивает корректную работу функций критических секций даже в условиях временной нехватки памяти.
 мы не ставили себе задачу исчерпывающе описать все объекты исполнительной системы, а лишь хотели дать представление об их базовой функциональности и механизмах синхронизации. об использовании этих объектов в -программах см. справочную документацию или четвертое издание книги джеффри рихтера « для профессионалов».
структуры данных
 учет ожидающих потоков и их объектов ожидания базируется на двух ключевых структурах данных: заголовках диспетчера ( ) и блоках ожидания ( ). обе эти структуры определены в ., заголовочном файле . для удобства мы воспроизводим здесь эти определения.
 заголовок диспетчера содержит тип объекта, информацию о состоянии (занят/свободен) и список потоков, ожидающих этот объект. у каждого ждущего потока есть список блоков ожидания, где перечислены ожидаемые потоком объекты, а у каждого объекта диспетчера ядра - список блоков ожидания, где перечислены ожидающие его потоки. этот список ведется так, что при освобождении объекта диспетчера ядро может быстро определить, кто ожидает данный объект. блоке ожидания имеются указатели на объект ожидания, ожидающий поток и на следующий блок ожидания (если поток ждет более одного объекта). он также регистрирует тип ожидания («любой» или «все») и позицию соответствующего элемента в таблице описателей, переданную потоком в функцию (позиция 0 - если поток ожидает лишь один объект).
 рис. 3-27 показана связь объектов диспетчера ядра с блоками ожидания потоков. данном примере поток 1 ждет объект в, а поток 2 - объекты и в. если объект освободится, поток 2 не сможет возобновить свое выполнение, так как ядро обнаружит, что он ждет и другой объект. другой стороны, при освобождении объекта ядро сразу же подготовит поток 1 к выполнению, поскольку он не ждет никакие другие объекты.
 эксперимент: просмотр очередей ожидания 
 хотя многие утилиты просмотра процессов умеют определять, находится ли поток в состоянии ожидания (отмечая в этом случае и тип ожидания), список объектов, ожидаемых потоком, можно увидеть только с помощью команды ! отладчика ядра. например, следующий фрагмент вывода команды ! показывает, что поток ждет на объекте-событии.
 эти данные позволяют нам убедиться в отсутствии других потоков, ожидающих данный объект, поскольку указатели начала и конца списка ожидания указывают на одно и то же место (на один блок ожидания). копия блока ожидания (по адресу 0812398) дает следующее:
 если в списке ожидания более одного элемента, вы можете выполнить ту же команду со вторым указателем в поле каждого блока ожидания (команду ! применительно к указателю потока в блоке ожидания) для прохода по списку и просмотра других потоков, ждущих данный объект.
быстрые и защищенные мьютексы
 быстрые мьютексы ( ), также известные как мьютексы исполнительной системы, обычно обеспечивают более высокую производительность, чем объекты «мьютекс». почему? дело в том, что быстрые мьютексы, хоть и построены на объектах событий диспетчера, в отсутствие конкуренции не требуют ожидания объекта «событие» (и соответственно спин-блокировок, на которых основан этот объект). эти преимущества особенно ярко проявляются в многопроцессорной среде. быстрые мьютексы широко используются в ядре и драйверах устройств.
 однако быстрые мьютексы годятся, только если можно отключить доставку обычных режима ядра. исполнительной системе определены две функции для захвата быстрых мьютексов: и -. первая функция блокирует доставку всех , повышая процессора до уровня _, а вторая - ожидает вызова при уже отключенной доставке обычных режима ядра (такое отключение возможно повышением до уровня «» или вызовом ). другое ограничение быстрых мьютексов заключается в том, что их нельзя захватывать рекурсивно, как объекты «мьютекс».
 защищенные мьютексы ( ) - новшество 2003; они почти идентичны быстрым мьютексам (хотя внутренне используют другой синхронизирующий объект, ). захватить защищенные мьютексы можно вызовом функции , отключающей доставку всех режима ядра через , а не -, которая на самом деле отключает только обычные режима ядра. защищенные мьютексы недоступны вне ядра и используются в основном диспетчером памяти для защиты глобальных операций вроде создания страничных файлов, удаления определенных типов разделов общей памяти и расширения пула подкачиваемой памяти. (подробнее о диспетчере памяти см. главу 7.)
ресурсы исполнительной системы
 ресурсы исполнительной системы ( ) - это механизм синхронизации, который поддерживает разделяемый (совместный) и монопольный доступ и по аналогии с быстрыми мьютексами требует предварительного отлючения доставки обычных режима ядра. они основаны на объектах диспетчера, которые используются только при наличии конкуренции. ресурсы исполнительной системы широко применяются во всей системе, особенно в драйверах файловой системы.
 потоки, которым нужно захватить какой-либо ресурс для совместного доступа, ждут на семафоре, сопоставленном с этим ресурсом, а потоки, которым требуется захватить ресурс для монопольного доступа, - на событии. семафор с неограниченным счетчиком применяется потому, что в первом случае можно пробудить все ждущие потоки и предоставить им доступ к ресурсу, как только этот семафор перейдет в свободное состояние (ресурс будет освобожден потоком, захватившим его в монопольное владение). когда потоку нужен монопольный доступ к занятому на данный момент ресурсу, он ждет на синхронизирующем объекте «событие», так как при освобождении события пробуждается только один из ожидающих потоков.
 для захвата ресурсов предназначен целый ряд функций: -, , , и . эти функции документированы в .
 эксперимент: перечисление захваченных ресурсов исполнительной системы 
 команда ! отладчика ядра ищет в пуле подкачиваемой памяти объекты ресурсов исполнительной системы и выводит их состояние. по умолчанию эта команда перечисляет только захваченные на данный момент ресурсы, но ключ - позволяет перечислять все ресурсы исполнительной системы. вот фрагмент вывода этой команды:
 заметьте, что счетчик конкурирующих потоков ( ), извлекаемый из структуры ресурса, фиксирует, сколько раз потоки пытались захватить данный ресурс и были вынуждены переходить в состояние ожидания из-за того, что он уже занят.
 для изучения деталей конкретного объекта ресурса (в частности, кто владеет ресурсом и кто ждет его освобождения) укажите ключ - и адрес ресурса:
 ›! - 08054390 
блокировки с заталкиванием указателя
 блокировки с заталкиванием указателя ( ), впервые появившиеся в , являются еще одним оптимизированным механизмом синхронизации, который основан на объекте «событие» (в 2003 такие блокировки базируются на внутреннем синхронизирующем объекте ) и подобно быстрым мьютексам заставляет ждать этот объект только при наличии конкуренции. такие блокировки имеют преимущества над быстрыми мьютексами, так как их можно захватывать как в разделяемом, так и в монопольном режиме. они не документированы и не экспортируются ядром, так как зарезервированы для использования самой операционной системой.
 существует два типа блокировок с заталкиванием указателя: обычный и с поддержкой кэша ( ). первый тип занимает в памяти тот же объем, что и указатель (4 байта в 32-разрядных системах и 8 байтов в 64-разрядных). когда поток захватывает обычную блокировку с заталкиванием указателя, код этой блокировки помечает ее как занятую, если она на данный момент свободна. если блокировка захвачена для монопольного доступа или если потоку нужно захватить ее монопольно, а она уже захвачена для разделяемого доступа, ее код создает в стеке потока блок ожидания, инициализирует объект «событие» в этом блоке и добавляет последний в список ожидания, сопоставленный с блокировкой. как только блокировка освобождается, ее код пробуждает ждущий поток (если таковой имеется), освобождая событие в блоке ожидания потока.
 второй тип создает обычную блокировку с заталкиванием указателя для каждого процессора в системе и сопоставляет ее с блокировкой с заталкиванием указателя, поддерживающей кэш. когда потоку нужно захватить такую блокировку, он просто захватывает обычную блокировку, созданную для текущего процессора в соответствующем режиме доступа.
 подобные блокировки используются, в том числе, диспетчером объектов, когда возникает необходимость в защите глобальных структур данных и дескрипторов защиты объектов, а также диспетчером памяти для защиты структур данных .
обнаружение взаимоблокировки с помощью 
 взаимоблокировка () - это проблема синхронизации, возникающая, когда два потока или процессора удерживают ресурсы, нужные другому, и ни один из них не отдает их. такая ситуация может приводить к зависанию системы или процесса. утилита , описываемая в главах 7 и 9, позволяет проверять возможность взаимоблокировки, в том числе на спин-блокировках, быстрых и обычных мьютексах. том, как пользоваться для анализа зависания системы, см. главу 14.
системные рабочие потоки
 при инициализации создает несколько потоков в процессе , которые называются системными рабочими потоками ( ). они предназначены исключительно для выполнения работы по поручению других потоков. многих случаях потоки, выполняемые на уровне «/», нуждаются в вызове таких функций, которые могут быть вызваны только при более низком . например, -процедуре, выполняемой в контексте произвольного потока при уровня «/» ( может узурпировать любой поток в системе), нужно обратиться к пулу подкачиваемой памяти или ждать на объекте диспетчера для синхронизации с потоком какого-либо приложения. поскольку -процедура не может понизить , она должна передать свою задачу потоку, который сможет выполнить ее при ниже уровня «/».
 некоторые драйверы устройств и компоненты исполнительной системы создают собственные потоки для обработки данных на уровне «», но большинство вместо этого использует системные рабочие потоки, что помогает избежать слишком частого переключения потоков и чрезмерной нагрузки на память из-за диспетчеризации дополнительных потоков. драйвер устройства или компонент исполнительной системы запрашивает сервисы системных рабочих потоков через функцию исполнительной системы или . эти функции помещают рабочий элемент ( ) в специальную очередь, проверяемую системными рабочими потоками (см. раздел «порты завершения ввода-вывода» главы 9).
 рабочий элемент включает указатель на процедуру и параметр, передаваемый потоком этой процедуре при обработке рабочего элемента. процедура реализуется драйвером устройства или компонентом исполнительной системы, выполняемым на уровне «».
 например, -процедура, которая должна ждать на объекте диспетчера, может инициализировать рабочий элемент, который указывает на процедуру в драйвере, ждущем на объекте диспетчера, и, возможно, на указатель на объект. каком-то этапе системный рабочий поток извлекает из своей очереди рабочий элемент и выполняет процедуру драйвера. после ее выполнения системный рабочий поток проверяет, нет ли еще рабочих элементов, подлежащих обработке. если нет, системный рабочий поток блокируется, пока в очередь не будет помещен новый рабочий элемент. выполнение -процедуры может и не закончиться в ходе обработки ее рабочего элемента системным рабочим потоком. ( однопроцессорной системе выполнение этой процедуры всегда завершается до обработки ее рабочего элемента, так как на уровне «/» потоки не планируются.)
 существует три типа системных рабочих потоков:
  отложенные ( ) - выполняются с приоритетом 12, обрабатывают некритичные по времени рабочие элементы и допускают выгрузку своего стека в страничный файл на время ожидания рабочих элементов;
  критичные ( ) - выполняются с приоритетом 13, обрабатывают критичные по времени рабочие элементы. их стек всегда находится только в физической памяти;
  гиперкритичный ( ) - единственный поток, выполняемый с приоритетом 15. его стек тоже всегда находится в памяти. диспетчер процессов использует гиперкритичные по времени рабочие элементы для выполнения функции, освобождающей завершенные потоки.
 число отложенных и критичных системных рабочих потоков, создаваемых функцией исполнительной системы , которая вызывается на ранних стадиях процесса загрузки, зависит от объема памяти в системе и от того, является ли система сервером. таблице 3-11 показано количество потоков, изначально создаваемых в системах с различной конфигурацией. вы можете указать создать дополнительно до 16 отложенных и 16 критичных системных рабочих потоков. для этого используйте параметры и - в разделе реестра \\\-\ \.
 исполнительная система старается балансировать число критичных системных рабочих потоков в соответствии с текущей рабочей нагрузкой. каждую секунду функция исполнительной системы проверяет, надо ли создавать новый критичный рабочий поток. кстати, критичный рабочий поток, создаваемый функцией -, называется динамическим ( ). для создания такого потока должны быть выполнены следующие условия.
  очередь критичных рабочих элементов не должна быть пустой.
  число неактивных критичных потоков (блокированных в ожидании рабочих элементов или на объектах диспетчера при выполнении рабочей процедуры) должно быть меньше количества процессоров в системе.
  системе должно быть менее 16 динамических рабочих потоков.
 динамические потоки завершаются через 10 минут пребывания в неактивном состоянии. зависимости от рабочей нагрузки исполнительная система может создавать до 16 таких потоков.
глобальные флаги 
 поддерживает набор флагов, который хранится в общесистемной глобальной переменной , предназначенной для отладки, трассировки и контроля операционной системы. при загрузке системы переменная инициализируется значением параметра из раздела реестра \\\\ . по умолчанию его значение равно 0, и в системах с обычной конфигурацией глобальные флаги обычно не используются. кроме того, каждый образ исполняемого файла имеет набор глобальных флагов, позволяющих включать код внутренней трассировки и контроля (хотя битовая структура этих флагов совершенно не соответствует структуре общесистемных глобальных флагов). эти флаги не документированы, но могут пригодиться при изучении внутреннего устройства .
 счастью, в и средствах отладки есть утилита ., позволяющая просматривать и изменять системные глобальные флаги (либо в реестре, либо в работающей системе) и глобальные флаги образов исполняемых файлов. поддерживает как -интерфейс, так и командную строку. параметры командной строки можно узнать, введя /?. при запуске утилиты без параметров выводится диалоговое окно, показанное на рис. 3-28.
 вы можете переключаться между реестром ( ) и текущим значением переменной в системной памяти ( ). для внесения изменений нужно щелкнуть кнопку арру (кнопка просто закрывает программу). хотя вы можете изменять флаги в работающей системе, большинство из них требует перезагрузки для того, чтобы изменения вступили в силу.
 поскольку документации на этот счет нет, лучше перезагрузиться после любых изменений.
 выбрав , вы должны ввести имя исполняемого в системе файла. этот переключатель позволяет изменять набор глобальных флагов отдельного образа (а не всей системы). заметьте, что флаги на рис. 3-29 отличаются от флагов на рис. 3-28.
 рис. 3-29. настройка в глобальных флагов образа исполняемого файла 
 эксперимент: включение трассировки загрузчика образов и просмотр 
 чтобы увидеть пример детальной трассировочной информации, которую можно получить при установке глобальных флагов, попробуйте запустить в системе с загруженным отладчиком ядра, которая подключена к компьютеру с запущенной утилитой или .
 далее попробуйте установить, например, глобальный флаг . для этого выберите , установите флажок и щелкните кнопку . теперь запустите на этой машине какую-нибудь программу, и отладчик ядра будет выдавать информацию, аналогичную показанной ниже.
 для просмотра состояния переменной можно использовать команды / и / отладчика ядра. первая выводит список всех флагов, указывая, какие из них установлены, / показывает только установленные флаги.
 
 ( ) - это механизм межпроцессной связи для высокоскоростной передачи сообщений. он недоступен через напрямую и является внутренним механизмом, которым пользуются только компоненты операционной системы . вот несколько примеров того, где применяется 
  -приложения, использующие (документированный ), неявно используют и , когда указывают локальный - разновидность , применяемую для взаимодействия между процессами в рамках одной системы.
  некоторые функции обращаются к , посылая сообщения процессу подсистемы .
  взаимодействует с процессом через 
  монитор состояния защиты (компонент исполнительной системы, рассматриваемый в главе 8) также взаимодействует с процессом через 
 эксперимент: просмотр объектов «порт » 
 вы можете увидеть именованные объекты «порт » ( ) с помощью утилиты . запустите . и выберите корневой каталог. интересующие нас объекты обозначаются значком в виде разъема, как показано ниже.
 для просмотра объектов «порт », используемых , выберите каталог \ , как на следующей иллюстрации.
 вы также можете наблюдать объекты «порт » с помощью команды ! отладчика ядра. параметры этой команды позволяют перечислять порты , сообщения и потоки, ожидающие или посылающие эти сообщения. для просмотра порта аутентификации (в него посылает запросы на вход в систему) сначала нужно получить список портов в данной системе.
 как правило, используются для взаимодействия между серверным процессом и одним или несколькими клиентскими процессами. -соеди-нение может быть установлено между двумя процессами пользовательского режима или между компонентом режима ядра и процессом пользовательского режима. например, как говорилось в главе 2, -процессы иногда посылают сообщения подсистеме через некоторые системные процессы вроде и тоже используют примерами компонентов режима ядра, взаимодействующих с пользовательскими процессами через , могут служить монитор состояния защиты и . предусматривает три способа обмена сообщениями.
  сообщение длиной менее 256 байтов можно передать вызовом с буфером, содержащим сообщение. затем это сообщение копируется из адресного пространства процесса-отправителя в системное адресное пространство, а оттуда - в адресное пространство процесса-получателя.
  если клиент и сервер хотят обменяться данными, размер которых превышает 256 байтов, они могут использовать общий раздел, на который они оба спроецированы. отправитель помещает данные в общий раздел и посылает получателю уведомление с указателем на область раздела, где находятся данные.
  если серверу нужно считать или записать данные, объем которых превышает размер общего раздела, то их можно напрямую считать из клиентского адресного пространства или записать туда. для этого предоставляет серверу две функции. сообщение, посланное первой функцией, обеспечивает синхронизацию передачи последующих сообщений. экспортирует единственный объект исполнительной системы объект «порт» ( ). однако порты бывают нескольких видов.
  порт серверного соединения ( ) именованный порт, служащий точкой запроса связи с сервером. через него клиенты могут соединяться с сервером.
  коммуникационный порт сервера ( ) безымянный порт, используемый сервером для связи с конкретным клиентом. у сервера имеется по одному такому порту на каждый активный клиент.
  коммуникационный порт клиента ( ) безымянный порт, используемый конкретным клиентским потоком для связи с конкретным сервером.
  безымянный коммуникационный порт ( ) порт, создаваемый для связи между двумя потоками одного процесса.
 обычно используется так. сервер создает именованный порт соединения. клиент посылает в него запрос на установление связи. если запрос удовлетворен, создается два безымянных порта - коммуникационный порт клиента и коммуникационный порт сервера. клиент получает описатель коммуникационного порта клиента, а сервер - описатель коммуникационного порта сервера. после этого клиент и сервер используют новые порты для обмена данными.
 схема соединения между клиентом и сервером показана на рис. 3-30.
трассировка событий ядра
 различные компоненты ядра и несколько базовых драйверов устройств оснащены средствами мониторинга для записи трассировочных данных об их работе, используемых при анализе проблем в системе. эти компоненты опираются на общую инфраструктуру в ядре, которая предоставляет трассировочные данные механизму пользовательского режима - (). приложение, использующее , попадает в одну или более следующих категорий.
  контроллер () начинает и прекращает сеансы протоколирования ( ), а также управляет буферными пулами.
  провайдер () определяет ( ) для классов событий, для которых он может создавать трассировочные данные, и регистрирует их в . провайдер принимает команды от контроллера на запуск и остановку трассировки классов событий, за которые он отвечает.
  потребитель () выбирает один или более сеансов трассировки, для которых ему нужно считывать трассировочные данные. принимает информацию о событиях в буферы в режиме реального времени или в файлы журнала.
 системы встроено несколько провайдеров пользовательского режима, в том числе для , и . определяет сеанс протоколирования с именем [также известный как регистратор ядра ( )] для использования ядром и базовыми драйверами. провайдер для реализуется драйвером устройства () (драйвер называется ), который является частью .. (подробнее о  см. соответствующий раздел в главе 5.) этот драйвер не только служит основой регистратора ядра, но и управляет регистрацией классов событий пользовательского режима.
 драйвер экспортирует интерфейсы управления вводом-выводом для применения в -процедурах пользовательского режима и драйверах устройств, предоставляющих трассировочные данные для регистратора ядра. ( командах управления вводом-выводом см. главу 9.) он также реализует функции для использования компонентами в . режима ядра, которые формируют трассировочный вывод.
 когда в пользовательском режиме включается контроллер, регистратор ядра (библиотека , реализованная в \\32\.) посылает запрос управления вводом-выводом (/ ) дйв , сообщая ему, для каких классов событий контроллер хочет начать трассировку. если настроено протоколирование в файлы журналов (в противоположность протоколированию в буфер памяти), драйвер создает специальный системный поток в системном процессе, а тот создает файл журнала. принимая события трассировки от активизированных источников трассировочных данных, драйвер записывает их в буфер. поток записи в журнал пробуждается раз в секунду, чтобы сбросить содержимое буферов в файл журнала.
 записи трассировки, генерируемые для регистратора ядра, имеют стандартный -заголовок события трассировки, в котором содержатся временная метка, идентификаторы процесса и потока, а также сведения о том, какому классу события соответствует данная запись. классы событий могут предоставлять дополнительные данные, специфичные для их событий. например, класс дисковых событий ( ) указывает тип операции (чтение или запись), номер диска, на котором выполняется операция, а также смещение начального сектора и количество секторов, затрагиваемых данной операцией.
 классы трассировки, которые можно включить для регистратора ядра, и компонент, генерирующий каждый класс, перечислены ниже.
  дисковый ввод-вывод драйвер класса дисков.
  файловый ввод-вывод драйверы файловой системы.
  конфигурирование оборудования диспетчер (см. главу 9).
  загрузка/выгрузка образов системный загрузчик образов в ядре.
  ошибки страниц диспетчер памяти (см. главу 7).
  создание/удаление процессов диспетчер процессов (см. главу 6).
  создание/удаление потоков диспетчер процессов.
  операции с реестром диспетчер конфигурации (см. раздел «реестр» в главе 4).
  активностьтср/ драйвертср/р.
 более подробные сведения о и регистраторе ядра, в том числе примеры кода для контроллеров и потребителей, см. в .
 эксперимент: трассировка активности / с помощью регистратора ядра 
 чтобы включить регистратор ядра и получить от него файл журнала активности /, действуйте следующим образом.
 1. запустите оснастку (производительность) и выберите узел (журналы и оповещения производительности).
 2. укажите (журналы трассировки) и выберите из меню (действие) команду (новые параметры журнала).
 3.  появившемся окне присвойте имя новым параметрам (например, ).
 4.  следующем диалоговом окне выберите (события, протоколируемые системным поставщиком) и сбросьте все, кроме / (события сети /).
 5.  поле ввода (от имени) введите имя учетной записи администратора и ее пароль.
 6. закройте это диалоговое окно и создайте активность в сети, открыв браузер и зайдя на какой-нибудь -сайт.
 7. укажите журнал трассировки, созданный в узле таких журналов, и выберите (остановка) из меню (действие).
 8. откройте окно командной строки и перейдите в каталог : \ (или тот каталог, который вы указали как место хранения файла журнала).
 9. если вы используете или 2003, запустите (эта утилита находится в каталоге \\-32) и передайте ей имя файла журнала трассировки. если вы работаете в 2000, скачайте и запустите из ресурсов 2000. обе утилиты генерируют два файла: . и ..
 10. откройте . в или в любом текстовом редакторе. вы должны увидеть записи трассировки и/или :
64
 64 (эмуляция 32 в 64-разрядной ) относится к программному обеспечению, которое дает возможность выполнять 32-разрядные х8б-приложения в 64-разрядной . этот компонент реализован как набор пользовательского режима.
  64. - управляет созданием процессов и потоков, подключается к диспетчеризации исключений и перехватывает вызовы базовых системных функций, экспортируемых .. также реализует перенаправление файловой системы ( ) и перенаправление реестра и отражение ().
  64. - управляет 32-разрядным контекстом процессора каждого потока, выполняемого внутри 64, и предоставляет специфичную для процессорной архитектуры поддержку переключения режима процессора из 32-разрядного в 64-разрядный и наоборот.
  64. - перехватывает вызовы системных -функций, экспортируемых 32..
 взаимосвязь этих показана на рис. 3-31.
системные вызовы
 64 ставит ловушки на всех путях выполнения, где 32-разрядный код должен взаимодействовать с родным 64-разрядным или где 64-разрядной системе нужно обращаться к 32-разрядному коду пользовательского режима. при создании процесса диспетчер процессов проецирует на его адресное пространство 64-разрядную библиотеку .. загрузчик 64-разрядной системы проверяет заголовок образа и, если этот процесс 32-разрядный для платформы 86, загружает 64.. после этого 64 проецирует 32-разрядную . (она хранится в каталоге \\64). далее 64 настраивает стартовый контекст внутри , переключает процессор в 32-разрядный режим и начинает выполнять 32-разрядный загрузчик. этого момента все идет так же, как в обычной 32-разрядной системе.
 специальные 32-разрядные версии ., 32. и 32. находятся в каталоге \\64. они вызывают 64, не выдавая инструкции вызова, которые используются в истинно 32-разрядной системе. 64 переключается в «родной» 64-разрядный режим, захватывает параметры, связанные с системным вызовом, преобразует 32-разрядныеуказате-ли в 64-разрядные и выдает соответствующий для 64-разрядной системы системный вызов. когда последняя возвращает управление, 64 при необходимости преобразует любые выходные параметры из 64-битных в 32-битные форматы и вновь переключается в 32-разрядный режим.
диспетчеризация исключений
 64 перехватывает диспетчеризацию исключений через - в . всякий раз, когда 64-разрядное ядро собирается направить исключение 64-це, 64 перехватывает его и запись контекста ( ) в пользовательском режиме, а затем, создав на их основе 32-разрядные исключение и запись контекста, направляет их своему процессу так же, как это сделало бы истинно 32-разрядное ядро.
пользовательские обратные вызовы
 64 перехватывает все обратные вызовы из режима ядра в пользовательский режим. 64 интерпретирует их как системные вызовы; однако трансляция данных происходит в обратном порядке: входные параметры преобразуются из 64-битных форматов в 32-битные, а выходные (после возврата из обратного вызова) - из 32-битных в 64-битные.
перенаправление файловой системы
 чтобы обеспечить совместимость приложений и упростить перенос 32-программ на платформу 64-разрядной , имена системных каталогов сохранены прежними. поэтому в \\32 содержатся «родные» 64-разрядные исполняемые файлы. так как 64 ставит ловушки на все системные вызовы, этот компонент транслирует все -вызовы, относящиеся к путям, и заменяет в них каталог \\32 на \-\64. 64 также перенаправляет \\32 \ в \\32\ (86), чтобы обеспечить совместимость 32-разрядных приложений в 64-разрядных системах с установленной поддержкой дальневосточных языков. кроме того, 32-разрядные программы устанавливаются в каталог \ (86), тогда как 64-разрядные - в обычный каталог \ .
 каталоге \\32 есть несколько подкаталогов, которые по соображениям совместимости исключаются из перенаправления. так что, если 32-разрядным приложениям понадобится доступ к этим каталогам, они смогут обращаться к ним напрямую. число таких каталогов входят:
  %%\32\\;
  %%\32\;
  %%\32\2;
  %%\32\.
 наконец, 64 предоставляет механизм, позволяющий отключать перенаправление файловой системы, встроенное в 64, для каждого потока индивидуально. данный механизм доступен через функцию 64-64, которая впервые появилась в 2003.
перенаправление реестра и отражение
 приложения и компоненты хранят свои конфигурационные данные в реестре. эту информацию компоненты обычно записывают в реестр при регистрации в ходе установки. если один и тот же компонент поочередно устанавливается и регистрируется как 32- и 64-разрядный, тогда компонент, зарегистрированный последним, переопределяет регистрацию предыдущего, поскольку оба они пишут по одному адресу в реестре.
 чтобы решить эту проблему, не модифицируя 32-разрядные компоненты, реестр делится на две части: и 64. по умолчанию 32-разрядные компоненты получают доступ к 32-разрядному представлению реестра, а 64-разрядные - к 64-разрядному представлению. это создает безопасную среду исполнения для 32- и 64-разрядных компонентов и отделяет состояние 32-разрядных приложений от состояния 64-разрядных (если таковые есть).
 реализуя это решение, 64 перехватывает все системные вызовы, открывающие разделы реестра, и модифицирует пути к разделам так, чтобы они указывали на контролируемое 64 представление реестра. 64 разбивает реестр в следующих точках:
  \;
  __;
  __\\.
 каждом из этих разделов 64 создает раздел с именем 6432-. нем сохраняется конфигурационная информация 32-разрядного программного обеспечения. остальные части реестра 32- и 64-разрядные приложения используют совместно (например, \).
 при вызове функций и приложения могут передавать следующие флаги:
  _64_64 - для явного открытия 64-разрядного раздела из 32-или 64-разрядного приложения;
  _64_32 - для явного открытия 32-разрядного раздела из 32-или 64-разрядного приложения.
 для обеспечения взаимодействия через 32- и 64-разрядные сом-компо-ненты 64 отражает изменения в некоторых частях одного представления реестра на другое. для этого 64 перехватывает операции обновления любого из отслеживаемых разделов в одном из представлений и отражает соответствующие изменения на другое представление. вот список отслеживаемых разделов:
  \\;
  \\;  \\;
  \\3;
  \\.
 64 использует интеллектуальный подход к отражению \-\\: транслируются только -идентификаторы -32, так как они могут быть сом-активированы 32- или 64-разрядными приложениями, а -идентификаторы 32 не отражаются, поскольку 32-разрядные нельзя загрузить в 64-разрядный процесс, равно как и 64-разрядные в 32-разрядный процесс.
 при отражении раздела или параметра механизм отражения реестра ( ) помечает раздел так, чтобы было понятно, что он создан именно этим механизмом. это позволяет ему выбирать дальнейший алгоритм действий при удалении отражаемого раздела.
запросы управления вводом-выводом
 приложения могут не только выполнять обычные операции чтения и записи, но и взаимодействовать с некоторыми драйверами устройств через интерфейс управления вводом-выводом на устройствах, используя -функцию . при ее вызове можно указать входной и/или выходной буфер. если он содержит данные, зависимые от указателя, и процесс, посылающий запрос, является 64-пцм, тогда у 32-разрядного приложения и 64-разрядного драйвера разные представления входной и/ или выходной структуры, так как 32-разрядные программы используют указатели длиной 4 байта, а 64-разрядные - длиной 8 байтов. этом случае предполагается, что драйвер режима ядра сам преобразует соответствующие структуры, зависимые от указателей. чтобы определить, исходит ли запрос от 64-,, драйверы могут вызывать функцию 32. 
16-разрядные программы установки
 64 не поддерживает выполнение 16-разрядных приложений. поскольку многие программы установки являются 16-разрядными, в 64 предусмотрен специальный код, все же позволяющий выполнять 16-разрядные программы установки общеизвестных приложений.
 таким средствам установки, в частности, относятся:
  версий 2.6, 3.0, 3.01 и 3.1;
  версий 5.
 всякий раз, когда с помощью -функции предпринимается попытка создать 16-разрядный процесс, система загружает 64. и передает ей управление, чтобы та определила, относится ли данный 16-разрядный исполняемый файл к одной из поддерживаемых программ установки. если да, то выдается другой вызов , чтобы запустить 32-разрядную версию этого установщика с теми же аргументами командной строки.
печать
 использовать 32-разрядные драйверы принтера в 64-разрядной нельзя. они должны быть 64-разрядными версиями, «родными» для данной системы. однако, поскольку драйверы принтера работают в пользовательском адресном пространстве запрашивающего процесса, а 64-разрядная поддерживает лишь истинно 64-разрядные драйверы принтера, нужен специальный механизм для поддержки печати из 32-разрядных процессов. для этого все вызовы функций печати перенаправляются в 64. - -сервер печати 64. так как 64 является 64-разрядным процессом, он может загрузить 64-разрядные драйверы принтера.
ограничения
 64 (в отличие от 32-разрядных версий ) не поддерживает выполнение 16-разрядных приложений или загрузку 32-разрядныхдрайверов устройств режима ядра (их нужно перевести в истинно 64-разрядные). 64-цессы могут загружать лишь 32-разрядные (загрузка истинно 64-разрядных невозможна). аналогичным образом 64-разрядные процессы не могут загружать 32-разрядные .
 дополнение к сказанному 64 в системах 64 из-за различий в размерах страниц памяти не поддерживает функции , -, или (). кроме того, 64-процессам недоступно аппаратное ускорение операций через (таким процессам предоставляется лишь программная эмуляция).
резюме
 этой главе мы изучили важнейшие базовые механизмы, на которых построена исполнительная система . следующей главе будут рассмотрены три важных механизма, образующих инфраструктуру управления в : реестр, сервисы и ( ).
 гл 4  механизмы управления
 этой главе описываются три фундаментальных механизма , критически важных для управления системой и ее конфигурирования:
  реестр;
  сервисы;
  (инструментарий управления ).
реестр
 реестр играет ключевую роль в конфигурировании и управлении . это хранилище общесистемных и пользовательских параметров. реестр не является статичной совокупностью хранящихся на жестком диске данных, как думают многие. прочитав этот раздел, вы увидите, что он представляет собой окно в мир различных структур, которые хранятся в памяти компьютера и поддерживаются ядром и исполнительной системой. данный раздел не претендует на роль полного справочника по реестру . исчерпывающая информация такого рода для 2000 находится в справочном файле « 2000 » (.), который поставляется с ресурсами 2000, а для и 2003 эта информация доступна через интернет по ссылке :// ../2003/// 
 мы начнем с обзора структуры реестра, рассмотрим поддерживаемые им типы данных и ключевую информацию, хранящуюся в реестре . потом заглянем поглубже внутрь и обсудим механизмы, используемые диспетчером конфигурации - компонентом исполнительной системы, который отвечает за реализацию базы данных реестра. среди прочего мы коснемся внутренней структуры реестра на диске, способов выборки конфигурационной информации по запросу приложений и мер защиты этой важнейшей системной базы данных.
просмотр и изменение реестра
 как правило, следует избегать прямого редактирования реестра - приложения и система, хранящие в реестре параметры, которые могут потребовать настройки вручную, должны предоставлять соответствующий пользовательский интерфейс () для их модификации. однако, как вы уже неоднократно видели в этой книге, для изменения некоторых дополнительных и отладочных параметров никакого не предусмотрено. поэтому в включен ряд утилит, позволяющих просматривать и модифицировать реестр.
 2000 поставляется с двумя утилитами для редактирования реестра - . и 32., - тогда как в и 2003 имеется лишь .. причина в том, что версия в 2000 была перенесена из 98 и поэтому не поддерживала редактирование или просмотр параметров защиты и типов данных, не определенных в 98. поэтому в 2000 была добавлена 32, которая не обладала развитыми средствами поиска и поддержки импорта/экс-порта, но поддерживала параметры защиты и специфичные для 2000 типы данных. , поставляемая с и 2003, распознает все типы данных в реестре и позволяет редактировать параметры защиты, ввиду чего необходимость в 32 отпала.
 существует также целый ряд утилит для работы с реестром из командной строки. например, ., включенная в и 2003 и доступная в 2000 , дает возможность импортировать, экспортировать, создавать резервные копии и восстанавливать разделы реестра, а также сравнивать, модифицировать и удалять разделы и параметры.
использование реестра
 конфигурационные данные всегда считываются в следующих случаях.
  ходе загрузки система читает параметры, указывающие, какие драйверы устройств нужно загрузить, а различные подсистемы (вроде диспетчера памяти и диспетчера процессов) - параметры, позволяющие им настраивать себя и поведение системы.
  при входе и другие -компоненты считывают из реестра предпочтения данного пользователя, в том числе буквы подключенных сетевых дисков, размещение ярлыков, а также настройки рабочего стола, меню и др.
  при запуске приложения считывают общесистемные параметры, например список дополнительных установленных компонентов, информацию о лицензировании, настройки для данного пользователя (меню, размещение панелей инструментов, список недавно открывавшихся документов и т. д.). однако чтение реестра возможно и в другие моменты, скажем, в ответ на модификацию его параметра или раздела. некоторые приложения ведут мониторинг своих конфигурационных параметров в реестре и считывают обновленные значения, как только обнаруживают изменения. в целом, если система простаивает, работы с реестром не должно быть. реестр обычно модифицируется в следующих ситуациях.
  исходная структура реестра и многие настройки по умолчанию определяются его прототипной версией, поставляемой на дистрибутиве и копируемой при установке новой системы.
  программы установки различных приложений создают для них настройки по умолчанию и настройки, отражающие выбор пользователя в процессе установки.
  при установке драйвера устройства подсистема создает разделы и параметры в реестре, которые сообщают диспетчеру ввода-вывода, как запускать драйвер, а также создает другие параметры, определяющие работу этого драйвера. (подробнее об установке драйверов устройств см. главу 9.)
  когда вы изменяете параметры приложения или системы через , эти изменения часто сохраняются в реестре.
 примечание как ни печально, но некоторые приложения периодически опрашивают реестр на предмет изменений, тогда как делать это следует через функцию , которая отправляет поток в сон до тех пор, пока в интересующей его части реестра не произойдет какое-нибудь изменение. 
типы данных в реестре
 реестр - это база данных, структура которой аналогична структуре логического тома. он содержит разделы (), напоминающие дисковые каталоги, и параметры (), которые можно сравнить с файлами на диске. раздел представляет собой контейнер, содержащий другие разделы, называемые подразделами (), и/или параметры. параметры хранят собственно данные. разделы верхнего уровня называются корневыми. здесь мы будем использовать термины «подраздел» и «раздел» как синонимы (лишь корневые разделы не могут быть подразделами).
 соглашение об именовании разделов и параметров заимствовано из файловой системы. таким образом, параметру можно присвоить имя, которое сохраняется в каком-либо разделе. исключением из этой схемы является безымянный параметр, присутствующий в каждом разделе. утилиты реестра, и 32, по-разному показывают этот параметр: обозначает его как () [(по умолчанию)], 32 - как ‹ › (‹без имени›).
 параметрах хранятся данные 15 типов, перечисленных в таблице 4-1. большинство параметров реестра имеет тип _, или _. параметры типа _ содержат числовые или булевы значения, параметры типа - данные, требующие более 32 битов, или произвольные двоичные данные (например зашифрованные пароли), а параметры типа - строки (естественно, в -формате), которые могут представлять такие элементы, как имена, пути, типы и имена файлов.
 особенно интересен тип _, поскольку он позволяет разделу ссылаться на другой раздел или параметр. например, если параметр \\ содержит значение \2\ типа _, а параметр - , то значение можно идентифицировать двумя путями: \\\ и \2\\. как поясняется в следующем разделе, интенсивно использует ссылки в реестре: три из шести корневых разделов реестра представляют собой ссылки на подразделы трех корневых разделов, которые ссылками не являются. ссылки не записываются на диск, а создаются динамически при каждой загрузке системы.
логическая структура реестра
 вы можете проследить схему организации реестра через данные, которые в нем хранятся. существует шесть корневых разделов (добавлять или удалять корневые разделы нельзя), описанных в таблице 4-2.
 почему имена корневых разделов начинаются с буквы «»? дело в том, что имена корневых разделов представляют -описатели () разделов (). как говорилось в главе 1, является аббревиатурой __. таблице 4-3 приводится список всех корневых разделов и их аббревиатур. содержимое и предназначение каждого из них подробно обсуждаются в следующих разделах главы.
__
 корневой раздел содержит данные о предпочтениях и конфигурации программного обеспечения для локально зарегистрированного пользователя. этот раздел ссылается на профиль текущего пользователя, находящийся на жестком диске в файле \ \‹имя_полъзователя›\ . (описание файлов реестра см. в разделе «внутренние механизмы реестра» далее в этой главе). при каждой загрузке профиля пользователя (например, при регистрации в системе или при выполнении сервисного процесса в увязке с именем какого-либо пользователя) создается как ссылка на подраздел соответствующего пользователя в _. некоторые подразделы перечислены в таблице 4-4.
_
 содержит подраздел для каждого загруженного профиля пользователя, регистрационную базу данных классов и подраздел \., связанный с профилем для системы (этот профиль предназначен для процессов, выполняемых под локальной системной учетной записью; см. раздел «сервисы» далее в этой главе). данный профиль используется , например, чтобы изменения в параметрах фона рабочего стола были реализованы на экране входа. если пользователь входит в систему в первый раз и если его учетная запись не зависит от доменного профиля роуминга (т. е. профиль пользователя извлекается из централизованного хранилища в сети по указанию контроллера домена), система создает профиль для его учетной записи на основе профиля, хранящегося в каталоге : \ -\ .
 каталог, где система хранит профили, определяется параметром реестра \\\ \\\-, который по умолчанию устанавливается в %%\ . раздел также хранит список профилей, имеющихся в системе. информация по каждому профилю помещается в подраздел, имя которого отражает учетной записи, соответствующей данному профилю (сведения о см. в главе 8). информация в разделе профиля включает время последней загрузки этого профиля (параметры и ), двоичное представление учетной записи (параметр ) и путь к кусту профиля на диске в каталоге (о кустах см. раздел «кусты» далее в этой главе). и 2003 показывают список профилей в диалоговом окне управления профилями пользователей, которое представлено на рис. 4-1. чтобы открыть это окно, запустите апплет (система) из (панель управления), перейдите на вкладку (дополнительно) и в разделе (профили пользователей) щелкните кнопку (параметры).
 рис. 4-1. диалоговое окно (профили пользователей) 
 эксперимент: наблюдение за загрузкой и выгрузкой профилей 
 чтобы увидеть, как профиль загружается в реестр, а потом выгружается, запустите командой какой-нибудь процесс под учетной записью пользователя, не вошедшего на данный момент в систему. пока новый процесс выполняется, запустите и обратите внимание на загруженный раздел профиля в _. после завершения процесса нажмите в клавишу 5 для обновления, и этого профиля в реестре больше не будет.
__
 включает информацию двух типов: сопоставления расширений файлов и регистрационные данные сом-классов. для каждого зарегистрированного типа файлов существует свой раздел. большинство разделов содержит параметры типа _2, ссылающиеся на другие разделы , где находится информация о сопоставлениях классов файлов. например, \. ссылается на сведения о файлах в разделе \..8 (последняя цифра указывает на версию ). другие разделы содержат детальную информацию о конфигурации сом-объектов, зарегистрированных в системе.
 раздел формируется на основе:
  специфичных для конкретного пользователя регистрационных данных классов в \\ (хранятся в \ \ ‹имя_полъзователя›\1.оса\ \ \\\ .);
  общесистемных регистрационных данных классов в \\ .
 причина, по которой регистрационные данные, специфичные для каждого пользователя, были отделены от общесистемных, заключается в том, что это дает возможность включать соответствующие настройки и в профили «блуждающих» пользователей (профили роуминга). это же устранило дыру в защите: непривилегированный пользователь не может изменить или удалить разделы в и тем самым повлиять на функционирование приложений в системе. непривилегированные пользователи и приложения могут считывать общесистемные данные и добавлять новые разделы и параметры в общесистемные данные (которые отражаются на данные, специфичные для этих пользователей), но изменять существующие разделы и параметры им разрешается лишь в собственных данных.
__
 - корневой раздел, содержащий подразделы с общесистемной конфигурационной информацией: , , , и .
 подраздел \ содержит описание аппаратного обеспечения системы и все сопоставления драйверов с устройствами. диспетчер устройств, который запускается с вкладки (оборудование) окна свойств системы, позволяет просматривать информацию об устройствах, получаемую простым считыванием значений параметров из раздела .
 эксперимент: забавы с разделом 
 вы можете обмануть своих коллег или друзей, заставив их поверить в то, что у вас самый последний процессор, модифицировав параметр в разделе \\\\\0. апплет (система) отображает значение параметра на вкладке (общие). изменение остальных параметров никак не влияет на информацию, выводимую апплетом , так как система кэширует многие параметры для использования функциями, через которые приложения запрашивают у системы возможности установленного на данном компьютере процессора.
 \ находится информация о локальных учетных записях и группах, например пароли, определения групп и сопоставления с доменами. система , работающая как контроллер домена, хранит доменные и групповые учетные записи в - базе данных, которая содержит общедоменные параметры и сведения. ( в этой книге не рассматривается.) по умолчанию дескриптор защиты раздела сконфигурирован так, что к нему не имеет доступа даже администратор.
 \ хранятся данные, которые относятся к общесистемным политикам безопасности, а также сведения о правах, назначенных пользователям. \ связан с подразделом в разделе \-\. по умолчанию содержимое \ недоступно для просмотра, поскольку параметры защиты разрешают доступ только по учетной записи . вы можете сменить дескриптор защиты, чтобы администраторы получили доступ к этому разделу для чтения, или, если вам любопытно, что там находится, запустить под локальной системной учетной записью с помощью (как это сделать, будет показано в соответствующем эксперименте). это почти ничего не даст, так как данные в нем не документированы, а пароли зашифрованы (по алгоритму необратимого шифрования).
 \ - то место, где хранит общесистемную конфигурационную информацию, не требуемую при загрузке системы. кроме того, здесь сохраняют свои общесистемные настройки приложения сторонних разработчиков (пути к файлам, каталоги приложений, даты лицензий и сроки их окончания).
 \ содержит общесистемную конфигурационную информацию, необходимую для загрузки системы, например списки загружаемых драйверов и запускаемых сервисов. поскольку эта информация критична для запуска системы, делает ее копию, называемую последней удачной конфигурацией ( ). она позволяет вернуться к последней работоспособной конфигурации, если после изменений, внесенных в текущую конфигурацию, система перестала загружаться. подробнее об этом - ближе к концу главы.
__
 __ - просто ссылка на текущий профиль оборудования, хранящийся в \\\ \-. профили оборудования позволяют администратору изменять базовые настройки системных драйверов. хотя реальный профиль может меняться от загрузки к загрузке, благодаря разделу приложения всегда имеют дело с текущим активным профилем. управление профилями оборудования осуществляется через диалоговое окно (профили оборудование), которое открывается кнопкой (профили оборудования) в одноименном разделе на вкладке (оборудование) в апплете . при загрузке предложит указать, какой профиль вам нужен, если он не один.
__
 реестр также является механизмом, который в обеспечивает доступ к значениям счетчиков производительности. при этом не важно, предоставлены счетчики компонентами операционной системы или серверными приложениями. одна из дополнительных выгод обращения к счетчикам производительности через реестр - возможность удаленного мониторинга рабочих характеристик без лишних издержек, поскольку удаленный доступ к реестру легко получить через обычные -функции реестра.
 обратиться напрямую к этим данным можно только программным путем через -функции реестра типа , открыв специальный раздел с именем __. доступ к разделу из редактора реестра невозможен - здесь хранится не сама информация о производительности, а ссылки на соответствующие источники этих данных.
 информация, относящаяся к счетчикам производительности, доступна и через функции (), предоставляемые (.). компоненты, используемые для получения значений счетчиков производительности, показаны на рис. 4-2.
анализ и устранение проблем с реестром
 поскольку система и приложения сильно зависят от конфигурационных параметров, изменение данных в реестре может вызвать их сбои. когда системе или приложению не удается считать параметры, которые, как предполагается, всегда доступны, это программное обеспечение может рухнуть и при этом выводить сообщения об ошибках, скрывающие корень проблемы. понимая, как сбоящая система или программа обращается к реестру, практически невозможно выяснить, какие разделы или параметры реестра сконфигурированы неправильно. такой ситуации ответ может дать утилита .
 позволяет наблюдать за обращениями к реестру. при этом выводит информацию о процессе, обращающемся к реестру, а также сообщает время, тип и результат доступа. эти сведения полезны для того, чтобы увидеть, как приложения и система взаимодействуют с реестром, найти места хранения конфигурационных параметров, записываемых приложениями и системой, и устранить неполадки, связанные с отсутствием каких-либо разделов или параметров реестра. включает расширенные средства фильтрации и выделения информации, чтобы вы могли сосредоточиться на операциях над выбранными разделами или параметрами, либо операциях, выполняемых конкретными процессами.
как работает 
 утилита полагается на драйвер устройства, который она извлекает из своего исполняемого образа и запускает в период своего выполнения. при первом запуске она требует, чтобы в учетной записи, под которой она выполняется, были привилегии и ; при последующих запусках в том же сеансе загрузки системы достаточно одной привилегии , так как драйвер является резидентным.
 самом деле внутри исполняемого файла хранится три драйвера: один - для 95, 98 и , другой - для , 2000 и , третий - для 2003. почему драйвер для 2003 отделен от драйвера для аналогичных систем? потому, что в , 2000 и единственный способ, которым драйвер может вести мониторинг всех операций с реестром - перехват системных вызовов (- ), и потому, что в 2003 драйвер может использовать с той же целью механизм обратного вызова реестра ( ). ( 95, 98 и поддерживают другой механизм мониторинга реестра.)
 вспомните раздел «диспетчеризация системных сервисов» главы 3 - там говорилось, что адреса функций системных сервисов хранятся в диспетчерской таблице системных сервисов в ядре. драйвер может обнаруживать вызов системного сервиса, сохранив адрес соответствующей функции из массива и заменив этот элемент массива адресом своей функции-ловушки ( ). после этого любые вызовы данного сервиса поступают в функцию-ловушку, установленную драйвером, и эта функция может проверять или модифицировать параметры вызова, а при необходимости и выполнять исходную функцию системного сервиса. если функция-ловушка вызывает исходную функцию, драйвер также получает возможность изучить результат операции и возвращаемые ею данные, например значения параметров реестра. рис. 4-3 показано, как перехватывает вызовы функций реестра в режиме ядра.
 механизм обратного вызова реестра впервые появился в ; однако по-прежнему использует перехват системных вызовов (- ), работая в , потому что в ней этот механизм сообщает не обо всех операциях с реестром. используя механизм обратного вызова, драйвер регистрирует в диспетчере конфигурации функцию обратного вызова. диспетчер конфигурации запускает функции обратного вызова, установленные драйвером, в определенные моменты выполнения системных сервисов реестра, чтобы драйвер видел все обращения к реестру и мог их контролировать. этот механизм используют антивирусные программы, которые сканируют данные реестра или блокируют неавторизованным процессам доступ к реестру для записи.
 эксперимент: анализ операций с реестром в простаивающей системе 
 поскольку реестр реализует функцию , с помощью которой приложения могут запрашивать уведомление об изменениях в реестре, не опрашивая его постоянно, в простаивающей системе не должен обнаруживать повторяющиеся обращения к одним и тем же разделам или параметрам реестра. любая такая активность указывает на плохо написанное приложение, которое отрицательно влияет на общую производительность системы.
 запустите и через несколько секунд изучите журнал вывода, чтобы выяснить, не пытается ли какая-то программа постоянно опрашивать реестр. найдя в выводе строку, связанную с опросом, щелкните ее правой кнопкой мыши и выберите из контекстного меню команду , чтобы узнать, какой процесс занимается такой деятельностью.
 эксперимент: поиск параметров приложения в реестре с помощью 
 иногда при анализе проблем нужно определить, где в реестре хранятся те или иные параметры системы или приложения. этом эксперименте вы используете для поиска параметров (блокнот). , как и большинство -приложений, сохраняет пользовательские предпочтения (например, включение режима переноса строк, выбранный шрифт и его размер, позиция окна) между запусками. наблюдая с помощью , когда считывает или записывает свои параметры, вы сможете выявить раздел реестра, в котором хранятся эти параметры. вот как это делается.
 1. пусть сохранит какой-нибудь параметр, который вы легко найдете в трассировочном выводе . для этого запустите , выберите шрифт и закройте .
 2. запустите . откройте диалоговое окно фильтра выделения информации и введите . в фильтре . тогда будет протоколировать только активность . в столбце или .
 3. снова запустите и остановите в перехват событий, просто выбрав команду-переключатель в меню утилиты .
 4. прокрутите полученный журнал к верхней строке и выберите ее.
 5. нажмите +, чтобы открыть диалоговое окно , и введите строку поиска . должен выделить строку вроде показанной на следующей иллюстрации. остальные операции в непосредственной близости должны относиться к другим параметрам .
 наконец, дважды щелкните выделенную строку. запустит (если он еще не выполняется) и заставит его перейти к соответствующему параметру реестра.
методики анализа проблем с применением 
 выявить причины сбоев приложения или системы, связанные с реестром, позволяют две базовые методики анализа с использованием .
  найдите в трассировке последнее, что делало приложение перед сбоем. это может указать на источник проблемы.
  сравните трассировку для сбойного приложения с аналогичной трассировкой в работающей системе.
 при первом подходе запустите сначала , затем приложение. момент сбоя вернитесь в и остановите протоколирование (нажав +). прокрутите журнал до конца и найдите последние операции, выполнявшиеся приложением перед сбоем (крахом, зависанием или чем-то еще). начните с последней строки и изучайте, на какие файлы и/или разделы реестра были ссылки, - это часто помогает локализовать источник проблемы.
 второй подход полезен, когда приложение сбоит в одной системе, но работает в другой. создайте в журналы трассировки приложения в сбойной и работающей системе, потом откройте их в (согласитесь с параметрами по умолчанию, предлагаемыми мастером импорта) и удалите первые три столбца. (если вы их не удалите, сравнение покажет, что все строки различаются, так как в первых трех столбцах содержится информация, которая меняется между запусками.) наконец, сравните полученные файлы журналов. (для этого можно использовать и утилиту , которая в включена в дистрибутив как один из бесплатных инструментов, а для 2000 предлагается в составе ресурсов.)
 вы должны обратить особое внимание на записи в трассировке со значениями «» или « » в столбце . сообщается, когда приложение пыталось обратиться к несуществующему разделу или параметру реестра. многих случаях отсутствующий раздел или параметр - вещь безобидная, так как процесс, не сумевший обнаружить искомое в реестре, просто использует значения по умолчанию. для некоторых параметров нет значений по умолчанию, и поэтому приложения сбоят, не найдя их в реестре.
 ошибки, связанные с отказом в доступе, - частая причина сбоев приложений; такие ошибки возникают, когда у приложения нет разрешения на доступ к нужному разделу реестра. это касается приложений, в которых не проверяются результаты операций с реестром или не предусматривается восстановление после соответствующих ошибок.
 также подозрительна строка со значением «». она не указывает на наличие в приложении эксплойта (), использующего переполнение буфера. такое значение посылается диспетчером конфигурации программе, которая выделила под буфер для хранения параметра реестра слишком мало места. разработчики приложений часто пользуются этим, чтобы определить, какой буфер надо выделить для хранения того или иного значения. сначала выполняется запрос к реестру с буфером нулевой длины и в ответ поступает сообщение с ошибкой переполнения буфера и истинным размером данных. тогда программа создает буфер указанного размера и повторно считывает данные. поэтому вы должны обнаружить операции, которые возвращают и при повторной попытке дают успешный результат.
 вот один из примеров использования для анализа реальной проблемы. эта утилита избавила пользователя от полной переустановки симптом был таким: зависал при запуске, если пользователь предварительно не устанавливал вручную соединение с интернетом. оно было задано как соединение по умолчанию, поэтому запуск должен бы вызывать автоматическое подключение к интернету ( был настроен на отображение начальной страницы по умолчанию при запуске).
 изучение журнала для операций при запуске, начиная с того места, где зависал, позволило обнаружить запрос, адресованный разделу в \\\ . пользователь сообщил, что ранее он удалил средство набора телефонных номеров, сопоставленное с этим разделом, и вручную создал соединение по коммутируемой линии. поскольку имя такого соединения не совпадало с именем удаленной программы, получалось, что соответствующий раздел не был удален программой удаления средства набора телефонных номеров и что именно это было причиной зависания . после удаления этого раздела стал работать нормально.
протоколирование операций под непривилегированными учетными записями или во время входа/выхода
 нередко наблюдается следующая ситуация. приложение работает при выполнении под учетной записью, входящей в группу (администраторы), и сбоит при запуске под учетной записью непривилегированного пользователя. как уже говорилось, требует привилегий, которые обычно не выдаются стандартным учетным записям пользователей, но вести трассировку приложений, выполняемых в сеансе входа непривилегированного пользователя, все же можно. для этого запустите под административной учетной записью командой . 
 если проблема с реестром относится ко входу или выходу по учетной записи, вы также должны предпринять особые меры, чтобы использовать для трассировки этих этапов сеанса входа. приложения, выполняемые под системной учетной записью, не завершаются при выходе пользователя, и благодаря этому вы можете работать с , несмотря на выход текущего пользователя и последующий вход того же или другого пользователя. чтобы запустить под системной учетной записью, введите команду , встроенную в , и укажите флаг / или запустите утилиту , например так:
 - - - : \. 
 ключ - сообщает , что окно должно появиться в интерактивной консоли, ключ - заставляет запустить под системной учетной записью, а ключ - указывает запустить и завершиться, не дожидаясь закрытия . после этой команды данный экземпляр переживет выход пользователя, и его окно вновь появится на рабочем столе, когда кто-то войдет в систему; при этом он будет протоколировать активность в реестре в обоих случаях.
 еще один способ мониторинга активности в реестре во время входа, выхода, загрузки системы или ее выключения - использовать функцию для протоколирования с момента загрузки системы. для этого вы должны выбрать в меню . при следующем запуске системы драйвер устройства будет протоколировать активность в реестре с самых ранних этапов загрузки, записывая информацию в журнал \\ .. протоколирование будет продолжаться до тех пор, пока не закончится свободное место на диске, пока система не будет выключена или пока вы не запустите . файл журнала, хранящий трассировку операций над реестром при загрузке, входе, выходе и выключении системы , обычно занимает 50-150 мб.
внутренние механизмы реестра
 из этого раздела вы узнаете, как диспетчер конфигурации (компонент исполнительной системы, реализующий реестр) организует файлы реестра на диске. мы исследуем, как диспетчер конфигурации управляет реестром по мере его чтения и изменения приложениями и другими компонентами системы. мы также обсудим механизмы, с помощью которых диспетчер конфигурации позволяет восстанавливать реестр, даже если система рухнула непосредственно в ходе внесения в него изменений.
кусты
 реестр представлен на диске не просто одним большим файлом, а набором отдельных файлов, называемых кустами (). каждом кусте содержится дерево реестра, у которого есть раздел, служащий корнем, или начальной точкой, дерева. подразделы с их параметрами находятся под корнем. возможно, вы подумали, что корневые разделы, показываемые редактором реестра, соответствуют корневым разделам кустов, но это не так. таблице 4-5 перечислены кусты реестра и имена их файлов на диске. полные имена всех файлов кустов (вместе с путями), кроме относящихся к профилям пользователей, жестко определяются самим диспетчером конфигурации. при загрузке кустов диспетчер конфигурации отмечает путь к каждому кусту в подразделе \\\\ и удаляет пути к выгруженным из памяти кустам. (профили пользователей выгружаются в отсутствие ссылок на них.) для формирования привычной структуры реестра, отображаемой редактором реестра, диспетчер конфигурации создает корневые разделы и связывает кусты друг с другом.
 заметьте, что некоторые кусты, перечисленные в таблице 4-5, являются изменяемыми и не имеют сопоставленных файлов. система создает и манипулирует такими кустами только в памяти, поэтому они существуют лишь временно. изменяемые кусты создаются при каждой загрузке системы. пример подобного куста - \, в котором хранятся сведения о физических устройствах и назначенных им ресурсах. распознавание оборудования и распределение ресурсов происходят при каждой загрузке системы, поэтому было бы нелогично хранить данные этого куста на диске.
 эксперимент: загрузка и выгрузка кустов вручную 
 32 в 2000 и в или 2003 позволяют загружать кусты, к которым можно обращаться через меню этих редакторов реестра. такая возможность полезна при анализе проблем, когда нужно просмотреть или отредактировать куст, полученный с незагружаемой системы или из резервной копии. этом эксперименте вы используете 32 (при наличии 2000) или (при наличии или 2003) для загрузки версии куста \, создаваемой программой и сохраняемый в каталоге \\ в ходе установки.
 1. кусты можно загружать только в или , поэтому откройте или 32, укажите , а затем выберите (загрузить куст) из меню (файл) в или из меню (реестр) в 32.
 2. перейдите в каталог \\ в диалоговом окне (загрузить куст), выберите . и откройте его. при запросе введите в качестве имени раздела, в который будет загружаться этот куст.
 3. откройте только что созданный раздел \ и изучите содержимое куста.
 4. откройте \\\\ и найдите элемент \\\, который продемонстрирует, как диспетчер конфигурации перечисляет загруженные кусты в разделе .
 5. укажите \ и выберите (выгрузить куст) из меню в или из меню в 32 для выгрузки этого куста.
лимиты на размеры кустов
 некоторых случаях размеры кустов ограничиваются. например, ограничивает размер куста \. это делается из-за того, что считывает весь куст \ в физическую память почти в самом начале процесса загрузки, когда поддержки виртуальной памяти еще нет. кроме того, загружает в физическую память и драйверы устройств периода загрузки. (подробнее о роли в процессе загрузки см. главу 6.) 2000 устанавливает фиксированный верхний предел на размер этого куста в 12 мб, но в и 2003 тот же куст может быть размером до 200 мб или до четверти объема физической памяти, установленной в системе (в зависимости от того, какой предел будет достигнут раньше).
 2000 также существует лимит на общий размер всех загруженных кустов. она использует для хранения кустов реестра пул подкачиваемой памяти, и поэтому общий объем загруженных данных реестра ограничен доступным размером этого пула. при инициализации диспетчер памяти определяет его размер на основе целого ряда факторов, в том числе объема физической памяти в системе. системе, где диспетчер памяти создает самый большой из возможных пул подкачиваемой памяти, размер реестра ограничен 376 мб. поскольку система не сможет эффективно работать, если пула подкачиваемой памяти будет недостаточно для других целей, 2000 не позволит данным реестра занять более 80 % этого пула. для просмотра или модификации ограничения на размер реестра, как показано на рис. 4-4, щелкните кнопку (изменить) в разделе (виртуальная память) диалогового окна (параметры быстродействия), доступного с вкладки (дополнительно) окна свойств системы.
 лимит на общий размер загруженных кустов реестра может привести к ограничению числа пользователей, одновременно входящих в систему 2000 с , поскольку каждый профиль пользователя увеличивает размер загруженных кустов. и 2003 диспетчер конфигурации использует не пул подкачиваемой памяти, а функции проецирования в системную память, предоставляемые диспетчером памяти. при этом проецируются лишь те части кустов реестра, к которым происходят обращения в данный момент времени. ограничений на размер реестра в или 2003 нет, и общий размер загруженных кустов не сказывается на масштабируемости .
 эксперимент: просмотр описателей кустов 
 диспетчер конфигурации открывает кусты, используя таблицу описателей режима ядра (см. главу 3), поэтому он может обращаться к ним из контекста любого процесса. применение такой таблицы - эффективная альтернатива подходу, основанному на использовании драйверов или компонентов исполнительной системы для простого обращения из системных процессов к одним лишь описателям (которые должны быть защищены от пользовательских процессов). просмотреть описатели кустов можно с помощью утилиты . 2000 диспетчер объектов сообщает об описателях из таблицы как об открытых в системном процессе , а в и 2003 он показывает описатели как открытые в процессе . укажите нужный процесс и выберите из подменю в меню . задайте сортировку по типу описателя и прокручивайте список, пока не увидите файлы кустов, как на следующей иллюстрации.
 особый тип разделов, символьная ссътка ( ), позволяет диспетчеру конфигурации связывать кусты для организации реестра. символьная ссылка - это раздел, который переадресует диспетчер конфигурации к другому разделу. так, раздел \ представляет собой символьную ссылку на раздел в корне куста .
структура куста
 диспетчер конфигурации делит куст на логические единицы, называемые блоками (), по аналогии с тем, как файловая система делит диск на кластеры. по определению размер блока реестра составляет 4096 байтов (4 кб). размер куста увеличивается кратно размеру блоков. первый блок куста называется базовым ( ); он включает глобальную информацию о кусте, в том числе сигнатуру , идентифицирующую файл как куст, порядковые номера, метку времени последней записи в куст, номер версии формата, контрольную сумму и внутреннее имя файла куста (например, \устройство\раздел_жесткого_диска1\\32\\). мы поясним смысл порядковых номеров и метки времени, когда будем рассматривать механизм записи данных в файл куста. номер версии формата указывает формат данных куста. 2000 диспетчер конфигурации использует формат данных куста версии 1 .3. и 2003 применяется тот же формат данных для совместимости с профилями роуминга 2000, но для кустов и используется формат версии 1 .5, обеспечивающий более эффективный поиск, а также хранение больших значений.
 упорядочивает хранимые в кусте данные с помощью контейнеров, которые называются ячейками (). ячейка может содержать раздел, параметр, дескриптор защиты, список подразделов или параметров раздела. поле в начале ячейки описывает тип ее данных. все типы данных поясняются в таблице 4-6. размер ячейки указывается в ее заголовке. когда ячейка присоединяется к кусту, последний должен быть соответственно увеличен. для этого система создает блок, называемый приемником (). размер приемника равен размеру ячейки, округленному до ближайшего большего значения, кратного размеру блока. пространство между концом ячейки и концом приемника считается свободным, и система может помещать в него другие ячейки. приемники тоже имеют заголовки, но с сигнатурой , и поле, в которое записывается размер приемника и его смещение в файле куста.
 используя для отслеживания активных частей реестра приемники вместо ячеек, упрощает себе управление реестром. так, система обычно создает и удаляет приемники реже, чем ячейки, а это позволяет диспетчеру конфигурации эффективнее управлять памятью. считывая куст в память, диспетчер конфигурации может выбирать только приемники, содержащие ячейки (т. е. активные приемники), и игнорировать пустые (удаленные). результате добавления или удаления ячеек куст может содержать пустые приемники вперемешку с активными. такая ситуация напоминает фрагментацию диска, возникающую при создании и удалении файлов. когда приемник становится пустым, диспетчер конфигурации объединяет его со смежными пустыми приемниками, формируя непрерывный пустой приемник как можно большего размера. диспетчер конфигурации также объединяет смежные пустые ячейки для формирования свободных ячеек большего размера. (диспетчер конфигурации уплотняет куст, только когда приемники в конце куста освобождаются. вы можете уплотнить реестр за счет его резервного копирования и последующего восстановления с помощью -функций и -, используемых утилитой .)
 ссылки, образующие структуру куста, называются индексами ячеек ( ). индекс ячейки представляет собой ее смещение в файле куста. таким образом, он похож на указатель из одной ячейки на другую и интерпретируется диспетчером конфигурации относительно начала куста. например, как видно из таблицы 4-6, ячейка раздела содержит поле с индексом ячейки родительского раздела; индекс ячейки подраздела указывает на ячейку со списком подчиненных ему подразделов. ячейка списка подразделов содержит список индексов, ссылающихся на ячейки подчиненных подразделов. поэтому если вам нужно найти, скажем, ячейку раздела для подраздела а, родительским разделом которого является раздел в, вы должны сначала найти ячейку со списком подразделов раздела по ее индексу в ячейке раздела в. после этого с помощью списка индексов из ячейки списка подразделов раздела можно отыскать ячейки любых подразделов раздела в. при этом для каждой ячейки подраздела вы проверяете, не совпадает ли хранящееся там имя раздела с именем искомого (в данном случае - а).
 ячейки, приемники и блоки можно легко перепутать, поэтому для прояснения различий между ними обратимся к структуре простого куста реестра. образец файла куста реестра, схема которого показана на рис. 4-5, включает в себя базовый блок и два приемника. первый приемник пуст, а во втором есть несколько ячеек. логично, что в таком кусте может быть всего два раздела: корневой и его подраздел, . находятся два параметра: 1 и 2. ячейка списка подразделов определяет местонахождение подразделов корневого раздела, а ячейка списка параметров - адрес параметров корневого раздела. свободные промежутки во втором приемнике являются пустыми ячейками. учтите, что на схеме не показаны ячейки дескрипторов защиты для двух разделов, которые должны присутствовать в составе куста.
 рис. 4-5. внутренняя структура куста реестра 
 рис. 4-6 показано окно утилиты (.) с образцом содержимого первого приемника куста . обратите внимание на сигнатуру приемника, . под ней можно увидеть сигнатуру . это сигнатура ячейки раздела (). обратный порядок отображения сигнатуры определяется порядком хранения данных в системах типа 86. ячейка, которой диспетчер конфигурации присвоил внутреннее имя $$$., является корневой ячейкой куста , как указывает следующее за сигнатурой имя.
 для оптимизации поиска подразделов и параметров диспетчер конфигурации сортирует ячейки списков подразделов в алфавитном порядке. если нужно найти подраздел в списке, диспетчер использует двоичный поиск. при этом он сразу обращается в середину списка. если искомое имя в соответствии с алфавитным порядком находится перед разделами из середины списка, диспетчер узнает, что оно хранится в первой половине списка. ином случае оно должно быть во второй половине списка подразделов. и так до тех пор, пока диспетчер не найдет искомый подраздел или не обнаружит его отсутствие. ячейки списков параметров не сортируются, так что новые параметры всегда добавляются в конец списка.
карты ячеек
 диспетчер конфигурации не обращается к файлам кустов на диске при каждом обращении к реестру хранит в адресном пространстве ядра версию каждого куста. при инициализации куста диспетчер конфигурации определяет размер его файла, выделяет из подкачиваемого пула нужный объем памяти и считывает файл куста в память (о пуле подкачиваемой памяти см. главу 7). поскольку все загруженные кусты реестра хранятся в подкачиваемом пуле, в 2000 они, как правило, занимают его наибольшую часть. (для исследования этого пула используйте утилиту , описываемую в одном из экспериментов главы 7.)
 и 2003 диспетчер конфигурации проецирует части куста в память по мере того, как возникает необходимость в доступе к ним. при этом он обращается к функциям проецирования файлов в диспетчере кэша для отображения 16-килобайтных представлений на файлы кустов (о диспетчере кэша см. главу 10). чтобы проекция куста не заняла весь адресный диапазон диспетчера кэша, диспетчер конфигурации пытается хранить не более 256 представлений куста в любой момент времени, отменяя проецирование реже всего используемых представлений по достижении этого предела. диспетчер конфигурации по-прежнему использует подкачиваемый пул для хранения различных структур данных, но занимает в нем лишь малую часть по сравнению с 2000.
 примечание и 2003 диспетчер конфигурации сохраняет блок в подкачиваемом пуле вместо его проецирования, если размер этого блока превышает 256 кб. 
 если бы размер кустов никогда не увеличивался, диспетчер конфигурации мог бы выполнять все операции с копией реестра в памяти, как с обыкновенным файлом. зная индекс ячейки, диспетчер конфигурации мог бы вычислить ее адрес в памяти, просто сложив индекс ячейки, представляющий смещение в файле куста, с базовым адресом копии куста в памяти. именно так и поступает с кустом на ранних этапах загрузки: он полностью считывает его в память как неизменяемый и для поиска нужных ячеек суммирует их индексы с базовым адресом копии куста в памяти. сожалению, по мере появления новых разделов и параметров кусты разрастаются, а это означает, что система должна выделять дополнительную память из подкачиваемого пула для хранения новых приемников с добавляемыми разделами и параметрами. так что данные реестра не обязательно хранятся в непрерывной области подкачиваемой памяти.
 эксперимент: наблюдение за использованием пула подкачиваемой памяти для кустов реестра 
 административных утилит, которые показывали бы объем памяти из подкачиваемого пула, используемой кустами реестра вместе с профилями пользователей, в 2000 нет. однако команда ! - отладчика ядра сообщает не только число страниц, задействованных каждым загруженным кустом, но и количество страниц, занятых постоянными и переменными данными. конце отчета команда выводит суммарный объем памяти, занятой кустами реестра, (учтите, что эта команда показывает лишь последние 32 символа в имени куста.)
 эксперимент: наблюдение за использованием памяти кустами 
 и 2003 статистику по использованию памяти кустами реестра можно просмотреть командой / . вывод команды включает размеры постоянных (сохраняемых на диске) и переменных данных, число активных представлений и количество представлений, заблокированных в памяти:
 здесь куст профиля для учетной записи (полный путь к которому, \ \\., в выводе обрезан) имеет 116 спроецированных представлений и размер около 4 мб (0х3000 в шестнадцатеричной форме). команда / показывает спроецированные представления заданного куста. вот как выглядит вывод этой команды при ее выполнении применительно к кусту ., который был показан как первый куст в выводе команды / : 
 этом выводе показаны адреса двух представлений, которые команда сообщила для куста в столбце . используя команду отладчика ядра для получения содержимого памяти по адресу первого представления, вы обнаружите, что это проекция базового блока куста гона распознается по сигнатуое ): 
 для работы с дискретными адресами, ссылающимися на данные кустов в памяти, диспетчер конфигурации использует стратегию, аналогичную применяемой диспетчером памяти для проецирования виртуальных адресов памяти на физические. двухуровневая схема, принятая для диспетчера конфигурации, показана на рис. 4-7. входе принимается индекс ячейки (т. е. смещение в файле куста), а на выходе возвращается адрес блока, в который попадает индекс данной ячейки, и адрес блока, в котором находится указанная ячейка. вспомните, что в приемнике может быть более одного блока, а куст разрастается за счет увеличения размеров приемников. ввиду этого всегда отводит под приемник непрерывную область памяти, и все его блоки находятся в одном и том же представлении, принадлежащем диспетчеру кэша (в и 2003), или в одной и той же части пула подкачиваемой памяти.
 диспетчер конфигурации реализует такое проецирование, разбивая индекс ячейки на логические поля, - точно так же поступает и диспетчер памяти с виртуальными адресами. интерпретирует первое поле индекса ячейки как индекс каталога карты ячеек куста. каталоге карты ячеек имеется 1024 элемента, каждый из которых ссылается на таблицу карты ячеек, а каждая таблица в свою очередь содержит 512 элементов. элемент в таблице карты ячеек определяется вторым полем индекса ячейки. этом элементе содержатся адреса приемника и блоков с ячейкой в памяти. и 2003 не все приемники обязательно проецируются в память, и, если поиск ячейки дает нулевой адрес, диспетчер конфигурации проецирует приемник в память, при необходимости отменяя проецирование другого приемника из своего списка.
 завершающем этапе процесса проецирования диспетчер конфигурации интерпретирует последнее поле индекса ячейки как смещение в найденном блоке для определения точного местонахождения ячейки в памяти. при инициализации куста диспетчер конфигурации динамически создает таблицы сопоставлений с записями для всех блоков куста, а в дальнейшем добавляет и удаляет таблицы из каталога ячеек по мере изменения размера куста.
пространство имен и механизмы работы реестра
 для интеграции пространства имен реестра с общим пространством имен ядра диспетчер конфигурации определяет тип объектов «раздел реестра». он помещает такой объект с именем в корень пространства имен и использует его как точку входа в реестр. показывает имена разделов в виде __\\, но подсистема транслирует эти имена в соответствии с пространством имен своих объектов (например, \\\\). диспетчер объектов, анализируя подобное имя, распознает ссылку на объект и тут же передает остальную часть имени диспетчеру конфигурации. последний берет на себя дальнейший разбор имени, просматривая свое внутреннее дерево куста для поиска нужного раздела или параметра. прежде чем описывать последовательность действий при типичной операции с реестром, нужно обсудить объекты «раздел реестра» и блоки управле-ния разделом ( ). всякий раз, когда программа создает или открывает раздел реестра, диспетчер объектов передает ей описатель для ссылки на этот раздел. описатель соответствует объекту «раздел реестра», созданному диспетчером конфигурации с участием диспетчера объектов. опираясь на диспетчер объектов, диспетчер конфигурации использует все предоставляемые им преимущества в защите объектов и учете ссылок.
 для каждого открытого раздела реестра диспетчер конфигурации создает блок управления разделом. таком блоке хранится полный путь раздела, индекс ячейки узла раздела, к которому относится данный блок, и флаг, уведомляющий диспетчер конфигурации, надо ли удалять ячейку раздела (на которую ссылается данный блок) после закрытия последнего описателя раздела. помещает все блоки управления разделами в хэш-таблицу, что обеспечивает быстрый поиск нужного блока по имени. объекты «раздел реестра» указывают на соответствующие блоки управления, и, если два приложения открывают один и тот же раздел реестра, каждое получает свой объект, указывающий на общий блок управления.
 приложение, открывая существующий раздел реестра, начинает с того, что сообщает его имя -функции реестра, которая вызывает процедуру разбора имени, принадлежащую диспетчеру объектов. найдя нужный объект «раздел реестра» в пространстве имен диспетчера конфигурации, диспетчер объектов возвращает ему полученный путь. диспетчер конфигурации, используя структуры данных куста, содержащиеся в памяти, ищет указанный раздел среди всех разделов и подразделов. если он находит ячейку раздела, поиск продолжается в дереве блоков управления разделами, что позволяет узнать, открыт ли данный раздел (тем же или другим приложением). процедура поиска оптимизирована так, чтобы поиск всегда начинался с ближайшего предка с уже открытым блоком управления. например, если приложение открывает \\\ \2 в то время, как \\ уже открыт, то процедура разбора в качестве отправной точки использует блок управления разделом \\. если раздел открыт, диспетчер конфигурации увеличивает счетчик ссылок в блоке управления этим разделом. ином случае диспетчер конфигурации создает новый блок управления и помещает его в дерево. далее диспетчер конфигурации создает объект «раздел реестра», передает указатель на него блоку управления разделом и возвращает управление диспетчеру объектов, который передает приложению описатель.
 когда приложение создает новый раздел реестра, диспетчер конфигурации сначала ищет для нового раздела ячейку родительского раздела. далее он находит список свободных ячеек куста, в котором будет находиться новый раздел, и определяет, есть ли достаточно большие ячейки для размещения ячейки нового раздела. если таковых нет, диспетчер конфигурации создает новый приемник и помещает в него ячейку, а остальное свободное пространство приемника регистрирует в списке свободных ячеек. новая ячейка раздела заполняется соответствующей информацией, включая имя раздела. диспетчер конфигурации добавляет ячейку раздела в список подразделов ячейки родительского раздела. наконец, система сохраняет в новой ячейке индекс родительской ячейки.
 диспетчер конфигурации использует счетчик ссылок блока управления разделом для определения момента его удаления. когда закрываются все описатели, счетчик ссылок обнуляется, и это говорит о том, что данный блок управления разделом больше не нужен. если приложение, вызывающее -функцию для удаления раздела, устанавливает флаг удаления, диспетчер конфигурации может удалить соответствующий раздел куста, так как он больше не используется ни одним приложением.
 эксперимент: просмотр блоков управления разделами 
 команда ! отладчика ядра позволяет перечислить все блоки управления разделами, созданные в системе. качестве альтернативы, если вы хотите просмотреть блок управления разделом для конкретного открытого раздела, используйте !\: 
 ›! \\\\ 
 = 103440:: \\\\ 
 для анализа блока управления разделом, о котором сообщила предыдущая команда, предназначена команда ! \ 
 поле указывает, что имя хранится в сжатой форме, а поле - что в разделе имеется 137 подразделов.
надежность хранения данных реестра
 для обеспечения гарантированной возможности восстановления постоянных кустов реестра (т. е. кустов, которым соответствуют файлы на диске) диспетчер конфигурации использует регистрационные кусты ( ). каждым постоянным кустом сопоставлен регистрационный, представляющий собой скрытый файл с именем куста и расширением . так, в каталоге \\32\ присутствуют ., . и другие -файлы. при инициализации куста диспетчер конфигурации создает битовый массив, в котором каждый бит представляет часть куста размером 512 байтов - сектор куста ( ). поэтому и массив называется массивом измененных секторов ( ). установленный бит этого массива указывает на то, что соответствующий сектор куста в памяти изменен системой и должен быть записан в файл куста на диске, а сброшенный бит означает, что его сектор не обновлялся.
 при создании нового или изменении уже существующего раздела или параметра диспетчер конфигурации отмечает модифицированные секторы куста в массиве измененных секторов. далее он планирует операцию отложенной записи, или синхронизацию куста ( ). системный поток отложенной записи активизируется через 5 секунд после запроса на синхронизацию куста и записывает измененные секторы всех кустов из памяти на диск. таким образом, система сбрасывает на диск и все изменения в данных реестра, произошедшие за период между запросом на синхронизацию и самой синхронизацией. следующая синхронизация возможна не ранее, чем через 5 секунд.
 примечание 2003 можно изменить 5-секундную задержку по умолчанию, используемую системным потоком отложенной записи. для этого модифицируйте в реестре параметр \ \\ \ \-. 
 если бы поток отложенной записи сразу записывал все измененные секторы в файл куста и при этом произошел бы крах системы, то файл куста оказался бы в несогласованном состоянии, и возможность его восстановления была бы утрачена. чтобы предотвратить такую ситуацию, массив измененных секторов куста и все измененные секторы сначала записываются в регистрационный куст, и при необходимости его размер увеличивается. далее поток отложенной записи обновляет порядковый номер базового блока куста и записывает измененные секторы в файл. закончив эту операцию, поток отложенной записи обновляет второй порядковый номер в базовом блоке. поэтому, если в момент записи в куст система рухнет, при ее перезагрузке диспетчер конфигурации обнаружит, что два порядковых номера в базовом блоке куста не совпадают, и сможет обновить куст, используя измененные секторы из файла регистрационного куста (т. е. произведет операцию отката вперед). результате данные куста останутся актуальными и в согласованном состоянии.
 для еще большей защиты целостности критически важного куста диспетчер конфигурации в 2000 поддерживает на диске его зеркальную копию. вы можете найти соответствующий файл в каталоге \-\32\ файл с именем без атрибута «скрытый» - -.. файл . является резервной копией куста. при каждой синхронизации куста происходит обновление и .. если при запуске системы диспетчер конфигурации обнаружит повреждение куста , он попытается загрузить его резервную копию. если она не повреждена, то будет использована для обновления исходного куста .
 и 2003 не поддерживают куст ., так как в этих версиях знает, как обрабатывать файл . для актуализации куста , который пришел в рассогласованное состояние при выключении системы или ее крахе. 2003 внесены и другие усовершенствования для большей устойчивости к повреждениям реестра. до 2003 диспетчер конфигурации вызывал крах системы, обнаружив базовый блок, приемник или ячейку с данными, которые не проходят проверки на целостность. диспетчер конфигурации в 2003 справляется с такими проблемами и, если повреждения не слишком сильны, заново инициализирует поврежденные структуры данных (с возможным удалением подразделов в ходе этого процесса) и продолжает работу. если же ему нужно прибегнуть к самовосстановлению, он уведомляет об этом пользователя, отображая диалоговое окно с сообщением о системной ошибке.
 примечание каталоге \\32\ также имеется скрытый файл .. это версия куста , которая служила изначальной копией куста . именно этот файл копируется программой с дистрибутива. 
оптимизация операций с реестром
 диспетчер конфигурации предпринимает некоторые меры для оптимизации операций с реестром. во-первых, практически у каждого раздела реестра имеется дескриптор защиты от несанкционированного доступа. было бы очень неэффективно хранить копии уникальных дескрипторов защиты для каждого раздела в кусте, поскольку сходные параметры защиты часто применяются к целым ветвям дерева реестра. когда система устанавливает защиту для какого-либо раздела, диспетчер конфигурации в 2000 прежде всего проверяет дескриптор защиты его родительского раздела, а потом просматривает все подразделы родительского раздела. если дескриптор защиты одного из них совпадает с дескриптором защиты, запрошенным системой для раздела, диспетчер конфигурации просто использует уже существующий дескриптор. учет числа разделов, совместно использующих один и тот же дескриптор, ведется с помощью счетчика ссылок. и 2003 диспетчер конфигурации проверяет пул уникальных дескрипторов защиты, чтобы убедиться, что в кусте имеется по крайней мере одна копия каждого уникального дескриптора защиты.
 диспетчер конфигурации также оптимизирует хранение имен разделов и параметров в кусте. реестр полностью поддерживает , но, если в каком-либо имени присутствуют только -символы, диспетчер конфигурации сохраняет это имя в кусте в -формате. когда диспетчер конфигурации считывает имя (например, при поиске по имени), он преобразует его формат в памяти в . хранение имен в формате позволяет существенно уменьшить размер куста.
 чтобы свести к минимуму нагрузку на память, блоки управления разделами не хранят полные пути разделов реестра. вместо этого они ссылаются лишь на имя раздела. так, блок управления разделом \\\ хранит не полный путь, а имя . дополнительная оптимизация в использовании памяти выражается в том, что диспетчер конфигурации хранит имена разделов в блоках управления именами разделов ( ), и все блоки управления разделов с одним и тем же именем используют один и тот же блок управления именем раздела. для ускорения просмотра диспетчер конфигурации хранит имена блоков управления разделами в специальной хэш-таблице.
 для быстрого доступа к блокам управления разделами диспетчер конфигурации сохраняет наиболее часто используемые блоки управления в кэш-таблице, сконфигурированной как хэш-таблица. при поиске блока диспетчер конфигурации первым делом проверяет кэш-таблицу. более того, у диспетче конфигурации имеется другой кэш, таблица отложенного закрытия ( ), в которой хранятся блоки управления разделов, закрытых приложениями. результате приложение при необходимости может быстро открыть недавно закрытый раздел. по мере добавления новых недавно закрытых блоков диспетчер удаляет из этой таблицы самые старые блоки.
сервисы
 практически в каждой операционной системе есть механизм, запускающий при загрузке системы процессы, которые предоставляют сервисы, не увязываемые с интерактивным пользователем. такие процессы называются сервисами, или -сервисами, поскольку при взаимодействии с системой они полагаются на сервисы аналогичны демонам и часто используются для реализации серверной части клиент-серверных приложений. примером -сервиса может служить -сервер, поскольку он должен запускаться вместе с системой и работать независимо от того, зарегистрировался ли в системе какой-нибудь пользователь.
 -сервисы состоят из трех компонентов - сервисного приложения ( ), программы управления сервисом ( , ) и диспетчера управления сервисами ( , ). для начала мы обсудим сервисные приложения, учетные записи сервисов и работу . далее мы поясним, как происходит автоматический запуск сервисов при загрузке системы, и рассмотрим, что делает в случае сбоя сервиса при его загрузке и как он завершает работу сервисов.
сервисные приложения
 сервисные приложения вроде -серверов состоят минимум из одной программы, выполняемой как -сервис. для запуска, остановки и настройки сервиса предназначена хотя в имеются встроенные , обеспечивающие базовую функциональность для запуска, остановки, приостановки и возобновления сервисных приложений, некоторые сервисные приложения предоставляют собственные , позволяющие администраторам указывать параметры конфигурации того сервиса, которым они управляют.
 сервисные приложения представляют собой просто -программы ( или консольные) с дополнительным кодом для обработки команд от и возврата ему статусной информации. поскольку у большинства сервисов нет пользовательского интерфейса, они создаются в виде консольных программ.
 когда вы устанавливаете приложение, в состав которого входит некий сервис, программа установки приложения должна зарегистрировать этот сервис в системе. для его регистрации вызывается -функция -, реализованная в 32. (\\32\32.). эта , название которой расшифровывается как « », реализует всю клиентскую часть .
 регистрируя сервис через , программа установки посылает сообщение о том, где будет находиться данный сервис. затем создает в реестре раздел для сервиса по адресу \\-\. раздел является постоянным представлением базы данных . индивидуальные разделы для каждого сервиса определяют пути к соответствующим исполняемым файлам, а также параметры и конфигурационные настройки сервисов.
 зарегистрировав сервис, программа установки или управляющее приложение может запустить его через функцию . поскольку некоторые приложения, основанные на сервисах, нужно инициализировать при загрузке системы, программа установки обычно регистрирует сервис как автоматически запускаемый, просит пользователя перезагрузить систему для завершения установки и при загрузке системы позволяет запустить сервис.
 при вызове программа должна указывать некоторые параметры, описывающие характеристики сервиса. эти характеристики включают тип сервиса (выполняется ли этот сервис в собственном процессе или совместно с другими сервисами), местонахождение его исполняемого файла, необязательное экранное имя, необязательные имя и пароль для запуска сервиса в контексте защиты определенной учетной записи, тип запуска (запускается ли он автоматически при загрузке системы или вручную под управлением ), код, указывающий, как система должна реагировать на ошибку при запуске сервиса, и необязательную информацию о моменте запуска относительно других сервисов (если данный сервис запускается автоматически).
 хранит каждую характеристику как параметр в разделе, созданном для данного сервиса. пример такого раздела реестра показан на рис. 4-8.
 рис. 4-8. пример раздела реестра для сервиса 
 таблице 4-7 перечислены характеристики сервиса, многие из которых применимы и к драйверам устройств. (заметьте, что не все из них свойственны каждому типу сервисов или драйверов устройств.) для хранения собственной конфигурационной информации сервиса в его разделе создается подраздел , в котором и будут находиться параметры конфигурации этого сервиса. сервис получает значения параметров через стандартные функции реестра.
 примечание не обращается к подразделу сервиса до тех пор, пока данный сервис не удаляется; лишь в момент его удаления уничтожает весь раздел сервиса вместе с подразделами вроде . 
 заметьте, что к драйверам устройств применимы три значения параметра туре. они используются драйверами устройств, которые также хранят свои параметры в разделе реестра . отвечает за запуск драйверов со значением , равным __ или __, поэтому база данных естественным образом включает и драйверы. сервисы используютдругие типы (_32__ и _ 32__), которые являются взаимоисключающими. программы, содержащие более одного сервиса, указывают тип _32_ _. преимущество совместного использования процесса несколькими сервисами - экономия ресурсов, которые в ином случае понадобились бы на диспетчеризацию индивидуальных процессов. потенциальный недостаток этой схемы в том, что работа всех сервисов данного процесса прекращается, если один из них вызывает ошибку, из-за которой завершается их процесс. кроме того, все сервисы в одном процессе должны выполняться под одной и той же учетной записью.
 когда запускает сервисный процесс, тот немедленно вызывает . эта функция принимает список точек входа в сервисы - по одной на каждый сервис процесса. каждая точка входа идентифицируется именем соответствующего сервиса. установив соединение с по именованному каналу, входит в цикл, ожидая, когда от поступит команда. посылает команду запуска сервиса, и функция - всякий раз, когда получает такую команду, - создает поток, называемый потоком сервиса ( ); он вызывает точку входа запускаемого сервиса и реализует цикл ожидания команд для сервиса. находится в бесконечном ожидании команд и возвращает управление основной функции процесса только после остановки всех сервисов в этом процессе, давая ему время на очистку ресурсов.
 первое, что происходит при передаче управления входной точке сервиса, - вызов . эта функция принимает и хранит указатель на функцию - обработчик управления ( ), которую реализует сервис для обработки различных команд . она не взаимодействует с , а лишь хранит только что упомянутую функцию в локальной памяти процесса для функции . входная точка продолжает инициализацию сервиса, выделяя нужную память, создавая конечные точки коммуникационного канала и считывая из реестра данные о собственной конфигурации сервиса. по соглашению, которому следует большинство сервисов, эти параметры хранятся в подразделе раздела соответствующего сервиса. входная точка, инициализируя сервис, может периодически посылать сообщения о ходе процесса запуска сервиса (при этом используется функция ). когда входная точка заканчивает инициализацию, поток сервиса обычно входит в цикл ожидания запросов от клиентских приложений. например, -сервер должен инициализировать тср-сокет и ждать запросы на входящие нттр-соединения.
 основной поток сервисного процесса, выполняемый в функции -, принимает команды , направляемые сервисам в этом процессе, и вызывает функцию - обработчик управления (хранимой ) для соответствующего сервиса. посылает следующие команды: (стоп), (пауза), (возобновление), (опрос), (выключение) и команды, определенные приложением. схема внутренней организации сервисного процесса показана на рис. 4-9. этой иллюстрации изображены два потока процесса, предоставляющего один сервис (основной поток и поток сервиса).
утилита 
 если у вас есть какая-то программа, которую нужно запускать как сервис, вы должны модифицировать ее стартовый код в соответствии с требованиями к сервисам, кратко описанным в этом разделе. если исходный код этой программы отсутствует, можно воспользоваться утилитой из ресурсов . позволяет выполнять любое приложение как сервис. она считывает путь файла, который должен быть загружен как сервис, из подраздела в разделе реестра, соответствующего данному сервису. при запуске уведомляет о том, что она предоставляет определенный сервис, и, получив от него команду, запускает исполняемый файл сервиса как дочерний процесс. последний получает копию маркера доступа процесса и ссылку на тот же объект . таким образом, сервис выполняется с параметрами защиты и настройками, указанными вами при конфигурировании . сервисы не поддерживают значение параметра туре, соответствующее совместному использованию процесса, поэтому каждое приложение, установленное утилитой как сервис, выполняется в отдельном процессе с отдельной копией хост-программы .
учетные записи сервисов
 контекст защиты сервиса очень важен для разработчиков и системных администраторов, поскольку он определяет, к каким ресурсам получит доступ этот сервис. большинство сервисов выполняется в контексте защиты учетной записи локальной системы, если системным администратором или программой установки не указано иное. ( пользовательском интерфейсе название учетной записи локальной системы показывается как или .) введены две разновидности учетной записи локальной системы: сетевой сервис ( ) и локальный сервис ( ). по сравнению с учетной записью локальной системы новые учетные записи обладают меньшими правами, и любой встроенный в сервис, не требующий всей мощи учетной записи локальной системы, выполняется под соответствующей альтернативной учетной записью. особенности этих учетных записей описываются в следующих разделах.
учетная запись локальной системы
 под этой учетной записью выполняются базовые компоненты пользовательского режима, включая диспетчер сеансов (\\32\.), процесс подсистемы (.), подсистемулокальной аутентификации (\\32\.) и процесс (\\32\.).
 точки зрения защиты, учетная запись обладает исключительными возможностями - большими, чем любая другая локальная или доменная учетная запись. вот ее характеристики.
  обладатель является членом группы локальных администраторов. таблице 4-8 перечислены группы, которым назначается учетная запись локальной системы. ( том, как информация о членстве в группах используется при проверках прав доступа к объектам, см. в главе 8.)
  она дает право на задание практически любых привилегий (даже таких, которые обычно не назначаются учетной записи локального администратора, например создания маркеров защиты). список привилегий, назначаемых учетной записи , приведен в таблице 4-9. (описание каждой привилегии см. в главе 8.)
  она дает право на полный доступ к большинству файлов и разделов реестра. даже если какие-то объекты не разрешают полный доступ, процессы под этой учетной записью могут воспользоваться привилегией захвата объекта во владение (- ) и тем самым получить нужный вид доступа.
  процессы, работающие под учетной записью , применяют профиль пользователя по умолчанию (\.). поэтому им недоступна конфигурационная информация, которая хранится в профилях пользователей, сопоставленных с другими учетными записями.
  если данная система входит в домен , учетная запись включает идентификатор защиты () для компьютера, на котором выполняется сервисный процесс. поэтому сервис, работающий под учетной записью , будет автоматически аутентифицирован на других машинах в том же лесу. (л с - это группа доменов в .)
  если только учетной записи компьютера специально не назначены права доступа (к общим сетевым ресурсам, именованным каналам и т. д.), процесс может получать доступ к сетевым ресурсам, разрешающим так называемые -сеансы, т. е. соединения, не требующие соответствующих удостоверений защиты. вы можете указывать общие ресурсы и каналы, разрешающие -сеансы на конкретном компьютере, в параметрах и раздела реестра \\\\\.
 1 учетная запись локальной системы в 2003 эту привилегию не включает.
учетная запись 
 эта учетная запись предназначена для сервисов, которым нужно аутентифицироваться на других компьютерах в сети по учетной записи компьютера, как это делается в случае учетной записи , но не требуется членство в административных группах или привилегии, назначаемые учетной записи . поскольку учетная запись не относится к группе администраторов, выполняемые под ней сервисы по умолчанию получают доступ к гораздо меньшему количеству разделов реестра, а также каталогов и файлов в файловой системе, чем учетная запись . более того, назначение меньшего числа привилегий ограничивает возможности скомпрометированного процесса сетевого сервиса. например, процесс, работающий под учетной записью , не может загрузить драйвер устройства или открыть произвольный процесс.
 процессы, выполняемые под учетной записью , используют ее профиль; он загружается в раздел \--5-20, а его файлы и каталоги находятся в \ \. и 2003 под учетной записью выполняется -кли-ент, отвечающий за разрешение -имен и поиск контроллеров домена.
учетная запись 
 эта учетная запись практически идентична с тем отличием, что позволяет обращаться лишь к тем сетевым ресурсам, которые разрешают анонимный доступ. таблице 4-9 показано, что у нее те же привилегии, что и у учетной записи , а таблица 4-8 - что она принадлежит к тем же группам (если не считать группы и ). профиль, используемый процессами, выполняемыми под учетной записью , загружается в \--5-19 и хранится в \ \.
 и 2003 под учетной записью работают такие компоненты, как (служба удаленного реестра), предоставляющая удаленный доступ к реестру локальной системы, служба оповещения, принимающая широковещательные сообщения с административными уведомлениями, и служба , обеспечивающая разрешение -имен.
выполнение сервисов под другими учетными записями
 силу вышеописанных ограничений некоторые сервисы должны работать с удостоверениями защиты учетной записи пользователя. вы можете сконфигурировать сервис на выполнение под другой учетной записью при его создании или с помощью оснастки (службы) консоли , указав в ней пароль и учетную запись, под которой должен работать сервис. оснастке щелкните правой кнопкой мыши нужный сервис, выберите из контекстного меню команду (свойства), перейдите на вкладку (вход в систему) и щелкните переключатель ( учетной записью), как показано на рис. 4-10.
интерактивные сервисы
 другое ограничение сервисов, работающих под учетными записями , или , заключается в том, что они не могут выводить окна на рабочий стол интерактивного пользователя (без специального флага в функции , о котором мы расскажем чуть позже). такое ограничение не является прямым следствием выполнения под этими учетными записями, а вызвано тем, как подсистема назначает сервисные процессы объектам .
 дело в том, что подсистема сопоставляет каждый -процесс с объектом . он включает объекты «рабочий стол», а те в свою очередь - объекты «окно». консоли видим только объект , и только он принимает пользовательский ввод от мыши и клавиатуры. среде видимым является лишь один объект для каждого сеанса, а все сервисы выполняются как часть консольного сеанса. присваивает видимому объекту имя , и к нему обращаются все интерактивные процессы.
 если не указано иное, подсистема сопоставляет сервисы, выполняемые под учетной записью , с невидимым -объектом -00-37$, который разделяется всеми неинтерактивными сервисами. числовая часть его имени, 37, представляет назначаемый идентификатор сеанса входа в систему, который используется для неинтерактивных сервисов, работающих под учетной записью .
 сервисы, сконфигурированные на запуск под учетной записью пользователя (т. е. под учетной записью, отличной от ), выполняются в другом невидимом объекте , имя которого формируется из идентификатора, назначаемого сеансу входа в систему. рис. 4-11 показано окно программы при просмотре каталога диспетчера объектов, в который помещает объекты . обратите внимание на интерактивный -объект 0, неинтерактивный -объект системного сервиса -00-37$ и неинтерактивный -объект -00-6368$, назначенный сервисному процессу, который зарегистрирован как пользователь.
 независимо от того, работает ли сервис под учетной записью пользователя или под учетными записями , либо , он не может получать пользовательский ввод или выводить окна на консоль, если он не сопоставлен с видимым объектом . фактически, если бы сервис попытался вывести обычное диалоговое окно, он бы казался зависшим, так как ни один пользователь не увидел бы это окно и не смог бы его закрыть с помощью мыши или клавиатуры. (единственное исключение - вызов со специальным флагом __ или ___. при __ окно всегда выводится через интерактивный объект , даже если сервис не сконфигурирован на взаимодействие с пользователем, а при ___ окно показывается на рабочем столе по умолчанию интерактивного объекта .)
 иногда, хоть и очень редко, сервису нужно взаимодействовать с пользователем через информационные или диалоговые окна. чтобы предоставить сервису право на взаимодействие с пользователем, в параметр туре в разделе реестра данного сервиса следует добавить модификатор __. (учтите, что сервисы, сконфигурированные для работы под учетной записью пользователя, нельзя помечать как интерактивные.) случае сервиса, помеченного как интерактивный, запускает его процесс в контексте защиты учетной записи , но сопоставляет сервис с , а не с неинтерактивным объектом . это позволяет сервису выводить на консоль окна и реагировать на ввод пользователя.
 примечание не рекомендует запускать интерактивные сервисы (особенно под учетной записью ), так как это вредит безопасности. , представленная интерактивным сервисом, уязвима перед оконными сообщениями, с помощью которых злонамеренный процесс, работающий как непривилегированный пользователь, может вызывать переполнения буферов в сервисном процессе и подменять его собой, чтобы повысить уровень своих привилегий в подсистеме защиты. 
диспетчер управления сервисами
 исполняемым файлом является \\32\., и подобно большинству процессов сервисов он выполняется как консольная -программа. процесс запускает на ранних этапах загрузки (см. главу 5) вызовом функции . она управляет запуском сервисов, сконфигурированных на автоматический старт. выполняется почти сразу после появления на экране пустого рабочего стола, но, как правило, до загрузки процессом графического интерфейса , открывающего диалоговое окно для входа в систему.
 прежде всего создает синхронизирующее событие с именем _3752 и в занятом состоянии. освобождает этот объект только по завершении всех операций, необходимых для подготовки к получению команд от последний устанавливает диалог с через функцию , которая не дает связаться с до его инициализации, реализуя это за счет ожидания перехода объекта _3752 в свободное состояние.
 далее переходит к делу и вызывает функцию -, создающую внутреннюю базу данных сервисов . функция считывает и сохраняет в разделе \\\\\ параметр типа __, в котором содержится список имен и порядок определенных групп сервисов. если сервису или драйверу нужно контролировать свой порядок запуска относительно сервисов других групп, в раздел реестра этого сервиса включается дополнительный параметр . например, сетевой стек построен по принципу «снизу вверх», поэтому сетевые сервисы должны указывать параметры , благодаря которым при загрузке системы они будут запускаться после загрузки сетевых драйверов. создает в памяти внутренний список групп, где хранится порядок групп, считанный из реестра. список входят , , , , и другие группы. дополнительные приложения и программное обеспечение от сторонних разработчиков могут определять собственные группы и вносить их в список. так, добавляет группу .
 сканирует раздел \\\ и создает для каждого его подраздела запись в базе данных сервисов. такая запись включает все параметры, определенные для сервиса, и поля, предназначенные для слежения за состоянием сервиса. добавляет записи для драйверов устройств и сервисов, так как отвечает за запуск компонентов, помеченных для автоматического запуска. при этом обнаруживает любые ошибки, вызываемые драйверами, которые помечены как запускаемые при загрузке системы (-) и после нее (-). (он также предоставляет приложениям средства для запроса состояния драйверов.) диспетчер ввода-вывода загружает такие драйверы до начала выполнения какого-либо процесса пользовательского режима, поэтому они загружаются до старта .
 считывает параметр сервиса, определяя принадлежность этого сервиса к той или иной группе, и сопоставляет его значение с элементом в созданном ранее списке групп. эта функция также считывает и сохраняет в базе данных зависимости сервиса от групп и других сервисов, запрашивая из реестра значения его параметров и -. рис. 4-12 показано, что представляет собой база данных . заметьте, что сервисы отсортированы в алфавитном порядке. это вызвано тем, что создает список на основе раздела , сортирует разделы реестра по алфавиту.
 при запуске сервиса может понадобиться обращение к (например, для регистрации сервиса под учетной записью пользователя), поэтому он ждет, когда освободит синхронизирующее событие ___, которое переходит в свободное состояние после инициализации . тоже запускает процесс , поэтому инициализация проходит параллельно инициализации , но завершаться эти операции могут в разное время. после этого вызывает , которая сканирует базу данных сервисов и ищет записи для драйверов устройств, запускаемых при загрузке системы и после нее. определяет, успешно ли запустился драйвер, проверяя наличие его имени в каталоге \ пространства имен диспетчера объектов. при успешной загрузке драйвера его объект помещается в данный каталог пространства имен диспетчером ввода-вывода, так что имена незагруженных драйверов присутствовать там не могут. содержимое каталога , полученное с помощью , показано на рис. 4-13. если драйвер не загружен, ищет его имя в списке, возвращаемом функцией _, которая сообщает о драйверах, включенных в текущий профиль оборудования системы. отмечает имена драйверов из текущего профиля, которые не удалось запустить, в списке с именем .
 перед запуском автоматически запускаемых сервисов предпринимает еще несколько действий. он создает именованный канал с именем \\, а затем запускает поток, отслеживающий приходящие по этому каналу сообщения далее освобождает свой объект _3752, сигнализируя о завершении инициализации.
буквы сетевых дисков
 не только предоставляет интерфейс к сервисам, но и играет еще одну роль, никак не связанную с сервисами: он уведомляет -приложения о создании или удалении сопоставления буквы с сетевым диском. ждет, когда маршрутизатор многосетевого доступа ( , ) освободит объект \\. это происходит, когда приложение назначает букву диска удаленному сетевому ресурсу или удаляет ее. (сведения о см. в главе 13) при освобождении объекта-события маршрутизатором многосетевого доступа вызывает -функцию , чтобы получить список букв подключенных сетевых дисков. если этот список изменяется в результате освобождения объекта-события, посылает широковещательное -сообщение типа _ с подтипом _ или _. это сообщение адресовано главным образом , чтобы он мог обновить любые открытые окна (мой компьютер) с учетом изменений в наборе подключенных сетевых дисков.
запуск сервиса
 вызывает -функцию для запуска всех сервисов, значение параметра которых указывает на автостарт. также осуществляет автоматический запуск драйверов. чтобы не запутаться, помните, что термином «сервисы» обозначаются как сервисы, так и драйверы, если явно не указано иное. алгоритм разбивает процесс запуска сервисов на несколько фаз, причем в каждой фазе запускаются определенные группы сервисов. порядок запуска определяется параметром в разделе реестра \\\\. этот параметр, показанный на рис. 4-14, включает имена групп в том порядке, в каком они должны запускаться . таким образом, единственное, для чего сервис включается в ту или иную группу, - точная настройка момента его запуска относительно других сервисов.
 начале каждой фазы отмечает все сервисы, относящиеся к группе, которая запускается на данной фазе. после этого перебирает отмеченные сервисы, определяя возможность запуска каждого из них. при этом функция проверяет зависимость текущего сервиса от другой группы, на существование которой указывает наличие в соответствующем разделе реестра параметра . если сервис зависит от какой-либо группы, она должна быть уже инициализирована и хотя бы один ее сервис должен быть успешно запущен. если сервис зависит от группы, запускаемой позже группы данного сервиса, генерирует ошибку, которая сообщает о «круговой зависимости». если имеет дело с -сервисом или с автоматически запускаемым драйвером устройства, она дополнительно проверяет, зависит ли данный сервис от каких-либо других сервисов, и, если да, то запущены ли они. зависимости сервисов указываются в параметре раздела, соответствующего сервису. если сервис зависит от других сервисов из групп, запускаемых позднее, также генерирует ошибку, связанную с «круговой зависимостью». если же сервис зависит от еще не запущенных сервисов из той же группы, он просто пропускается.
 если все зависимости корректны, делает последнюю перед запуском сервиса проверку: входит ли он в состав загружаемой в данный момент конфигурации. разделе реестра \\\ \ имеется два подраздела - и . какой из них будет использован для проверки зависимостей, определяется типом безопасного режима, выбранного пользователем. если пользователь выбрал (безопасный режим) или (безопасный режим с поддержкой командной строки), обращается к подразделу , а если пользователь выбрал (безопасный режим с загрузкой сетевых драйверов), то - к подразделу . наличие в разделе строкового параметра говорит не только о загрузке системы в безопасном режиме, но и указывает выбранный пользователем тип безопасного режима. подробнее о безопасных режимах см. главу 5.
 как только принимает решение о запуске сервиса, он вызывает , которая запускает сервисы иначе, чем драйверы устройств. случае -сервиса эта функция сначала определяет имя файла, запускающего процесс сервиса, и для этого считывает параметр из раздела, соответствующего сервису. далее она определяет значение параметра туре, и, если оно равно _32__ (020), проверяет, зарегистрирован ли процесс, запускающий данный сервис, по той же учетной записи, что и запускаемый сервис. учетная запись пользователя, под которой должен работать сервис, хранится в разделе этого сервиса в параметре . если параметр сервиса содержит значение или этот параметр вовсе отсутствует, данный сервис запускается под учетной записью .
 удостоверяется, что процесс сервиса еще не запущен под другой учетной записью. для этого он ищет в своей внутренней базе данных, называемой базой данных образов ( ), запись для параметра сервиса. если такой записи нет, создает ее. при этом он сохраняет имя учетной записи, используемой сервисом, и данные из параметра . требует от сервисов наличия параметра . если его нет, генерирует ошибку, сообщая, что найти путь к сервису не удалось и запуск этого сервиса невозможен. если находит существующую запись в базе данных с теми же данными, что и в , то проверяет, совпадают ли сведения об учетной записи пользователя запускаемого сервиса с информацией в базе данных. процесс регистрируется только под одной учетной записью, и поэтому сообщает об ошибке, если имя учетной записи сервиса отличается от имени, указанного другим сервисом, который уже выполняется в том же процессе.
 чтобы зарегистрировать (если это указано в конфигурации сервиса) и запустить процесс сервиса, вызывает . регистрирует сервисы, выполняемые не под системной учетной записью, с помощью -функции . обычно требует пароль, но указывает , что пароль хранится как «секрет» в разделе реестра \\\. (учтите, что содержимое обычно невидимо, поскольку его параметры защиты по умолчанию разрешают доступ только по системной учетной записи.) , вызывая , указывает тип регистрации, и поэтому ищет пароль в подразделе раздела с именем типа _ ‹имя сервиса›. конфигурируя регистрационную информацию сервиса, командует сохранить регистрационный пароль как секрет, используя функцию . если регистрация проходит успешно, возвращает описатель маркера доступа. такие маркеры применяются для установки контекста защиты пользователя, и сопоставляет маркер доступа с процессом, реализующим сервис.
 после успешной регистрации загружает информацию из профиля учетной записи (если она еще не загружена), для чего вызывает функцию из \\32\.. местонахождение куста, который загружает в реестр как раздел __, определяется параметром \\\ \\\‹раздел профиля пользователя› \.
 интерактивный сервис должен открыть -объект 0. прежде чем разрешить интерактивному сервису доступ к , проверяет, установлен ли параметр \\-\\\. этот параметр устанавливается администратором для того, чтобы запретить сервисам, помеченным как интерактивные, вывод окон на консоль. такой вариант применяется при работе сервера в необслуживаемом режиме, когда пользователей, взаимодействующих с интерактивными сервисами, нет.
 далее запускает процесс сервиса, если он еще не выполняется. запускает процессы в приостановленном состоянии, используя -функцию . после этого создает именованный канал для взаимодействия с процессом сервиса и присваивает ему имя \\\, гдех- счетчик количества созданных каналов. возобновляет выполнение процесса сервиса через функцию и ждет подключения сервиса к созданному каналу. сколько времени ждет вызова сервисом функции и соединения с каналом, зависит от значения параметра реестра \\\\ (если такой параметр существует). по истечении этого времени завершает процесс и считает запуск сервиса несостоявшимся. если параметра в реестре нет, использует таймаут по умолчанию, равный 30 секундам. этот же таймаут распространяется на все виды коммуникационной связи между и сервисами.
 когда сервис подключается по каналу к , последний посылает сервису команду запуска. если сервис в течение определенного периода не реагирует на нее, переходит к запуску следующего сервиса. данном случае не завершает процесс сервиса, а заносит запись об ошибке в системный журнал событий, указывая, что сервис не смог своевременно начать работу.
 если параметр реестра туре для сервиса, запускаемого с помощью , равен или ___ , то данный сервис является драйвером устройства, и вызывает для его загрузки . она выдает процессу право на загрузку драйвера и вызывает сервис ядра , передавая ему значение параметра реестра для данного драйвера. отличие от сервисов драйверам не обязательно указывать значение . если оно не указано, формирует путь к образу исполняемого файла, добавляя имя драйвера к строке \\32\\.
 продолжает поочередно обрабатывать сервисы, принадлежащие какой-либо группе, до тех пор, пока все они не будут запущены или не вызовут ошибку, связанную с нарушением зависимостей. такая циклическая обработка позволяет автоматически упорядочивать сервисы внутри группы в соответствии с их параметрами . сначала запускает сервисы, на которые полагаются другие сервисы, пропуская зависимые сервисы. заметьте, что игнорирует параметры в подразделах -сервисов раздела \\\ . эти параметры использует диспетчер ввода-вывода, упорядочивая запуск драйверов устройств в группе драйверов, запускаемых при загрузке и при старте системы.
 как только завершает операции запуска для всех групп, перечисленных в списке \, он переходит к запуску сервисов, принадлежащих к группам, которые не входят в этот список, а потом обрабатывает сервисы, не включенные ни в одну группу. закончив, переводит событие \\_ в свободное состояние.
ошибки при запуске
 если драйвер или сервис в ответ на команду запуска сообщает об ошибке, реакция определяется значением параметра из раздела реестра для соответствующего сервиса. если равен _ (0) или вообще не указан, игнорирует ошибку и продолжает обработку запуска сервисов. если равен - (1), заносит в журнал событий запись такого вида: « ‹имя сервиса› : («служба ‹имя сервиса› завершена из-за ошибки:»). добавляет возвращаемый сервисом -код ошибки, указывая его в записи в качестве причины сбоя при запуске. рис. 4-15 показан пример такой записи.
 рис. 4-15. запись в журнале событий, уведомляющая об ошибке при запуске сервиса 
 если сервис, значение которого равно __ (2) или __ (3), сообщает об ошибке при запуске, делает запись в журнале событий и вызывает внутреннюю функцию . эта функция активизирует версию реестра, соответствующую последней удачной конфигурации, в которой система была успешно загружена. после этого она перезагружает систему, вызывая сервис , реализуемый исполнительной системой. если система уже загружена в последней удачной конфигурации, она просто перезагружается.
критерии успешной загрузки и последняя удачная конфигурация
 кроме запуска сервисов система возлагает на определение того, когда следует сохранять раздел реестра \\ в качестве последней удачной конфигурации. раздел входит в раздел -, поэтому включает представление реестра из базы данных . также включает раздел , где хранятся многие параметры конфигурации подсистем режима ядра и пользовательского режима. по умолчанию загрузка считается успешной, если были запущены все автоматически запускаемые драйверы и пользователь смог войти в систему. загрузка считается неудачной, если система остановилась из-за краха драйвера устройства или если автоматически запускаемый сервис с параметром , равным __ или __, сообщил об ошибке при запуске.
 узнает, успешно ли стартовали автоматически запускаемые сервисы, но уведомление об успешном входе пользователя он должен получить от (\\32\.). при входе пользователя вызывает функцию , которая посылает сообщение . после успешного старта автоматически запускаемых сервисов или приема сообщения т (в зависимости от того, какое из этих событий будет последним) вызывает системную функцию для сохранения текущей конфигурации системы.
 сторонние разработчики программного обеспечения могут заменить определение успешного входа собственным. например, если в системе работает , загрузка считается успешной только после того, как может принимать и обрабатывать транзакции. разработчики указывают свое определение успешной загрузки, используя программу верификации загрузки и регистрируя ее местонахождение в параметре, который сохраняется в разделе реестра \\\\. кроме того, при установке программы верификации загрузки нужно отключить вызов функции , присвоив параметру \\\ \\\ значение, равное 0. если такая программа установлена, запускает ее, закончив обработку автоматически запускаемых сервисов. перед сохранением последней удачной конфигурации ждет вызова из этой программы.
 поддерживает несколько копий , который на самом деле представляет собой символьную ссылку на одну из этих копий. им присваиваются имена в виде \\ , где - порядковый номер вроде 001 или 002. раздел \\ хранит параметры, определяющие роль каждой копии . так, если ссылается на 001, значение параметра в разделе равно 1. параметр в разделе хранит номер последней удачной конфигурации. разделе может быть еще один параметр, , указывающий номер конфигурации, загрузка которой признана неудачной и прервана, после чего была предпринята попытка использования последней удачной конфигурации. рис. 4-16 показаны наборы и параметры раздела .
 синхронизирует набор параметров последней удачной конфигурации с содержимым дерева . после первой успешной загрузки системы последней удачной конфигурации еще нет, и система создает для нее новый набор параметров. если же набор параметров последней удачной конфигурации уже есть, система просто обновляет его данные так, чтобы они совпадали с данными из .
 последняя удачная конфигурация может помочь, когда изменения, внесенные в при оптимизации системы или установке сервиса, вызывают сбои при следующей загрузке. нажав клавишу 8 в самом начале загрузки, пользователь может вызвать меню, которое позволит ему активизировать последнюю удачную конфигурацию и вернуть реестр к исходному состоянию (детали см. в главе 5).
сбои сервисов
 разделах сервисов могут присутствовать необязательные параметры и , записываемые при запуске сервисов. система уведомляет о неожиданном завершении процесса сервиса, так как соответствующим образом регистрируется в системе. этом случае определяет, какие сервисы выполнялись в этом процессе, и предпринимает действия по их восстановлению. эти действия определяются параметрами реестра, относящимися к сбоям сервисов.
 сервисы могут указывать для такие действия, как перезапуск сервиса, запуск какой-либо программы и перезагрузка компьютера. более того, сервис может задавать действия, предпринимаемые при первом, втором и последующих сбоях его процесса, а также задавать период ожидания перед перезапуском сервиса, если это действие определено сервисом. например, сбой заставляет запустить приложение , которое освобождает ресурсы и перезапускает сервис. вы можете легко настроить действия, предпринимаемые для восстановления сервиса, на вкладке (восстановление) окна свойств сервиса в оснастке (службы), как показано на рис. 4-17.
завершение работы сервиса
 когда вызывает -функцию , она посылает сообщение , процессу подсистемы , доя вызова его процедуры завершения. по очереди уведомляет активные процессы о завершении работы системы. для каждого процесса, кроме , ждет его завершения в течение времени, указанного в \.\ \\ (по умолчанию - 20 секунд). дойдя до , также уведомляет его о завершении работы системы, но использует особый тайм-аут. опознает по идентификатору процесса, сохраненному при инициализации системы вызовом . таймаут отличен от таймаутов других процессов из-за того, что он обменивается сообщениями с сервисами. при завершении работы сервисы должны освободить ресурсы, поэтому администратору может быть достаточно настроить лишь таймаут . это значение хранится в \\\ \ и по умолчанию равно 20 секундам.
 обработчик завершения отвечает за рассылку уведомлений о завершении работы всем сервисам, которые сообщали при инициализации о необходимости посылки им таких уведомлений. -функция ищет в базе данных сервисы, которым требуется уведомление о завершении работы, и посылает каждому из них команду на завершение. для каждого сервиса, которому посылается уведомление о завершении работы, фиксирует срок ожидания ( ), который указывается и самим сервисом при его регистрации. определяет наибольший срок ожидания. разослав уведомления о завершении работы, ждет, пока не завершится хотя бы один из получивших уведомление сервисов или пока не истечет наибольший срок ожидания.
 если по истечении этого срока сервис так и не завершился, проверяет, не получил ли он сообщения о ходе процесса завершения от одного или нескольких ожидаемых им сервисов. если хотя бы один сервис прислал такое сообщение, снова ждет в течение периода, равного сроку ожидания. выходит из этого цикла ожидания, если все сервисы завершились или если ни один из них не прислал ему сообщение о ходе процесса завершения.
 пока занят рассылкой уведомлений и ожиданием завершения сервисов, ожидает завершения . если период ожидания (равный значению ) истекает, все еще выполняется, просто переходит к другим операциям, необходимым для завершения работы системы. таким образом, сервисы, не прекратившие свою работу вовремя, продолжают выполняться вместе с до момента выключения системы. сожалению, нет никакого способа, который позволил бы администратору узнать, надо ли увеличить значение , чтобы все сервисы успевали завершаться до выключения системы. (подробнее о процессе выключения системы см. в главе 5.)
разделяемые процессы сервисов
 выполнение каждого сервиса в собственном процессе может оказаться очень расточительным по отношению к системным ресурсам. другой стороны, если в каком-то из сервисов, совместно использующих один процесс, возникает ошибка, вызывающая завершение этого процесса, работа всех сервисов этого процесса прекращается.
 некоторые из встроенных сервисов выполняются в собственных процессах, а некоторые делят процессы совместно с другими сервисами. например, процесс включает сервисы (журнал системы) и пользовательского режима, а процесс содержит такие службы защиты, как () (диспетчер учетных записей безопасности), () (сетевой вход в систему) и () (агент политики 1р-безопасности).
 существует также «универсальный» процесс, () (\\32\.), который включает множество разнообразных сервисов. различных процессах может выполняться несколько экземпляров . сервисам, размещаемым в процессах , относятся, в частности, (), () и (). реализует сервисы, выполняемые в , в виде и включает в раздел реестра каждого из этих сервисов определение в формате «%%\32\. - ». подразделе раздела такого сервиса должен присутствовать и параметр , указывающий на -файл сервиса.
 для всех сервисов, использующих общий процесс , должен быть указан один и тот же параметр («- » - в примере из предыдущего абзаца), чтобы у них была одна запись в базе данных образов. когда , запуская сервисы, обнаруживает первый сервис с , указывающим на с каким-то параметром, он создает новую запись в базе данных образов и запускает процесс с этим параметром. новый процесс принимает этот параметр и ищет одноименный параметр в разделе реестра \\\ \\. считывает его, интерпретируя как список имен сервисов, и при регистрации уведомляет о предоставляемых сервисах. пример раздела показан на рис. 4-18. здесь процесс , запущенный с параметром «- », настроен на выполнение нескольких сетевых сервисов.
 если при запуске сервисов обнаруживает сервис со значением , которое соответствует уже существующей записи в базе данных образов, он не запускает второй процесс, а просто посылает уже выполняемому команду на запуск этого сервиса. существующий процесс считывает из раздела реестра сервиса параметр и загружает этого сервиса.
 эксперимент: просмотр сервисов, выполняемых в процессах 
 утилита выводит детальные сведения о сервисах, выполняемых внутри процессов. запустите и откройте вкладки в окнах свойств для следующих процессов: ., . и .. вашей системе должно выполняться несколько экземпляров , и вы сможете увидеть, под какой учетной записью работает каждый из них, добавив столбец в окне или взглянув на поле на вкладке окна свойств процесса. иллюстрации ниже показан список сервисов, выполняемых внутри , который работает под учетной записью локальной системы.
 отображаемая информация включает имя сервиса, его экранное имя ( ) и описание (если таковое есть); описание выводится в внизу списка при выборе конкретного сервиса.
 просмотреть список сервисов, выполняемых внутри процессов, также можно с помощью утилит командной строки . из и , которая входит в состав и 2003. первом случае синтаксис для просмотра сервисов выглядит так:
 / 
 во втором - так:
 / 
 заметьте, что эти утилиты не показывают описания или экранные имена сервисов.
программы управления сервисами
 программы управления сервисами ( , ) - стандартные -приложения, использующие -функции управления сервисами , , , , и . для вызова -функций сначала должна установить канал связи с через функцию . при запросе на открытие канала связи должна указать, какие действия ей нужно выполнить. например, если требуется просто вывести список сервисов, присутствующих в базе данных , то при вызове она запрашивает доступ для перечисления сервисов (- ). при инициализации создает внутренний объект, представляющий его базу данных. для защиты этого объекта применяются функции защиты . частности, для него создается дескриптор защиты, определяющий, по каким учетным записям можно открывать объект и с какими правами. например, в дескрипторе защиты указывается, что получить доступ к объекту для перечисления сервисов может группа , но открыть объект для создания или удаления сервиса могут только администраторы.
 реализует защиту не только своей базы данных, но и сервисов. создавая сервис вызовом , указывает дескриптор защиты, сопоставляемый с записью сервиса в базе данных. хранит дескриптор защиты в параметре раздела, соответствующего сервису. при инициализации сканирует раздел и считывает дескриптор защиты, так что параметры защиты сохраняются между загрузками системы. должна указывать тип доступа к сервису при вызове по аналогии с тем, как она это делает, вызывая обращения к базе данных . может запрашивать доступ для получения информации о состоянии сервиса, а также для его настройки, остановки и запуска.
 , которая вам, наверное, хорошо знакома, - оснастка (службы) консоли в . эта оснастка содержится в файле \ 32\.. и 2003 включают командной строки . ( ), а для 2000 такая программа доступна в ресурсах 2000.
 иногда расширяет политику управления сервисами по сравнению с той, которая реализуется . удачный пример - таймаут, устанавливаемый оснасткой при запуске сервисов (служб) вручную. эта оснастка выводит индикатор, отражающий ход запуска сервиса. если ждет ответа сервиса на команду запуска неопределенно долго, то оснастка - только 2 минуты, после чего сообщает, что сервис не смог своевременно начать работу. сервисы косвенно взаимодействуют с -программами, изменяя свой статус, который отражает их прогресс в выполнении команды . запрашивают этот статус через функцию и способны отличать зависшие сервисы от активно обновляющих свой статус. благодаря этому они могут уведомлять пользователя о том, что делает тот или иной сервис.
 
 всегда были интегрированные средства мониторинга производительности и системных событий. приложения и система, как правило, используют (диспетчер событий) для вывода сообщений об ошибках и диагностической информации. помощью (просмотр событий) администраторы могут просматривать список событий как на локальном компьютере, так и на любом компьютере в сети. аналогичным образом механизм поддержки счетчиков производительности позволяет приложениям и операционной системе передавать соответствующие статистические сведения таким программам мониторинга производительности, как .
 хотя средства мониторинга событий и производительности в 4 решают поставленные при разработке задачи, для них характерны некоторые ограничения. так, их программные интерфейсы различаются, что усложняет приложения, использующие для сбора данных не только мониторинг событий, но и мониторинг производительности. вероятно, самый серьезный недостаток средств мониторинга в 4 в том, что они слабо расширяемы (если вообще расширяемы) и не поддерживают двустороннее взаимодействие, необходимое для управления. приложения должны предоставлять данные в жестко предопределенных форматах. не позволяет приложениям получать уведомления о событиях, связанных с производительностью, а приложения, запрашивающие уведомления о событиях , не могут ограничиться конкретными типами событий или источниками. наконец, клиенты любого из механизмов мониторинга не могут взаимодействовать через или с провайдерами данных, относящихся к событиям или счетчикам производительности.
 для устранения этих ограничений и поддержки средств управления другими типами источников данных в включен новый механизм управления, () (инструментарий управления ). - это реализация - () (управление предприятием на основе ), стандарта, введенного промышленным консорциумом (). стандарт определяет правила проектирования средств управления и сбора данных в масштабах предприятия, обладающих достаточной расширяемостью и гибкостью для управления локальными и удаленными системами, которые состоят из произвольных компонентов. поддержка добавляется в 4 установкой 4. также поддерживается в 95 2, 98 и . хотя многие сведения из этого раздела применимы ко всем платформам , поддерживающим , особенности реализации , о которых мы здесь рассказываем, все же специфичны для 2000, и 2003.
архитектура 
 состоит из четырех главных компонентов, как показано на рис. 4-19: управляющих приложений, инфраструктуры , компонентов доступа (провайдеров) и управляемых объектов. первые являются -приложениями, получающими сведения об управляемых объектах для последующей обработки или вывода. пример простого управляющего приложения - утилита (производительность), использующая вместо . более сложным программам относятся промышленные средства управления, позволяющие администраторам автоматизировать инвентаризацию программно-аппаратных конфигураций всех компьютеров на своих предприятиях.
 управляющие приложения, как правило, предназначены для управления определенными объектами и сбора данных от них. объект может представлять единственный компонент, например сетевую плату, или совокупность компонентов вроде компьютера. (объект «компьютер» может включать объект «сетевая плата».) провайдеры должны определять и экспортировать форму представления объектов, нужных управляющим приложениям. так, изготовитель может добавить специфичную функциональность для сетевой платы, поддерживаемой . поэтому он должен написать свой провайдер, который открывал бы управляющим приложениям объекты, связанные с этой функциональностью.
 инфраструктура , центральное место в которой занимает () (), связывает воедино управляющие приложения и провайдеры (о - чуть позже). инфраструктура также служит хранилищем классов объектов и зачастую диспетчером хранения свойств постоянных объектов. реализует это хранилище в виде базы данных на диске, которая называется репозитарием объектов ( ). поддерживает несколько , через которые управляющие приложения обращаются к данным объектов, провайдерам и определениям классов.
 для прямого взаимодействия с -программы используют , основной управления. остальные размещаются поверх и включают -адаптер для субд . разработчик может использовать этот адаптер для встраивания ссылок на данные объектов в свою базу данных. после этого можно легко генерировать отчеты с помощью запросов к базе данных, содержащей -информацию. -элементы поддерживают другой многоуровневый . -разработчики используют -элементы для создания -интерфейсов к -данным. для написания сценариев представляет собой еще один управления, используемый в приложениях, построенных на основе сценариев («скриптов»), и в программах . поддержка сценариев предусмотрена во всех технологиях языков программирования .
 как и для управляющих приложений, интерфейсы образуют основной для провайдеров. в отличие от управляющих приложений, являющихся сом-клиентами, провайдеры - это - или -серверы, т. е. провайдеры реализуют сом-объекты, с которыми взаимодействует провайдеры могут быть реализованы в виде , загружаемых в процесс диспетчера , а также в виде отдельных -приложений или сервисов. предлагает ряд встроенных провайдеров, которые представляют данные из таких общеизвестных источников, как , реестр, , , и -драйверы устройств. сторонние разработчики могут создавать свои компоненты доступа, используя .
провайдеры
 основе лежит спецификация , разработанная определяет, как управляющие системы представляют любые компоненты вычислительной системы - от компьютера до устройств и приложений. разработчики провайдеров используют для представления компонентов приложения, для которого они предусматривают возможность управления. реализация м-представлений осуществляется на языке ().
 провайдер должен не только определять классы, представляющие объекты, но и обеспечивать -интерфейс с объектами. классифицирует провайдеры в соответствии с функциями их интерфейса. эта классификация показана в таблице 4-10. заметьте, что провайдер может реализовать несколько функций и благодаря этому выступать сразу в нескольких ролях, например провайдера классов и провайдера событий. чтобы лучше понять определения функций в таблице 4-10, рассмотрим провайдер , реализующий несколько таких функций. он поддерживает несколько объектов, включая , и . является провайдером , так как способен определять несколько экземпляров своих классов. один из классов, определяемых в нескольких экземплярах, - (32_); экземпляр этого класса определяется для каждого журнала событий: (журнал системы), (журнал приложений) и (журнал безопасности).
 провайдер определяет данные экземпляра и позволяет управляющим приложениям перечислять записи. методы и , реализуемые для объектов , позволяют управляющим приложениям создавать резервные копии файлов и восстанавливать их через . это дает основания считать и провайдером . наконец, управляющее приложение может зарегистрироваться на получение уведомлений о создании новых записей в файлах . таким образом, , уведомляя о создании новых записей, выступает еще и в роли провайдера .
 и язык 
 следует по стопам объектно-ориентированных языков типа ++ и , в которых средства моделирования создают представления в виде классов. работая с классами, программисты могут использовать мощные методы моделирования, например наследование и включение. подклассы могут наследовать атрибуты класса-предка, добавляя при этом собственные и даже переопределяя унаследованные. класс, наследующий свойства другого класса, считается производным. то же время классы можно составлять, создавая новый класс, включающий другие.
 предоставляет набор классов как часть стандарта . эти классы образуют базовый язык и представляют объекты, применимые во всех сферах управления. классы являются частью базовой модели ( ). примером базового класса может служить _. у него есть несколько базовых свойств, идентифицирующих физические компоненты вроде аппаратных устройств и логические компоненты типа процессов и файлов. свойствам относятся заголовок (), описание (), дата установки ( ) и статус (). таким образом, классы _ и _ наследуют атрибуты класса _. эти два класса тоже входят в базовую модель . стандарте эти классы называются абстрактными, поскольку они существуют только как наследуемые другими классами (т. е. создать объект абстрактного класса нельзя). абстрактные классы можно считать шаблонами, которые определяют свойства, используемые в других классах.
 вторая категория классов представляет объекты, специфичные для сфер управления, но независимые от конкретной реализации. эти классы образуют общую модель ( ) и считаются расширением базовой модели. пример класса общей модели - _, наследующий атрибуты _. поскольку практически все операционные системы, включая , и прочие вариации , опираются на хранилище данных, структурируемое на основе той или иной файловой системы, класс _ является важной частью общей модели.
 последняя категория классов, расширенная модель ( ), включает расширения, специфичные для конкретных технологий. определен обширный набор таких классов, представляющих объекты, специфичные для подсистемы . так как все операционные системы хранят данные в файлах, в общую модель входит класс _. класс _ наследует свойства _, добавляет классы 32_ и 32_ для соответствующих типов файлов в подсистеме .
 провайдер интенсивно использует наследование. рис. 4-20 показано, как выглядит , браузер классов, поставляемый с (этот набор можно бесплатно получить с сайта ). использование наследования в провайдере можно наблюдать на примере его класса 32_, производного от _ . файлы - это файлы данных, которые имеют дополнительные атрибуты, специфичные для файлов журналов: имя файла журнала () и счетчик числа записей в файле (). отображаемое браузером дерево классов показывает, что 32_ использует несколько уровней наследования: _ является производным от _, тот - от _, а последний - от _.
 как уже говорилось, разработчики провайдеров пишут свои классы на языке . ниже показано определение класса 32_ компонента , выбранного на рис. 4-20. обратите внимание на корреляцию свойств, перечисленных в правой секции окна браузера классов, и их определений. свойства, наследуемые классом, помечаются в желтыми стрелками, и в определении 32_ эти свойства отсутствуют.
 одно ключевое слово, на которое стоит обратить внимание в заголовке класса 32_, - . его смысл в том, что всякий раз, когда управляющее приложение запрашивает свойства объекта, инфраструктура обращается к -провайдеру за значениями соответствующих свойств, сопоставленных с объектом данного класса. статическим () считается класс, находящийся в репозитарии ; в этом случае инфраструктура получает значения свойств из репозитария и не обращается к -провайдеру. поскольку обновление репозитария - операция относительно медленная, динамические компоненты доступа более эффективны в случае объектов с часто изменяемыми свойствами.
 эксперимент: просмотр -определений -классов 
 для просмотра -определения любого -класса используйте утилиту , поставляемую с . этом эксперименте мы покажем, как увидеть -определение класса 32_.
 1. запустите через диалоговое окно (запуск программы), открываемое из меню (пуск).
 2. щелкните кнопку (подключить), измените (-) на \2 и вновь щелкните кнопку .
 3. выберите (классы), установите переключатель (рекурсивно) и нажмите ок.
 4. найдите 32_ в списке классов и дважды щелкните его, чтобы увидеть свойства этого класса.
 5. щелкните кнопку (вывести ), чтобы открыть окно с -определением.
 после создания классов на разработчики могут предоставлять их определения в несколькими способами. разработчик провайдера компилирует -файл в двоичный (), более компактную форму представления, и передает -файл инфраструктуре другой способ заключается в компиляции -файла и программной передаче определений от провайдера в инфраструктуру через функции . наконец, можно задействовать утилиту (.), чтобы передать скомпилированное представление классов непосредственно инфраструктуре .
пространство имен 
 классы определяют свойства объектов, а объекты являются экземплярами классов в системе. для иерархического упорядочения объектов использует пространство имен, в котором может содержаться несколько подпространств имен. управляющее приложение должно подключиться к пространству имен, прежде чем оно сможет получить доступ к расположенным там объектам.
 корневой каталог пространства имен называется корнем и обозначается как . каждой -системе есть четыре предопределенных пространства имен, расположенных под корнем: 2, , и некоторые из них тоже включают другие пространства. так, в 2 входят подпространства имен и _409. иногда провайдеры определяют собственные пространства имен, например в можно увидеть пространство имен (определяемое -провайдером для драйверов устройств).
 эксперимент: просмотр пространств имен 
 увидеть, какие пространства имен определены в системе, позволяет . этот браузер открывает при запуске диалоговое окно подключения, в котором справа от поля ввода пространства имен имеется кнопка для просмотра пространств имен. выбрав интересующее вас пространство имен, вы заставите подключиться к этому пространству имен. 2003 под корнемопреде-лено свыше десятка пространств имен, некоторые из которых видны на следующей иллюстрации.
 отличие от пространства имен файловой системы, которое включает иерархию каталогов и файлов, пространство имен имеет только один уровень вложения. вместо имен использует свойства объектов, которые определяет как ключи (), идентифицирующие эти объекты. указывая объект в пространстве имен, управляющие приложения сообщают имя класса и ключ. таким образом, каждый экземпляр класса уникально идентифицируется его ключом. например, компонент доступа представляет записи в журнале событий классом 32_. у этого класса есть два ключа: (строковый) и (беззнаковый целочисленный). поэтому, запрашивая у экземпляры записей журнала событий, управляющее приложение идентифицирует их парой ключей. вот пример ссылки на одну из записей:
 \\\\2:32_.="" 
 ="1" 
 первая часть имени (\\) идентифицирует компьютер, на котором находится объект, а вторая (\\2) - пространство имен, где размещен объект. имя класса следует после двоеточия, а имена ключей и их значения - после точки. значения ключей отделяются запятыми.
 предоставляет интерфейсы, позволяющие приложениям перечислять все объекты конкретного класса или выполнять запросы, которые возвращают экземпляры какого-либо класса, удовлетворяющие критериям запроса.
классы сопоставления
 многие типы объектов так или иначе связаны между собой. например, объект «компьютер» включает объекты «процессор», «программное обеспечение», «операционная система», «активный процесс» и т. д. позволяет создавать класс сопоставления ( ), представляющий логическую связь между двумя классами и поэтому имеющий всего два свойства: имя класса и модификатор . ниже показан исходный текст на , сопоставляющий классы 32_ и 32_. получив какой-то объект, управляющее приложение может запрашивать и сопоставленные объекты. благодаря таким сопоставлениям компонент доступа получает возможность определять иерархию объектов.
 рис. 4-21 показан (еще один инструмент, включаемый в ), который показывает содержимое пространства имен 2. это пространство имен обычно помещают свои объекты системные компоненты . браузер объектов сначала определяет местонахождение объекта -, экземпляра 32_-, представляющего компьютер. далее браузер получает объекты, сопоставленные с 32_ и отображает их под -. пользовательский интерфейс браузера объектов помечает сопоставленные объекты значком папки с двуглавой стрелкой.
 как видите, класс сопоставления 32_ показывается под - и существует несколько экземпляров класса 32_-. посмотрите на предыдущий листинг - вы убедитесь, что класс 32_ определен доя сопоставления классов 32_ и 32_. выбрав в браузере объектов экземпляр 32_ , вы увидите в правой секции на вкладке свойства этого класса. предоставляет , чтобы -разработчики могли изучать свои объекты, но управляющие приложения, выполняя те же операции, показывают свойства или собранные данные более наглядно.
 эксперимент: использование -сценариев для управления системами 
 сильная сторона - его поддержка языков сценариев. создала сотни сценариев, выполняющих распространенные административные задачи для управления учетными записями пользователей, файлами, реестром, процессами и аппаратными устройствами. некоторые сценарии поставляются с ресурсами , но основная их часть находится на сайте . использовать сценарий с этого сайта очень легко: достаточно скопировать его текст из окна интернет-браузера, сохранить в файле с расширением. и запустить командой ., где - имя, присвоенное вами данному сценарию. - это интерфейс командной строки для ().
 вот пример сценария из , который регистрируется на получение событий при создании экземпляров 32_ (его экземпляр создается всякий раз, когда запускается какой-либо процесс) и выводит строку с именем процесса, представляемым данным объектом:
 = 0 
 = . . .. 
 
 строке, где вызывается , этой функции передается параметр, который включает выражение из поддерживаемого подмножества -стандарта () только для чтения. это подмножество называется , и оно предоставляет -потребителям гибкий способ задания информации, которую им нужно запросить от -провайдеров. если вы запустите этот сценарий с помощью , а затем запустите , то получите следующий вывод:
 : \› . 
 () 5.6 () 1996-2001. . 
реализация 
 2000 -сервис реализован в \\32\., который запускается при первой попытке доступа управляющего приложения или -провайдера к . и 2003 -сервис работает в общем процессе , выполняемом под учетной записью локальной системы.
 2000 загружает провайдеры как внутренние (внутрипроцессные) -серверы, выполняемые внутри сервисного процесса -. если ошибка в провайдере приведет к краху процесса , -сервис завершится, а затем перезапустится в ответ на следующий запрос к поскольку -сервис разделяет свой процесс с несколькими другими сервисами, которые тоже могут завершаться при ошибке в --вайдере, вызывающей закрытие этого процесса, в и 2003 загружает провайдеры в хост-процесс .. он запускается как дочерний по отношению к сервисному процессу выполняет под учетной записью , или в зависимости от значения свойства экземпляра -объекта 32, который представляет реализацию провайдера. процесс завершается, как только провайдер удаляется из кэша, спустя минуту после приема последнего запроса к провайдеру.
 эксперимент: наблюдение за созданием 
 чтобы понаблюдать за созданием , запустите и выполните . процесс появится под процессом , который служит хостом сервиса если в включена функция выделения заданий, вы увидите, что появился не только новый процесс, но и новое задание. дело здесь вот в чем. чтобы предотвратить исчерпание всей виртуальной памяти в системе плохо написанным провайдером, запускается в объекте «задание», который ограничивает количество создаваемых дочерних процессов и объемы виртуальной памяти, допустимые для выделения каждым процессом. (об объектах «задание» см. главу 6.)
 большинство компонентов , в том числе -файлы, встроенных провайдеров и управляющих приложений, по умолчанию размещаются в каталогах \\32 и \\-32\. втором каталоге вы найдете -файл провайдера , .. там же находится и ., провайдера , используемая -сервисом.
 подкаталогах каталога \\32\ находятся репозитарий, файлы журналов и -файлы сторонних разработчиков. репозитарий, называемый репозитарием , реализуется в с применением закрытой версии ядра баз данных . 2000 база данных хранится в файле \\32\\ \.. учитывает параметры реестра (включая различные внутренние параметры в 2000 вроде расположения резервных копий файлов и интервалов между их созданием), которые хранятся в разделе \\\\.
 для обмена данными с и приема команд от него драйверы устройств используют специальные интерфейсы под общим названием . эти межплатформенные интерфейсы являются частью (см. главу 9).
 состав и 2003 входит утилита ., позволяющая взаимодействовать с из оболочки командной строки с поддержкой . через эту оболочку доступны все -объек-ты и их свойства и методы, что превращает в консоль расширенного управления системами.
защита 
 реализует защиту на уровне пространства имен. если управляющее приложение успешно подключилось к пространству имен, оно получает доступ к любым свойствам всех объектов этого пространства имен. для управления доступом пользователей к пространству имен администратор может задействовать приложение . для запуска последовательно откройте в меню (пуск) подменю (программы) и (администрирование), а затем выберите команду (управление компьютером). далее раскройте узел (службы и приложения), щелкните правой кнопкой мыши строку (управляющий элемент ) и выберите команду (свойства) для вывода диалогового окна (свойства: управляющий элемент ), которое показано на рис. 4-22. для настройки параметров защиты пространства имен перейдите на вкладку (безопасность), выберите пространство имен и щелкните кнопку (безопасность). другие вкладки диалогового окна позволяют изменять сохраняемые в реестре настройки, которые относятся к функционированию и резервному копированию.
резюме
 этому моменту мы уже рассмотрели общую структуру , базовые системные механизмы, на которые опирается эта структура, и основные механизмы управления. заложив такой фундамент, можно переходить к более подробному изучению процесса загрузки и индивидуальных компонентов исполнительной системы.﻿собираем компьютер своими руками
александр иванович ватаманюк
видеосамоучитель
новое издание популярной книги. из чего состоит компьютер и как собрать его самостоятельно, как установить операционную систему и настроить ее для удобной работы, как следить за состоянием компьютера и как его модернизировать перед вами - настоящий обучающий курс для тех, кто желает собственными руками собирать, настраивать, обслуживать и модернизировать пк.
видеокурс прилагается только к печатному изданию книги.
александр иванович ватаманюк
собираем компьютер своими руками
введение
количество компьютеров увеличивается изо дня в день - это факт. пользуясь компьютером на работе, хочется иметь его и дома. многое без него вообще невозможно, например бухгалтерская отчетность, для которой необходимы электронные бланки, или общение через интернет.
распространение и обновление компьютеров требует постоянного совершенствования знаний и навыков, поэтому пользователю просто необходимо разбираться в комплектующих и уметь устанавливать и настраивать программное обеспечение.
обзавестись компьютером можно, либо купив готовый, либо собрав его самостоятельно. второй вариант интереснее, так как позволяет познакомиться с машиной более детально. в этом случае пользователь получает немалый практический опыт, поскольку ему придется пройти весь путь - от сборки до установки и настройки операционной системы.
удачи вам в прочтении книги и применении полученных знаний на практике!
для кого предназначена книга
эта книга рассчитана на пользователей, которые хотят собрать компьютер самостоятельно. для облегчения задачи далее описано предназначение часто используемых комплектующих. издание будет полезно и опытным пользователям как источник дополнительных знаний.
составляющие компьютера, его сборка, установка и настройка операционной системы , использование прикладных программ - обо всем этом подробно рассказывается в данной книге.
теоретический материал проиллюстрирован, что облегчает восприятие информации. читатель может также увидеть процесс сборки, ознакомившись с видеороликами на прилагаемом к книге компакт-диске.
структура книги
структура издания продумана таким образом, чтобы можно было быстро найти нужную информацию.
книга разбита на четыре части, посвященные аппаратной и программной частям компьютера, установке, настройке и оптимизации операционной системы, локальной и глобальной сетям. в конце книги есть три приложения. они познакомят вас с неисправностями комплектующих компьютера, профилактическим уходом за некоторыми устройствами, а также с содержимым видеороликов, которые находятся на прилагаемом к книге компакт-диске.
глава 1. «каким должен быть компьютер». из нее вы узнаете о причинах появления компьютеров и познакомитесь с понятием «конфигурация».
глава 2. «компьютерные комплектующие». в этой большой главе описываются внутренние и внешние комплектующие, которые чаще всего устанавливаются в компьютер. вы узнаете, какие бывают корпусы, блоки питания, материнские платы, оперативная память, процессоры, принтеры, сканеры и т. д. и ознакомитесь с их назначением и принципом работы. здесь же приводятся рекомендации по выбору устройств.
глава 3. «сборка компьютера». материал данной главы очень важен, так как он описывает процесс сборки системного блока и подсоединение всех комплектующих. вы подробно узнаете о подходах, используемых при подключении того или иного устройства, что поможет вам без осложнений собрать компьютер своими руками.
глава 4. «». данная глава рассказывает о первом программном обеспечении, которое начинает работать при включении компьютера. вы узнаете о том, что такое и какие функции она выполняет. вы также научитесь настраивать , чтобы компьютер работал максимально эффективно.
глава 5. «операционные системы». в данной главе вы ознакомитесь с некоторыми операционными системами, что поможет в принятии решения, какую из них предпочесть.
глава 6. «установка ». данная глава посвящена установке важнейшей программной части компьютера - его операционной системы, в частности самой популярной сегодня .
глава 7. «настройка ». от удобства использования средств операционной системы зависит, насколько быстро вы освоите работу в ней. в данной главе рассказывается, как настроить некоторые компоненты системы .
глава 8. «безопасность операционной системы». от системы безопасности зависит, насколько долго сможет проработать ос без переустановки или восстановления. из данной главы вы узнаете, как правильно настраивать и использовать средства безопасности  - брандмауэр и защитник .
глава 9. «ускорение загрузки операционной системы». операционную систему можно заставить работать быстрее. как это сделать - читайте в данной главе.
глава 10. «ускорение работы системы и программ». к скорости работы компьютера предъявляются повышенные требования, поэтому нужно знать, каким образом можно ускорить выполнение им поставленных задач. в данной главе речь пойдет о повышении скорости работы жесткого диска и прикладных программ.
глава 11. «понятие локальной сети». эта глава познакомит вас с основными понятиями локальной сети.
глава 12. «проводная сеть». данная глава посвящена вопросам, касающимся локальных проводных сетей , и содержит информацию о типах сети, топологии, стандартах, протоколах и др.
глава 13. «беспроводная сеть». в этой главе рассказывается о беспроводных сетях - их типах, стандартах и т. д.
глава 14. «подключение к локальной сети». из данной главы вы узнаете, как применить знания о локальной сети на практике - научитесь подключаться к ней и пользоваться ее возможностями.
глава 15. «подключение к интернету». в данной главе вы поближе познакомитесь с интернетом и узнаете, как подключиться к нему, используя возможности .
от издательства
замечания, предложения и вопросы отправляйте по адресу электронной почты @.. (://:%20@../) (издательство «питер», компьютерная редакция).
будем рады узнать ваше мнение!
на сайте издательства ://.. (://../) вы найдете подробную информацию о наших книгах.
часть 
аппаратная часть компьютера
каким должен быть компьютер
компьютерные комплектующие
сборка компьютера
глава 1
каким должен быть компьютер
 немного о компьютере
 типичные конфигурации компьютера
1.1. немного о компьютере
во все времена человек пытался облегчить себе выполнение тех или иных работ, в результате чего появлялись различные приспособления. однако процессы становились все сложнее, и существующие механизмы уже не справлялись со своими задачами и не могли обеспечить эффективность их выполнения.
появление первого компьютера стало началом новой эры развития человечества.
новшества не всегда воспринимаются с энтузиазмом. появление компьютера обрадовало в основном научных работников крупных государственных и коммерческих структур, которые занимались сложными исследованиями, так как с изобретением компьютера скорость вычислений возросла в тысячи раз.
намного меньше были восхищены новинкой руководители мелких предприятий (об обычных пользователях тогда не было и речи). это неудивительно - первые компьютеры стоили сотни тысяч долларов. однако со временем компьютеры совершенствовались, и цена на них снижалась. сегодня за $1000 можно купить отличный компьютер, удовлетворяющий практически любым требованиям. именно этот факт стал решающим для массового появления электронных помощников как в офисах, так и в домах пользователей.
современные компьютеры справляются практически с любой задачей - сложными математическими вычислениями, работой с графикой, воспроизведением музыки, компьютерными играми, профессиональной обработкой звука и видео, управлением разнообразными внешними устройствами и т. д. они применяются в большинстве областей деятельности - образовании, медицине, гуманитарных науках, на производстве и т. д.
сегодня компьютер доступен всем. даже не очень обеспеченная семья может позволить себе приобрести его. практически любой студент или научный работник имеет компьютер или даже два.
вы читаете эту книгу, следовательно, также решили присоединиться к армии пользователей. осталось определиться, для чего вам нужен компьютер, и выбрать соответствующую конфигурацию.
1.2. типичные конфигурации компьютера
конфигурация - это набор комплектующих, определяющий мощность и возможности компьютера: материнская плата, процессор, жесткий диск, монитор и т. д. правильный выбор конфигурации позволяет добиться требуемого быстродействия и поддерживать его на протяжении длительного периода времени.
можно выделить основные неспециализированные сферы применения компьютера.
 офисный компьютер предназначен для использования в офисах, кассах и т. п.
 домашний компьютер является симбиозом офисного и игрового, однако по конфигурации ближе к последнему; на нем с одинаковой скоростью должны выполняться обычные задачи (работа в текстовых и табличных редакторах, просмотр видео, серфинг в интернете и т. д.) и операции, более требовательные к производительности (игры, пакеты для работы с 3-графикой и т. п.).
 игровой компьютер ориентирован на обеспечение максимального быстродействия при работе с 3-графикой, то есть в нем должны быть большая оперативная память, графический адаптер, производительный процессор (последних моделей) и объемный жесткий диск.
 компьютер для работы с графикой и обработки видео должен быть оснащен быстрым процессором (обязательно двух- или четырехъядерным), большим количеством оперативной памяти, объемным жестким диском (предпочтительнее несколькими), а также записывающим и -приводом (или двумя). видеоподсистема такого компьютера подразумевает набор из специализированной видеокарты с тв-входом и выходом (аналоговым и цифровым) контроллера , который удобно использовать для переноса на компьютер видео с цифровых видеокамер и видеомагнитофонов.
разные типы компьютеров, в частности игровой и офисный, имеют существенные различия. офисные компьютеры иногда называют бюджетными. они имеют минимальную конфигурацию - такую, чтобы можно было комфортно работать в текстовых и табличных редакторах, просматривать изображения, путешествовать по интернету, отправлять и получать сообщения и т. п. бюджетные компью теры стоят в несколько раз дешевле игровых, которые оснащаются мощными процессором и видеокартой, большим количеством оперативной памяти и т. д.
офисный компьютер
компьютер для офиса значительно отличается от других. его главные качества - строгость и надежность. офисные компьютеры могут иметь разную конфигурацию, но при этом должны удовлетворять общим требованиям.
примечание
у офисного компьютера процессор может быть медленнее, жесткий диск - меньшего объема, мышь и клавиатура - проще, чем у домашнего и тем более игрового.
эти требования просты.
 надежность. офисным компьютерам приходится работать по 10 часов в сутки и более. случайный сбой в них способен уничтожить результаты многочасового труда или парализовать работу всего офиса, особенно если рабочие документы хранятся локально, а не на выделенном сервере. подбирать комплектующие следует, отдавая предпочтение не дешевым, а стабильно работающим, однако это не означает, что нужно выбирать продукцию только известных марок.
 функциональность. конфигурация офисного компьютера должна позволять без проблем запускать все необходимые для работы программы и подключаться к локальной сети. необходим также достаточный запас производительности, чтобы можно было переходить на новые программные продукты и технологии.
 возможность модернизации. офисный компьютер должен обеспечивать выполнение работы, допуская дальнейшую модернизацию. дома модернизацией можно заниматься долго, однако в офисе она должна отнимать минимум времени (и денег), поэтому, выбирая компьютер, необходимо проверить наличие на материнской плате свободных разъемов для памяти и слотов для подключения дополнительных плат. желательно также присутствие нескольких -портов (  - универсальная последовательная шина) для подключения нескольких устройств, например принтера и сканера.
 цена. выше уже было сказано, что главной особенностью офисного компьютера должна быть низкая цена. стоимость офисного и домашнего или игрового компьютера часто различается в несколько раз.
офисные компьютеры, как правило, оснащены достаточно медленными процессорами и средними по объему жесткими дисками. на таких компьютерах успешно работают любые офисные пакеты, например или бухгалтерский пакет «1с: предприятие». модели этого класса отличаются сравнительно низкой ценой и достаточным запасом мощности. со временем на них можно поставить более мощный процессор, увеличить объем оперативной памяти или подключить периферию.
в настоящее время вместо мониторов с электронно-лучевой трубкой в офисы все чаще покупают жидкокристаллические. в табл. 1.1 приведен пример распространенной конфигурации среди компьютеров бизнес-класса, ниже которой покупать или модернизировать компьютер не рекомендуется.
таблица 1.1. конфигурация офисного компьютера
компьютер такой конфигурации позволяет сэкономить деньги на приобретении видеокарты, сетевой карты и звуковой платы.
кроме самого компьютера, не помешает приобрести принтер для печати офисных документов; если выделенного сетевого принтера в офисе нет, то наилучшим выходом будет приобретение лазерного принтера из среднего ценового диапазона.
в офисе часто возникает необходимость сканирования документов с последующим редактированием их содержимого с помощью текстового или графического редактора, поэтому стоит также приобрести планшетный сканер. сканер, принтер и ксерокс могут совмещаться в одном устройстве, которое лучше всего подойдет для автоматизации работы небольшого офиса.
домашний компьютер
домашний компьютер должен выполнять, пусть не так быстро, как специализированная система, все основные задачи. сегодня вы набираете текст, завтра - играете, послезавтра хотите посмотреть фильм, а компьютер всегда должен работать как минимум на оценку «хорошо». домашний компьютер должен удовлетворять следующим параметрам.
 универсальность. домашний компьютер не должен быть приспособлен только для решения конкретных задач. никто не знает, что придется делать на нем в будущем, поэтому система должна быть готова ко всему.
 дизайн. домашний компьютер - элемент интерьера, поэтому следует с ответственностью подойти к выбору корпуса, монитора, клавиатуры, акустической системы и других устройств, находящихся на виду. однако ради дизайна не стоит жертвовать надежностью и производительностью.
 мощность. домашний компьютер должен иметь достаточный запас производительности. игры, энциклопедии, графические редакторы, прослушивание и создание музыки, работа с видео - это динамично развивающиеся направления, а каждая новинка требует все больше ресурсов компьютера: сначала требуется дополнительный объем памяти, а затем - замена процессора и видеокарты.
в табл. 1.2 приведен пример одной из конфигураций компьютера, оптимальных для домашнего использования.
таблица 1.2. конфигурация компьютера для домашнего использования
компьютер предназначен для использования в домашних условиях, однако рано или поздно возникнет необходимость что-то распечатать, для чего подойдет струйный принтер с возможностью печати на фотобумаге. неизменным спутником домашнего компьютера также является планшетный сканер. он обязательно пригодится для сканирования чужой курсовой работы или какой-либо технической информации.
как и в случае с офисным компьютером, вместо двух устройств можно рассмотреть вариант приобретения многофункционального устройства, совмещающего струйный принтер, ксерокс и сканер.
не стоит игнорировать возможность просмотра видео высокого качества на соответствующих телевизорах, для чего используется видеокарта с возможностью просмотра -видео (  - высокая четкость).
игровой компьютер
компьютер для игр должен состоять из самых современных комплектующих, так как программ, более «прожорливых» с точки зрения ресурсов, чем игры, не существует. современные игры требуют от видеокарты поддержки высокого разрешения экрана, 32-битной палитры цветов и множество аппаратных функций обработки изображения.
игра может занимать 5-10 гбайт и дополнительное место для файла подкачки. игры часто требуют наличия оригинального или , установленного в привод. обычно диск берется в прокате или у друга, и его нужно скоро вернуть; чтобы не прерывать игру, с помощью специализированной утилиты создается образ диска, который затем подключается к виртуальному приводу. это означает, что еще несколько десятков гигабайт уходит на хранение образов, то есть на жестком диске игра требует в полтора - два раза больше места, чем ожидалось, поэтому нелишне иметь один или два жестких диска большого объема.
не последнюю роль играет процессор. особенно это заметно, когда видеокарта не справляется с поставленными задачами и передает ему часть управления, и тогда процессор выполняет большой объем работы с графикой.
в табл. 1.3 приведен пример конфигурации, обладающей достаточным запасом мощности и других ресурсов, что позволяет компьютеру справляться практически с любыми играми, и не только.
таблица 1.3. конфигурация компьютера для игр
-модем и сетевая карта необходимы для сетевых игр через интернет и для серфинга в нем. аналогово-цифровой модем нужен для игр с прямым подключением к другому модему. качественная звуковая карта, акустическая система 5.1 и хорошие наушники незаменимы для создания эффекта присутствия. руль и рукоятка необходимы для эффективного управления своими действиями в играх.
компьютер для работы с графикой и обработки видео
при выборе компьютера для обработки живого видео и звука основными критериями должны быть быстрый процессор и винчестер большого объема. именно в таких компьютерах применяются дорогие и скоростные модели -винчестеров. параллельно устанавливается жесткий диск (или несколько) с -интерфейсом для хранения больших объемов видеоинформации (табл. 1.4).
таблица 1.4. конфигурация компьютера для работы с графикой и обработки видео
в данном случае обычно используется специализированная графическая видеокарта или карта с мощным графическим процессором и встроенными видеовходом и видеовыходом. неплохой альтернативой этому будет отдельное устройство для захвата видео и звука.
для работы с графикой используется высококачественный профессиональный монитор с хорошей цветопередачей и запасом яркости и контрастности. диагональ монитора при этом должна составлять не менее 21 дюйма.
обычно используется материнская плата с интегрированным - и -контроллером (для подключения цифровых видеокамер и фотоаппарата). в случае отсутствия контроллеров устанавливаются контроллеры в виде плат расширения, поэтому материнская плата должна обладать достаточным количеством свободных -слотов (  - дословно - взаимосвязь периферийных компонентов).
в качестве периферии к такому компьютеру подключается сканер с высокой точностью распознавания и дорогой струйный принтер (или фотопринтер) для качественной распечатки изображения.
для подобного компьютера желательно наличие -привода, умеющего рисовать изображение на поверхности диска.
глава 2
компьютерные комплектующие
 внутренние устройства
 внешние устройства
2.1. внутренние устройства
компьютер представляет собой модульную конструкцию, в которую входят внутренние и внешние комплектующие. в данном разделе речь пойдет об основных внутренних устройствах.
корпус
корпус не относится к внутренним устройствам, но является местом их расположения, поэтому будет рассмотрен именно в этом разделе.
корпус представляет собой металлический или пластиковый контейнер, в который устанавливаются материнская плата, процессор, оперативная память, видеоадаптер, звуковая и сетевая карты, внутренний модем, винчестер, дисковод, /-привод и т. д.
на передней панели корпуса обычно расположены две кнопки: включения/выключения и перезагрузки. часто сюда выводятся дополнительные порты, например или , а также звуковой выход на акустическую систему и вход для микрофона.
основу корпуса составляет рама, к которой крепятся:
 блок питания;
 шасси крепления материнской платы;
 передняя панель;
 секции для 3,5- и 5,25-дюймовых устройств;
 крышка.
у современных компьютерных корпусов крышки обычно две - левая и правая (снимаются раздельно), а в ранних - одна (п-образного вида). корпусы с раздельными крышками удобнее: как правило, снимать требуется только часть, которая открывает доступ к материнской плате, установленным на ней платам расширений и задним панелям устройств хранения данных.
рама, панель крепления материнской платы, корпус блока питания и секции накопителей изготавливаются из стали (реже - из алюминия или дюралюминия), а лицевая панель - из пластика или оргстекла.
часто встречаются корпусы с легкосъемными лицевыми панелями, которые пользователи могут менять самостоятельно.
в корпусе современного компьютера сконцентрировано большое количество устройств, выделяющих тепло. особенно интенсивно это делают процессоры на материнской плате и видеокарте, модули оперативной памяти, микросхемы контроллера жесткого диска и элементы блока питания.
процессоры уже давно не работают без кулера. сегодня этим охладительным прибором оснащаются даже видеокарты и некоторые винчестеры. в современном корпусе обычно предусмотрены места для установки дополнительных вентиляторов.
верхняя часть передней панели практически любого корпуса состоит из секций, закрытых заглушками. по мере необходимости заглушки вынимаются, и их место занимают /-привод, дисковод и другие устройства. в нижней или средней части панели расположены кнопки включения/выключения и перезагрузки и панель дополнительных портов. могут также присутствовать различные -панели.
существует два основных типа корпуса: (настольный, горизонтальный) и (вертикального исполнения). кроме того, существуют промежуточные варианты, сочетающие черты обоих типов.
при выборе корпуса следует обратить внимание на:
 размер - в любой момент может потребоваться установить в корпус дополнительное (новое) оборудование;
 систему вентиляции - необходима для поддержания оптимального температурного режима работы всех комплектующих;
 внешний вид - выбирайте корпус с красивой и функциональной передней панелью, на которой присутствует дополнительная панель с -портами и аудиовходом/выходом.
сегодня выпускаются корпусы разных форм-факторов. размер корпуса в первую очередь зависит от исполнения материнской платы, а во вторую - от количества устанавливаемых в него комплектующих, мощности блока питания и способов вентиляции.
корпусы часто снабжены дверцей, полностью или частично прикрывающей переднюю панель. это не столько необходимость, сколько модная тенденция.
на компьютерном рынке присутствует огромное количество разнообразных корпусов, отличающихся размером, ориентацией, цветом и дизайном.
как показывает практика, пользователи чаще всего покупают корпусы с форм-факторами () и () . популярность этих моделей обусловлена, прежде всего, требованиями, которые диктуют современные комплектующие.
на сегодняшний день выпускаются следующие типы корпусов.
  предназначен для установки на стол. основные отличительные черты: сравнительно небольшие размеры (обычно 45 х 45 х 20 см) и горизонтальный способ расположения, благодаря чему на него можно поставить жк-монитор (рис. 2.1).
рис. 2.1. корпус типа 
главный недостаток - малая вместительность. в таких корпусах предусмотрены два 5,25-дюймовых, один или два 3,5-дюймовых отсека и устанавливаются блоки питания небольшой мощности (примерно 200 вт), что является серьезным препятствием для разгона процессора и видеокарты.
пользователи назвали эту модель бюджетной, то есть используемой преимущественно для сборки офисных компьютеров.
  (рис. 2.2) является разновидностью -корпуса и представляет собой его уменьшенную модификацию. высота такого корпуса редко превышает 8 см, что сказывается не только на формате устанавливаемой материнской платы, но и на количестве слотов для плат расширения. в корпусе присутствует только по одному внешнему 3,5- и 5,25-дюймовому отсеку. поскольку содержимое такого корпуса не может быть требовательным к мощности блока питания, то в устанавливают блоки питания мощностью не более 200 вт (как правило, 150 вт).
рис. 2.2. корпус типа 
этот тип корпуса предназначен для использования только в компьютерах с конфигурацией, которая практически не поддается модернизации. пользователи не покупают корпусы для сборки домашнего компьютера.
достоинства корпуса этого типа - вес (1,5-3 кг) и бесшумность (в устанавливается блок питания без вентилятора и организована пассивная система охлаждения видеокарты).
  имеет вертикальную ориентацию (рис. 2.3) и предназначен для установки на стол или в другое подходящее место. в свое время это был самый популярный тип корпуса, поскольку в него помещалось все необходимое оборудование.
рис. 2.3. корпус типа 
благодаря увеличенным размерам (45 х 20 х 45 см) корпус типа имеет по два-три 3,5- и 5,25-дюймовых отсека, которых вполне достаточно для подключения необходимого количества устройств.
корпусы такого типа обычно оснащаются блоками питания мощностью 250 вт, которые обеспечивают стабильную работу всех устройств. однако разгонять комплектующие можно, только постоянно следя за температурным режимом, поскольку в непродуманная и неэффективная система вентиляции.
  (рис. 2.4) продолжает модельный ряд . его основное отличие от  - большая высота (размер 50 х 20 х 45 см), что позволяет вместить один дополнительный 5,25-дюймовый отсек. увеличенное внутреннее пространство корпуса способствует улучшению вентиляции и соблюдению необходимого температурного режима.
рис. 2.4. корпуса типа 
корпусы этого типа позволяют не только легко модернизировать систему, но и разгонять комплектующие, поэтому наиболее популярны среди пользователей.
как правило, в такой корпус устанавливается блок питания мощностью от 300 вт, однако можно установить блок питания любой большей мощности. для этого в корпусе предусмотрены вентиляционные решетки и крепления для дополнительных вентиляторов.
   - еще один представитель класса (рис. 2.5). его основные характеристики: шесть-восемь 5,25-дюймовых отсеков и от двух до пяти 3,5-дюймовых (размер 65 х 20 х 48 см).
рис. 2.5. корпус типа 
компьютер с системным блоком можно использовать в качестве мощной лаборатории по обработке видео и для других целей. обычно такой корпус снабжается дополнительными вентиляторами для охлаждения комплектующих и блоком питания мощностью более 350 вт. как правило, корпус имеет откидную переднюю крышку, под которой расположены лицевые панели установленных устройств и кнопки управления компьютером.
  (рис. 2.6) достаточно специфичен и применяется только для организации серверов. размеры такого корпуса зависят от его содержимого.
рис. 2.6. корпус типа 
как правило, в нем предусмотрено от восьми до десяти 5,25-дюймовых отсеков и несколько 3,5-дюймовых. поскольку серверный системный блок достаточно тяжелый, он часто имеет колесики, позволяющие легко перемещать его по ровной поверхности.
на передней панели корпуса находятся индикаторы и другие элементы управления и контроля, а внутри - несколько (обычно два-три) дополнительных вентиляторов для охлаждения внутренних устройств.
в корпус типа обычно устанавливается блок питания мощностью не менее 400 вт (а иногда и дополнительный, чтобы повысить отказоустойчивость системы). такие корпусы имеют открывающуюся (откидывающуюся) переднюю крышку с замком, которая надежно скрывает элементы управления компьютером и устройствами хранения данных.
блок питания
современному компьютеру необходим мощный и стабильный блок питания.
основное предназначение блока питания - преобразование переменного тока высокого напряжения (110-230 в) в постоянный и стабилизированный ток низкого напряжения (12 и 5 в), который питает практически все компоненты компьютера. если какому-то из устройств требуется другое напряжение, оно либо само преобразует имеющееся питание, либо использует питание, переработанное стабилизаторами материнской платы.
без напряжения работа компьютера невозможна, поэтому к выбору блока питания следует подходить с ответственностью, особенно если планируется установка новых внутренних или внешних устройств или разгон комплектующих.
внешне блок питания выглядит как металлическая коробка (рис. 2.7), в которой расположены электронные схемы и один-два вентилятора для охлаждения самого блока. со стороны, выходящей на заднюю стенку корпуса, вентилятор закрыт решеткой, чтобы предотвратить попадание в него инородных предметов.
рис. 2.7. внешний вид блока питания
на задней стенке блока расположены разъем для подключения кабеля, выключатель напряжения и дополнительный разъем для подсоединения кабеля питания монитора. в последнее время популярны блоки питания, у которых имеется также регулятор скорости вращения вентилятора.
на передней стенке блока находится отверстие, через которое выходит пучок проводов с группами контактов,[1 - такой контакт часто называют молексом.] на которых присутствует формируемое блоком питания напряжение 5 и 12 в, и дополнительные вентиляционные отверстия, через которые теплый воздух вытягивается из корпуса и попадает на вентилятор, который в свою очередь направляет его наружу.
в дорогих блоках питания вентиляция продумана более рационально: вентиляционная решетка или отверстия находятся не на передней стенке, а на нижней. это обеспечивает более эффективное охлаждение процессора, так как нагретый воздух вытягивается прямо с радиатора.
основные требования, предъявляемые к блоку питания, - это мощность, стабильность вырабатываемого электропитания и шум вентилятора. последний фактор кажется не столь важным, однако сильный гул раздражает. во избежание этого используются специальные регуляторы скорости вращения вентилятора, а также прикрывающая его модифицированная решетка.
примечание
именно решетка в большинстве случаев является причиной шума, поскольку расположена на пути выходящего из блока питания воздуха; чтобы избавиться от этого эффекта, в блоки питания часто устанавливают сеточные решетки, которые пропускают воздух менее шумно.
от мощности блока питания напрямую зависит количество подключаемых устройств и возможность разгона комплектующих. каждое устройство использует определенный запас мощности, который небезграничен и быстро исчерпывается. учитывая требовательность современных процессоров, графических адаптеров и оперативной памяти к ресурсам, мощность блока питания - критичный фактор.
ниже (табл. 2.1) приведен пример конфигурации компьютера, ориентированного на офисное использование, и подсчитана приблизительная мощность, потребляемая его комплектующими.
таблица 2.1. потребление энергии комплектующими компьютера
в сумме получается приблизительно 250 вт. это означает, что блок питания должен не только обеспечивать такую мощность, но и иметь запас. не следует забывать о подключении -устройств, которые также отнимают у блока питания часть мощности.
в зависимости от типа корпуса, используются блоки питания от 150 вт и выше; если подходить к выбору блока питания из расчета средней конфигурации, то подходящим вариантом будет блок с минимальной мощностью 300 вт.
следует также учесть, что разгон процессора или видеокарты увеличивает потребляемую ими мощность почти вдвое, поэтому логично приобретать блок питания мощностью 350 вт. это не означает, что он будет постоянно потреблять 350 вт - используется только необходимая в определенный момент часть мощности, все остальное - это запас.
удобно использовать специальные утилиты, рассчитывающие потребляемую мощность, основываясь на реальных данных для разных комплектующих. примером такой утилиты может быть .
стабильность электропитания - это также немаловажный фактор. не зря блок питания имеет напряжения 5 и 12 в, а не 5,7 или 11,3 в. некоторые комплектующие (например, процессор) требуют питания определенной величины (например, 1,7 в). они получают его от стабилизаторов на материнской плате, которые, в свою очередь, переделывают его из питания 5 в; если электропитание нестабильно, это приводит не только к лишней нагрузке на стабилизаторы материнской платы, но и к нестабильной работе других устройств.
на основе вышеизложенного можно дать следующие рекомендации:
 приобретайте блок питания известного производителя (тогда можно быть уверенным, что компьютер будет работать стабильно);
 покупайте блок питания с запасом мощности, но не менее 300 вт (если вы не используете корпус типа или );
 выбирайте блок питания с вентиляторами, скорость вращения которых регулируется.
материнская плата
материнская плата (рис. 2.8) - главная составная часть компьютера. от ее качества, функциональности и быстродействия напрямую зависит стабильность и скорость работы системы.
рис. 2.8. внешний вид материнской платы
материнская плата определяет тип процессора и оперативной памяти, которые могут быть установлены в компьютер. от форм-фактора материнской платы также зависит количество расположенных на ней слотов расширения, интегрированных контроллеров и т. п.
выбирая материнскую плату, обратите внимание, чтобы на ней присутствовали:
 один из последних процессорных слотов (чтобы можно было использовать новые процессоры и модернизировать систему);
 слот , желательно последней спецификации с поддержкой видеокарт новейших моделей;
 как можно большее количество -слотов и разъемов для установки оперативной памяти;
 дополнительные -контроллеры, -контроллер и контроллер 802.11.
обратите внимание также на удобство расположения (в нижней части) - и -коннекторов и выбирайте платы, у которых система охлаждения системной логики организована посредством тепловых трубок.
спецификация материнских плат. спецификация определяет не только размер материнской платы, но и ее функциональные особенности, например наличие разного количества слотов шин, интегрированных контроллеров и т. д.
существуют различные форм-факторы материнских плат, отвечающие определенным спецификациям. сегодня преобладают несколько типов размеров: , , и . выпускаются также уменьшенные варианты упомянутых форматов: -, -, -, -, -, - и т. д.
знать, чем они отличаются и какие преимущества имеет каждый из них, необязательно - все форм-факторы самодостаточны и позволяют устанавливать на них необходимые платы расширения.
выше упоминалось, что форм-фактор материнской платы не только определяет ее геометрические размеры, но и задает количество слотов расширения. например, один и шесть -слотов присутствуют только на платах формата или . на платах меньшего размера количество слотов другое (четыре у - и три у -). часто один-два -слота заменяются одним или двумя слотами .
процессорное гнездо, или слот (сокет), служит для установки центрального процессора (рис. 2.9).
рис. 2.9. пример процессорного слота
в зависимости от типа процессора, сокет может иметь разные интерфейсы. еще недавно его стандартная конструкция представляла собой пластиковую площадку с множеством отверстий: в нее вставлялся процессор, который крепился с помощью небольшого сдвига верхней пластины.
сейчас в моду входят процессоры от , которые не имеют металлических выводов, а содержат только металлические площадки, куда упираются выводы процессорного слота. выбирая материнскую плату, предварительно выясните, какие процессоры можно установить в ее сокет.
системная логика (чипсет) - главный компонент платы, отвечающий за ее функционирование, а в конечном итоге и за работу всего компьютера. как правило, он состоит из нескольких микросхем (рис. 2.10).
рис. 2.10. пример микросхемы системной логики
чипсет состоит из двух мостов: северного и южного, за каждый из которых отвечает отдельная микросхема (или несколько микросхем).
в северном мосте реализован контроллер памяти, графических портов и шины . в южном - контроллер () для жестких дисков и -устройств, порты ввода/вывода и др. контроллеры. южный мост соединяется с северным с помощью -шины.
функции южного моста постоянно расширяются. в настоящее время в него входят следующие контроллеры:
 ата и ;
 ;
 '97 с шестиканальным цифровым выходом (звуковой);
  (сетевой);
 1394 ();
 ;
 .
от модели чипсета зависят все основные характеристики платы: поддерживаемые процессоры и память, тип системной шины, порты для подключения внешних и внутренних устройств, различные дополнительные возможности (например, интегрированный звук или графическое ядро). современные чипсеты включают в себя множество встроенных контроллеров (для подключения жесткого диска, шины , портов ввода/вывода и др.), что удешевляет компьютер и облегчает его сборку и использование. иногда можно обойтись вообще без плат расширения, так как все необходимое есть в микросхемах системной логики.
все группы чипсетов развиваются параллельно и обеспечивают для своих процессоров примерно равные функциональные возможности. наибольшую популярность приобрели чипсеты, поддерживающие процессоры с интерфейсом 939 () и 775 ().
при покупке новой материнской платы необходимо узнать технические характеристики чипсета, чтобы быть уверенным, что при модернизации связка материнская плата - процессор - оперативная память будет работать в полную мощность.
микросхема . ( /  - базовая система ввода/вывода) - это программное обеспечение, которое начинает работать сразу после включения компьютера. в содержатся параметры конфигурации и настройки материнской платы и всех установленных и подключенных к ней устройств.
как правило, хранится в одной микросхеме, хотя на многих современных материнских платах присутствуют две (рис. 2.11). это подстраховка - данное сочетание позволяет загрузить компьютер в случае, если какая-то из микросхем будет повреждена, а также скопировать содержимое одной на другую (например, после неудачной перепрошивки можно восстановить главную из резервной копии).
рис. 2.11. микросхема в дублирующем исполнении ( )
слоты оперативной памяти предназначены для установки модулей оперативной памяти. разъемы могут иметь разное количество контактов, что зависит от типа поддерживаемой оперативной памяти, и снабжаются специальными защелками, которые удерживают модули в слоте.
производители оснащают материнские платы различным количеством слотов для памяти (как правило, не менее двух). более дорогие материнские платы имеют четыре или шесть разъемов (рис. 2.12).
рис. 2.12. внешний вид слотов для оперативной памяти
сегодня используется несколько типов памяти, однако наиболее популярны модули стандарта 2 и 3. при покупке оперативной памяти нужно учитывать, что материнская плата не способна эффективно работать с разными типами памяти. кроме того, конструкция слотов такова, что другие модули могут просто в них не установиться.
слоты плат расширений предназначены для установки различных плат расширения, например видеоадаптера, звуковой карты, -контроллера, модема и т. п.
в настоящее время повсеместно используются -, и - и -шина,[2 - употребляются также названия , -, -.] их слоты можно найти на материнской плате.
на сегодня (рис. 2.13) - это самая быстродействующая и функциональная шина, позволяющая устанавливать две видеокарты вместо одной и выводить изображение одновременно на четыре монитора. геймерам в паре с двух- или четырехъядерным процессором позволяет позволяет достичь максимального быстродействия в играх.
рис. 2.13. слоты спецификации 16х (вверху и внизу) и 1х (в центре)
производители уже представили несколько разных версий этой шины, последняя из которых, 16, позволяет передавать данные со скоростью до 4 гбайт/с (по 250 мбайт/с на каждую линию).
в -слот (рис. 2.14), спецификаций шины которого также существует достаточно много,[3 - последняя спецификация шины 8 позволяет передавать данные со скоростью 2 гбайт/с.] устанавливается видеокарта, а в -слоты (рис. 2.15) - любые устройства, в том числе устаревшие модели видеоадаптеров.
рис. 2.14. слот 
рис. 2.15. слоты 
количество слотов расширения может быть различным и зависит от форм-фактора материнской платы и ее функционального предназначения. лучше приобретать плату со всеми возможными слотами - это повышает вероятность того, что при модернизации компьютера не придется покупать новую. однако выбрать между - и -слотом нужно заранее, поскольку на материнской плате обычно присутствует только один из них.
коннекторы и разъемы служат для подключения шлейфов данных и проводов питания устройств.
в зависимости от типа и предназначения, разъемы имеют различную форму. изначально на материнской плате присутствуют разъемы для подключения - или -устройств, -разъем (рис. 2.16), разъем для подключения питания материнской платы и разъемы для вентиляторов. кроме того, могут присутствовать -разъемы, разъемы для подключения сетевого кабеля, разъемы для присоединения выхода звуковой карты, дополнительных портов, средств индикации и т. п.
рис. 2.16. -разъемы (вверху) и -разъем (внизу)
количество разъемов может быть различным и зависит от типа материнской платы. серверные и дорогие материнские платы содержат большее количество -, - или -разъемов, чем материнские платы, предназначенные для использования в офисных компьютерах.
локальные порты предназначены для подключения к ним периферийных устройств, например модема, принтера, сканера, веб-камеры и т. д. на любой материнской плате присутствуют порты следующих типов.
 , или параллельный порт (рис. 2.17), представляет собой полнодуплексный порт, через который сигнал передается в двух направлениях по восьми параллельным линиям. скорость передачи данных - от 800 кбит/с до 16 мбит/с в зависимости от настроек в . параллельные порты обозначаются индексами 1, 2 и т. д.
рис. 2.17. -порт
в настоящее время данный тип порта практически не используется - на смену ему пришел более скоростной и функциональный -порт. многие производители материнских плат не выводят его разъем на -панель, однако оставляют возможность подключения к соответствующему -разъему на самой материнской плате.
 , или последовательный порт, - полудуплексный порт, через который данные передаются последовательно или сериями в одном направлении в каждый момент времени (сначала в одну, потом в другую сторону). максимальная скорость - 115 кбит/с. последовательные порты обозначаются индексами 1, 2 и т. д. к -порту подключаются устройства, которые не требуют высокой скорости передачи данных, например мышь, модем, джойстик и т. п.
устаревшие материнские платы оснащались двумя такими портами, которые отличались количеством контактов; современные имеют один девятиконтактный -порт (или два одинаковых) (рис. 2.18).
рис. 2.18. 9-контактный -порт
на сегодня этот порт используется все реже из-за скоростной ограниченности, и в скором времени он исчезнет так же, как и -порт.
  (рис. 2.19) - наиболее универсальный и часто используемый порт. данные по могут передаваться в асинхронном и синхронном режимах. теоретическая скорость - от 12 до 480 мбит/с (в зависимости от спецификации порта[4 - существуют две спецификации -порта, последней из которых является 2.0. ведется разработка новой спецификации, которая позволит передавать данные со скоростью более 1 гбит/с.]).
рис. 2.19. -порты (вверху) и -коннекторы (внизу)
к -порту можно подключать разнообразные устройства - от мыши до цифровой видеокамеры. теоретически к одному компьютеру через цепочку концентраторов можно подсоединить до 127 -устройств. на практике существует проблема: подключение большого количества устройств требует достаточного запаса мощности блока питания, поэтому к компьютеру, как правило, подключаются только два - принтер и сканер.
важная особенность -портов - поддержка технологии : все присоединенные к -порту устройства конфигурируются автоматически, то есть для них не нужно устанавливать драйверы, компьютер сделает это сам.
обычно на материнской плате присутствуют не менее двух -портов. на хороших материнских платах их может быть шесть-восемь.
 /2 - параллельный порт, используемый для подключения мыши и клавиатуры. по функциональности он практически идентичен -порту, однако он быстрее и компактнее (рис. 2.20).
рис. 2.20. /2-порт (слева) и /2-коннектор (справа)
на любой материнской плате есть два таких порта. в большем количестве нет необходимости, поскольку подключение нескольких клавиатур и мышей не нужно и не осуществимо на аппаратном уровне.
 е1394, или , - последовательный порт, способный передавать данные со скоростью более 400 мбит/с, который используется для подключения к компьютеру цифровых видеоустройств, требующих максимально быстрой передачи большого объема информации. часто к такому порту подсоединяют беспроводные сетевые адаптеры (карты, мосты, маршрутизаторы, точки доступа и т. п.).
порты бывают двух типов. в большинстве настольных компьютеров используются шестиконтактные, а в ноутбуках - четырехконтактные (рис. 2.21).
рис. 2.21. 6-контактный порт (слева вверху), 4-контактный порт (справа вверху) и контроллер с двумя портами (справа внизу)
на материнских платах обычно присутствуют два либо четыре порта 1394.
 -порт, предназначенный для подсоединения компьютера к локальной сети. на любой материнской плате присутствует интегрированный сетевой контроллер, рассчитанный на подключение сетевого кабеля с разъемом -45. такой контроллер способен обеспечивать функционирование сети со скоростью 10/100 мбит/с, хотя все чаще встречаются контроллеры со скоростью работы 100/1000 мбит/с сетевого стандарта 802.3 (проводная сеть). выпускаются материнские платы, имеющие два интегрированных сетевых контроллера (рис. 2.22).
рис. 2.22. интегрированный сетевой контроллер (два правых верхних гнезда)
некоторые производители оснащают материнские платы интегрированным контроллером стандарта 802.11 (беспроводная сеть), что является безусловным плюсом.
аккумуляторная батарея питает -память, в которой хранятся настройки пользователя, сделанные с помощью .
батарея имеет плоскую форму и похожа на таблетку (рис. 2.23). для ее установки предназначено специальное гнездо с защелкой.
рис. 2.23. аккумуляторная батарея
срок службы хорошей аккумуляторной батареи - не менее трех лет.
к выбору материнской платы необходимо подходить продуманно, поскольку именно от нее зависит не только работа остальных устройств, но и возможность дальнейшей модернизации компьютера. старайтесь выбирать материнскую плату, которая имеет современный чипсет.
процессор
процессор ( , ) - это один из основных компонентов компьютера, который выполняет арифметические и логические операции, заданные программой.
процессор (рис. 2.24) представляет собой интегральную микросхему (пластину кристаллического кремния прямоугольной формы), на которой размещены электронные блоки, реализующие его функции. кристалл-пластинка обычно помещается в плоский керамический корпус и соединяется золотыми (медными) проводниками с металлическими штырями (выводами, с помощью которых процессор входит в процессорное гнездо на материнской плате компьютера) или металлическими площадками (сами выводы уже содержатся в процессорном слоте).
рис. 2.24. процессор: лицевая (слева) и оборотная (справа) стороны
процессор имеет множество характеристик, с помощью которых можно сравнивать различные модели процессоров от разных производителей. наличие нескольких производителей влияет на разнообразие характеристик процессора, поскольку вступают в силу патенты на технологии, которые не могут повторяться производителями.
в настоящее время на рынке присутствует только два реальных производителя процессоров - и .
вот некоторые представители этих типов: , 2 , , 64 2 и др. они отличаются интерфейсом, используемыми технологиями (алгоритмами, количеством ядер) и быстродействием.
рынок предлагает большой выбор процессоров разной частоты, начиная с младших (более дешевых) моделей и заканчивая моделями высшей категории, содержащими несколько ядер.
выпускаются процессоры трех видов - для персональных компьютеров, для серверов и для переносных устройств (ноутбуков, кпк, и др.). процессоры третьего направления характеризуются уменьшенным потреблением энергии, что важно для данного типа устройств.
быстродействие процессора зависит от многих факторов, основными из которых являются шины обмена информацией, частота работы ядра, наличие расширений стандартных инструкций, тип и размер кэш-памяти, пропускная способность контроллера памяти, аппаратные технологии ядра и др. некоторые из них рассмотрены далее.
частота ядра
частота ядра - это показатель, влияющий на скорость выполнения команд процессором. она не характеризует его быстродействие: в зависимости от конструкции ядра и его наполнения различными аппаратными блоками, ядро за один такт способно выполнять разное количество команд, поэтому бывает, что процессоры с разной частотой имеют одинаковую производительность.
по умолчанию единицей одного такта считается 1 гц. это означает, что при частоте 1 ггц ядро процессора выполняет 1 млрд тактов. теоретически, если считать, что за один такт ядро выполняет одну операцию, скорость работы процессора составляет 1 млрд операций в секунду. на практике этот показатель вычислить сложно, поскольку на него влияет количество выполняемых за такт операций, сложность операции, пропускная способность шин кэш-памяти и оперативной памяти и т. д.
шины. этот термин следует понимать как некоторый канал с определенными характеристиками, через который процессор обменивается данными с остальными компонентами. примером может быть канал, по которому идет обмен данными с кэш-памятью, контроллером памяти, видеокартой, жестким диском и т. д.
главными характеристиками шины являются ее разрядность и частота работы: чем они выше, тем больше данных проходит через нее за единицу времени, а значит, больше будет обработано процессором или другим компонентом. к примеру, процессоры имеют несколько подобных шин (внешних и внутренних), которые работают на разных частотах и имеют различную разрядность. это связано с технологическими особенностями, поскольку не все компоненты способны функционировать с частотой самой быстрой шины.
именно здесь кроется первая и главная ошибка многих пользователей, которые считают, что частота процессора является показателем скорости его работы. на самом деле все зависит от пропускной способности шины. например, если предположить, что за один такт ядра передается 64 бит или 8 байт информации (64-битный процессор) и частота шины составляет 100 мгц, пропускная способность шины составит 8 байт х 100 000 000 тактов, что равно приблизительно 763 мбайт. в то же время частота ядра процессора может быть в несколько раз выше, что означает, что при достижении этого показателя оставшийся запас скорости процессора простаивает.
с другой стороны, существуют шины, например между процессором и кэш-памятью первого уровня, которые позволяют наиболее эффективно обмениваться данными, что достигается за счет их работы на одной частоте.
разрядность. разрядность процессора определяет количество информации, которое он может обработать за один такт: чем она выше, тем больше информации он сможет обработать. однако это не означает, что скорость процессора повышается. разрядность влияет на объем адресуемых данных (а, соответственно, и на объем используемой оперативной памяти), хотя может повышать и скорость выполнения целочисленных операций. разрядность процессора тесно связана с разрядностью модулей оперативной памяти.
стоит отметить, что разрядность процессора не означает, что он работает именно с ней. это просто обозначает, что он может выполнять, к примеру, 64-битные команды, а в то же время работать с разрядностью 80 или 128 бит при операциях с плавающей точкой.
на сегодня используются 32- и 64-разрядные процессоры. при этом если раньше 64-битные процессоры использовались только в серверных решениях, то теперь они часто встречаются в обычных компьютерах.
кэш-память. скорость работы процессора определяется скоростью работы всех его участков, которая зависит от их аппаратных возможностей и пропускных способностей соответствующих шин данных. предвидя такую ситуацию, производители процессоров с целью максимально ускорить работу аппаратных блоков изобрели и внедрили кэш-память.
главное отличие кэш-памяти от оперативной памяти компьютера - скорость работы. на практике скорость работы кэш-памяти в десятки раз выше скорости работы оперативной памяти, что связано с технологическим процессом их изготовления и условиями функционирования.
существует несколько типов кэш-памяти. наиболее быстрой является кэш-память первого уровня, затем - второго и третьего. обязательными обычно являются только первые две позиции, хотя можно сделать кэш-память четвертого, пятого уровня и т. д. в любом случае эта память будет быстрее оперативной.
размер кэш-памяти может быть разным - в зависимости от модели процессора и его производителя. обычно размер кэш-памяти первого уровня значительно меньше второго или третьего. кроме того, кэш-память первого уровня самая быстродействующая, поскольку работает на частоте ядра процессора.
размер кэш-памяти процессоров заметно больше, чем . это связано с алгоритмом работы кэш-памяти. у процессоров кэш-память имеет эксклюзивный тип, то есть в памяти любого уровня содержатся только уникальные данные. кэш-память процессоров может хранить повторяющиеся данные, что объясняет ее увеличенный размер.
кэш-память, как и обычная, имеет разрядность, от которой зависит ее быстродействие, поскольку большая разрядность позволяет передавать больше данных за один такт. процессоры различных производителей работают с кэш-памятью по-разному: одни используют большую разрядность, например 256 бит, вторые - малую, но в режиме одновременного чтения и записи.
количество ядер. недавно на рынке процессоров появились модели, содержащие несколько ядер. в отличие от виртуальных ядер, которые предлагает технология , на процессорной пластине располагается несколько физических ядер. на сегодня получают распространение процессоры, у которых имеется четыре независимых ядра.
первые двухъядерные процессоры имели два независимых ядра, то есть ядра с одинаковым строением, включая кэш-память первого и второго уровня. сегодня ядра имеют общую кэш-память второго уровня, что позволяет увеличить производительность процессора.
использование многоядерного процессора дает заметное повышение производительности компьютера. такой процессор практически невозможно загрузить работой на 100 % из-за некоторых технологических аспектов. это означает, что ситуация, когда приложение настолько заняло процессор, что компьютер не реагирует ни на какие действия и его приходится перезагружать с помощью кнопки , не возникнет.
производительность процессора не всегда увеличивается: использование нескольких ядер подразумевает соответствующие приложения. на сегодня достаточно мало приложений, написанных с учетом многоядерности. это означает, что обычно загружается только одно ядро. однако многоядерность обязательно будет востребована.
маркировка. раньше процессоры можно было легко идентифицировать по названию и тактовой частоте. однако с появлением процессоров с разной архитектурой (разными ядрами) подобная маркировка процессоров оказалась малоэффективной. неразберихи добавили также процессоры , которые в качестве тактовой частоты используют -рейтинг, а не реальную частоту процессора.
сейчас существует определенный способ маркировки процессоров , который можно расшифровать по таблице соответствий. для процессоров подобная маркировка пока не используется.
интерфейс. этот термин означает конструкцию процессора, которая, в свою очередь, определяет особую форму процессорного слота на материнской плате.
за время существования процессоров сменилось множество процессорных слотов, что было вызвано постоянным усложнением конструкции процессора и увеличением количества контактов на его пластине. процессоры разных производителей также имеют различное количество контактов.
несколько лет назад была введена маркировка для процессоров , которая сменила показатель частоты процессора на незнакомый пользователям, но понятный производителям номер. процессоры придерживаются старого способа маркировки, который включает название процессора, его -рейтинг и дополнительный код из цифр и букв, с помощью которого можно узнать о ядре, технологическом процессе, степпингах и других показателях.
система охлаждения
при повышении температуры любые электронные составляющие могут выйти из строя.[5 - с помощью можно установить защиту процессора от перегрева путем автоматического понижения тактовой частоты. можно также настроить автоматическое отключение компьютера при достижении процессором критической температуры.] в первую очередь это касается процессора.
современные процессоры сильно нагреваются, особенно те, которые созданы с применением устаревших технологий. тепловыделение таких процессоров может составлять до 130 вт. именно поэтому важно обеспечить эффективную систему охлаждения.
до недавнего времени существовал один способ охлаждения процессора - применение радиаторов. для охлаждения радиатора использовался вентилятор. сегодня эту проблему можно решить несколькими способами.
воздушное охлаждение применяется в 90 % компьютеров. для охлаждения процессора используется радиатор, который, в свою очередь, охлаждается закрепленным на нем вентилятором с высокой скоростью вращения. в сборке такое устройство называется кулером (рис. 2.25).
рис. 2.25. кулер
сам по себе радиатор не охлаждает процессор, а только увеличивает площадь рассеивания тепла и создает условия для эффективного прохождения воздуха, поступающего от вентилятора.
что касается материала, то наибольшой популярностью пользуются медные радиаторы, которые позволяют рассеивать тепло на 20-30 % эффективнее, чем алюминиевые.
в последнее время часто используется воздушное охлаждение с применением тепловых трубок. тепловая трубка - это герметичное устройство с теплоносителем, которое позволяет переносить тепло, используя для этого молекулярный механизм переноса пара.
на практике это выглядит следующим образом. нагретый, например, радиатором процессора теплоноситель (жидкость) тепловой трубы превращается в пар и переносится в ее холодную часть, где конденсируется и охлаждается, после чего возвращается в исходную точку. получается замкнутый цикл и практически безупречная и вечная система.
конструкция охлаждающей системы с применением тепловых трубок может быть различной - в зависимости от количества переносимого тепла и наличия свободного места для ее организации. однако чем больше тепловых трубок участвует в системе охлаждения, тем больше рассеивается тепла.
подобная система охлаждения, реализованная для процессора, напоминает обычный кулер, только большего размера (рис. 2.26), и устанавливается, как правило, в мощные рабочие станции и серверы. ее предпочитают любители экстремального разгона.
рис. 2.26. кулер на основе тепловых трубок
жидкостное охлаждение применяется сравнительно давно. существует несколько его способов. один из них заключается в следующем. на процессор устанавливается металлический радиатор, представляющий собой теплообменник особой конструкции (рис. 2.27): металлическая трубка определенное количество раз изгибается внутри радиатора, покрывая всю его площадь. к концам трубки присоединяется водяная помпа, которая с некоторой скоростью перекачивает дистиллированную воду или другую жидкость. холодная жидкость, протекая через трубку в теплообменнике, охлаждает его и одновременно процессор. далее вода попадает в специальный резервуар, снабженный одним или двумя вентиляторами, где охлаждается для следующего цикла. подбирая скорость перекачивания воды, конструкцию теплообменника и его охлаждение, можно добиться максимальной производительности системы.
рис. 2.27. теплообменник системы водяного охлаждения
установить водяную систему охлаждения в системный блок просто, что привлекает многих, кто увлекается разгоном. таким способом можно параллельно охлаждать процессор и память на графическом адаптере, которые также сильно нагреваются.
примечание
использование водяного охлаждения несет в себе потенциальную угрозу. при нарушении целостности конструкции вода может попасть на электрические схемы, что приведет к замыканию, последствия которого непредсказуемы.
в продаже сегодня имеется множество наборов водяного охлаждения, которые сопровождаются инструкцией по сборке.
минус системы жидкостного охлаждения - высокая стоимость, однако для любителей игр это не препятствие.
оперативная память
оперативная память - одно из устройств, от объема и скорости работы которого зависит быстродействие всего компьютера. ее задача - своевременное предоставление процессору необходимой информации.
наиболее популярны модули памяти 2 (рис. 2.28).
рис. 2.28. модули оперативной памяти 2 
этот стандарт обеспечивает параллельную передачу данных в двух направлениях, используя 64-битную шину. за один такт 2 передает в два раза больше информации, чем . технологические нововведения позволяют уменьшить потребление энергии.
на рынке начали встречаться модули памяти стандарта 3, которые имеют еще большую пропускную способность. однако в результате тестов заметной разницы в производительности модулей 2 и 3 не обнаружено, поскольку модули 3 имеют большие тайминги. кроме того, использование таких модулей памяти требует наличия самых новых чипсетов и, соответственно, материнской платы.
при выборе типа оперативной памяти следует помнить, что ее должна поддерживать материнская плата, поэтому перед приобретением модулей необходимо обратиться к справочной информации, прилагаемой к материнской плате. стоит также учитывать, что современные материнские платы умеют работать с оперативной памятью в двухканальном режиме, позволяя добиться прироста производительности, но чтобы память заработала в таком режиме, требуется парное число модулей, например два модуля по 512 мбайт, и установка их в соответствующие слоты памяти.
видеокарта
для любителей трехмерных игр видеокарта - главное устройство. именно от нее в 90 % случаев зависит скорость работы в этих приложениях, хотя многие пользователи полагают, что самое важное - процессор.
видеокарта (рис. 2.29) служит для формирования и вывода на монитор изображения 2 (двухмерного, плоского) и 3 (объемного). от нее зависит качество изображения на экране и скорость воспроизведения графики.
рис. 2.29. видеокарта
особенно критична скорость работы с трехмерной графикой, поскольку все современные игры и графические программы для обработки сложных 3-объектов используют аппаратные возможности видеокарты.
на производительность графической подсистемы компьютера влияет множество показателей, основными среди которых являются:
 скорость шины данных, по которой передается видеоинформация;
 скорость установленной на видеокарте видеопамяти;
 объем установленной видеопамяти;
 скорость графического процессора и сопроцессора;
 аппаратные технологии работы с 3-графикой.
на скорость работы видеокарты также влияет центральный процессор, но современные графические адаптеры используют его ресурсы крайне слабо, поскольку имеют собственный, не менее производительный графический процессор.
важной составляющей видеокарты является графический чипсет, от которого зависит набор технологий и инструкций, используемый графическим процессором для обработки информации: чем больше информации сможет обработать графический процессор на аппаратном уровне, тем меньше придется работать центральному процессору, доделывая работу на программном уровне, а следовательно, тем быстрее будет работать видеоподсистема компьютера.
разрешение выводимого изображения. разрешение, с которым видеокарта выводит изображение на экран монитора, влияет на качество картинки. пользователю вряд ли понравится изображение с прорехами.
разрешение определяется количеством точек (пикселов), одновременно отображающихся на экране. например, для 15-дюймовых мониторов стандартным считается разрешение 1024 х 768, для 17-дюймовых - 1280 х 1024, для 19-дюймовых - 1600 х 1200 и т. д.
примечание
видеокарта способна формировать изображение и более высокого разрешения, однако все зависит от возможностей монитора, которые пока далеки от возможностей видеокарты.
глубина цвета. под глубиной цвета подразумевается количество одновременно выводимых цветов: чем их больше, тем реалистичнее изображение.
глубина цвета может быть любой, однако на практике используются показатели, созданные по конкретной формуле. с помощью 1 бита отображается два цвета - черный и белый, с помощью 2 бит - четыре цвета и т. д. в итоге получается арифметическая зависимость 2, где - количество бит.
сегодня официально принятым считается цвет глубиной 32 бит, который позволяет передавать несколько миллионов оттенков, чего достаточно для вывода фотореалистичных изображений.
объем видеопамяти. для обработки видеоданных графическому процессору необходим некоторый объем видеопамяти, где он смог бы хранить их. это особенно важно при формировании и обработке сложных трехмерных объектов.
подсчитать затраты памяти, которая расходуется для отображения двухмерной информации, просто: нужно умножить текущее разрешение на глубину цвета, например 1280 х 1024 х 32 = 41 943 040 бит = 5120 кбайт = 5 мбайт. получается немного, если просто смотреть на изображение рабочего стола или рисовать в редакторе . однако в играх, где прорисовка даже простого объекта требует несколько мегабайт памяти, ресурсы расходуются быстро. можно сделать вывод, что чем больше памяти, тем быстрее обрабатывается и выводится на экран графика.
в видеоадаптерах используется динамическая память с произвольным доступом, которая является самой эффективной, поскольку позволяет передавать данные в две стороны за один такт процессора. современные видеокарты оснащаются памятью , время доступа к которой составляет 0,6-2 нс.
в настоящее время наибольшее распространение получили видеоадаптеры с объемом памяти 256 мбайт. любители максимального комфорта покупают видеокарты с объемом памяти 512 мбайт.
при выборе видеокарты следует в первую очередь обратить внимание на чипсет и объем памяти; если вы планируете разгонять видеокарту, лучше остановиться на моделях с активной системой охлаждения, то есть с вентилятором.
винчестер
жесткий диск ( , ), или винчестер, предназначен для постоянного хранения информации, используемой при работе с компьютером, и быстрого доступа к ней. это могут быть самые различные данные - документы, видео, аудио, базы данных и др.
винчестер выглядит как металлическая коробка высотой 2-4 см и устанавливается в 3,5- или 5,25-дюймовый отсек компьютера (рис. 2.30).
рис. 2.30. винчестер (вид сверху и снизу)
внутри винчестера находятся одна или несколько пластин (дисков), на которые записывается информация. данные записываются и считываются блоком магнитных головок, которые, не соприкасаясь, скользят над пластинами. передвигает этот блок высокоточный шаговый двигатель, которым управляет интегрированный контроллер.
в рабочем состоянии пластины постоянно вращаются; чем выше скорость их вращения, тем быстрее считывается и записывается информация. сегодня наиболее распространены винчестеры со следующими скоростями вращения:
 7200 об/мин - для - и -дисков;
 10 000-15 000 об/мин - для -дисков.
жесткие диски отличаются интерфейсом, объемом, скоростью вращения пластин, кэш-буфером, временем позиционирования, временем поиска и другими параметрами. выбирая жесткий диск, в первую очередь нужно руководствоваться первыми двумя из вышеперечисленных параметров: от интерфейса зависит скорость обмена между винчестером и контроллером материнской платы; что касается объема, сегодня встречаются модели с объемом 1 тбайт (1024 гбайт).
чем меньше временные характеристики винчестера, тем быстрее жесткий диск реагирует на поступающие команды, а значит, придется меньше ждать, записывая и считывая большие объемы информации.
сегодня наиболее распространены три типа интерфейсов, каждый из которых имеет свои преимущества и недостатки.
  - один из первых интерфейсов, завоевавший популярность благодаря простоте, дешевизне и достаточной эффективности. -контроллер встраивается в жесткий диск, что избавляет от необходимости приобретать дополнительные платы расширения.
за все время существования -интерфейса было разработано множество стандартов, описывающих правила и скорость обмена данными между контроллерами винчестера и материнской платы. наибольшее распространение получили спецификации /100 и /133, которые позволяют передавать данные со скоростью 100 и 133 мбайт/с.
-устройства чаще всего используются в рабочих компьютерах пользователей, поскольку интерфейс имеет ряд ограничений.
для подключения -устройств к материнской плате используется 80-жильный шлейф. как правило, на материнской плате присутствует от одного до четырех -разъемов.
  - тип интерфейса, который появился в результате развития -интерфейса. работа над его созданием началась в 1999 году. в итоге была выпущена спецификация, которая позволяла передавать данные со скоростью до 150 мбайт/с. затем появилась еще одна спецификация, имеющая пропускную способность вдвое выше. в настоящий момент ведется разработка спецификации -3, скоростные показатели которой достигнут 600 мбайт/с. однако практика показывает, что скорость чтения информации с физического диска винчестера далека от теоретически возможной, поэтому дальнейшее развитие спецификации интерфейса не даст заметных результатов, пока не будет увеличена реальная скорость считывания данных.
на всех современных материнских платах присутствуют коннекторы для подключения -винчестеров с помощью четырехпроводного шлейфа. их количество может быть различным, но, как правило, таких коннекторов два-четыре (с возможностью создания -массива).
  - интерфейс, который развивался параллельно с -интерфейсом и изначально использовался в серверах. современные -контроллеры поддерживают скорость передачи данных до 320 мбайт/с (что значительно выше, чем у аналогичных -устройств). -интерфейс обладает неоспоримыми преимуществами, среди которых - возможность параллельного считывания информации с нескольких накопителей, поддержка большого количества накопителей, высокая надежность и т. д.
при всех достоинствах,  - дорогой интерфейс. кроме того, для использования -винчестера необходим соответствующий контроллер, который также стоит недешево. однако для обработки видео такой винчестер очень пригодится.
при выборе жесткого диска главными критериями должны быть скорость чтения/записи информации и объем диска. стоит также рассмотреть модели винчестеров, которые имеют наименьший уровень шума при работе.
что касается выбора интерфейса жесткого диска, то все зависит от того, где будет использоваться винчестер. в любом случае, -винчестер предполагает отличную производительность.
приводы компакт-дисков и 
современный компьютер невозможно представить без /-привода, поскольку практически вся информации (не учитывая интернет) распространяется именно на оптических носителях.
объем первых компакт-дисков составлял 650 мбайт. они предназначались для любителей высококачественной музыки. позже компакт-диски стали использоваться для записи и хранения компьютерных данных.
со временем появились более вместительные диски (), которые позволяли записывать до 4,7 гбайт информации. как и , изначально использовались в мультимедийных целях - для распространения высококачественного видео. на современные можно вместить около 17 гбайт информации, которая записывается в разные слои диска и на обе его стороны.
для считывания информации с и используются устройства /, для записи данных - приводы /-.
сегодня -приводы устанавливаются в компьютеры редко, так как любой -привод кроме дисков своего формата умеет читать и записывать информацию на . существенную роль сыграл и тот факт, что цена на -приводы значительно снизилась.
внешне приводы и практически не отличаются. они выглядят как металлическая коробка, имеющая выдвижной лоток (рис. 2.31).
рис. 2.31. -привод
как и винчестеры, разные модели приводов / отличаются техническими показателями - скоростью считывания информации с дисков, скоростью записи одноразовых и перезаписываемых и , временем позиционирования лазера, кэш-буфером, поддерживаемыми форматами и др.
под скоростью работы привода (единицы измерения - кбайт/с) подразумевается объем данных, передаваемых за единицу времени. с компакт-дисков информация считывается с базовой скоростью 150 кбайт/с. надпись 52х на корпусе означает 52-кратную скорость считывания, которая равняется 52 х 150 кбайт/с = 7800 кбайт/с. для обеспечения такой скорости привод 52х вращает диск со скоростью 7200 об/мин.
однако скорость передачи данных - не единственный показатель. существует такой параметр, как время доступа. оно равно времени задержки между получением команды и началом считывания с диска. данный параметр принимает среднее значение, поскольку с различных областей на диске информация считывается с разной скоростью. время доступа измеряется в миллисекундах и является величиной, обратно пропорциональной скорости передачи данных: чем выше скорость, тем меньше время доступа.
скорость считывания и записи информации отличаются (особенно это касается ), что объясняется сложностью реализации процесса записи, который требует от рабочего лазера больших временных затрат.
при выборе /-привода желательно остановиться на продукции известного производителя. обязательно убедитесь в том, что привод способен работать со всеми существующими форматами. это позволит записывать максимально возможные для выбранного носителя объемы информации.
звуковая карта
компьютер давно превратился в мультимедийный центр. во многом это обусловлено появлением множества мультимедийных и игровых приложений. мультимедийный центр невозможно представить без хорошего звукового контроллера и качественной акустической системы.
звуковая карта - это устройство, состоящее из звукового процессора и других вспомогательных компонентов, с помощью которых формируется звуковой сигнал необходимого уровня и окраски.
звуковые карты выпускаются в различном исполнении - в виде интегрированного в материнскую плату решения или карты расширения, устанавливаемой в -слот (рис. 2.32). часто встречаются внешние решения - профессиональные высококачественные звуковые устройства.
рис. 2.32. звуковая плата в виде карты расширения
качество интегрированных звуковых контроллеров постоянно улучшается, поэтому необходимость в звуковых платах, устанавливаемых в слот, отпадает. однако бытует мнение, что такие звуковые платы качественнее.
все звуковые адаптеры, независимо от их исполнения, имеют стандартный набор выходов и контактов, к которым подключается акустическая система или внешний усилитель. хорошие звуковые карты, кроме трех стандартных разъемов - микрофонного, акустического и линейного, оснащаются дополнительными. в частности, если звуковая карта поддерживает спецификацию 5.1 и выше, то на ней могут присутствовать отдельные выходы для левого и правого акустического канала, выход на фронтальные и тыльные колонки и т. д. однако, чтобы услышать звук из самых простых динамиков или наушников, достаточно подключить их к акустическому выходу.
сегодня выбрать подходящее звуковое решение просто. на многих материнских платах реализованы высококачественные звуковые контроллеры спецификации 7.1, работающие со всеми существующими звуковыми стандартами; если такое решение не устраивает, можно приобрести внешнее звуковое устройство - качественнее его ничего нет.
2.2. внешние устройства
внешние компьютерные комплектующие завершают формирование того, что в итоге называется компьютером. сегодня существует большое количество таких устройств, разнообразных по исполнению и назначению. без некоторых из них работа компьютера невозможна, другие делают работу комфортнее, а третьи позволяют хозяину компьютера выделиться из массы пользователей.
монитор
монитор - это устройство, которое служит для отображения текстовой и графической информации, поступающей от видеокарты.
сегодня наиболее распространены два типа мониторов: с электронно-лучевой трубкой (элт-мониторы) и жидкокристаллические (жк-мониторы).
при выборе монитора для домашнего компьютера стоит отдать препочтение жидкокристаллическому.
элт-мониторы (рис. 2.33), в основе которых лежит электронно-лучевая трубка, до сих пор можно увидеть у многих пользователей. это самый ранний тип дисплеев.
рис. 2.33. элт-монитор
для создания изображения в таком мониторе используется электронная пушка. она выстреливает поток электронов, которые проходят через металлическую сетку и попадают на внутреннюю поверхность стеклянного экрана, покрытую люминофором. в результате энергия электронов заставляет светиться точки люминофора, которые формируют изображение на экране.
элт-мониторы - громоздкие и тяжелые. например, средний 17-дюймовый монитор весит около 15 кг.
данный тип монитора имеет мало плюсов. из минусов же можно отметить вредное влияние на здоровье человека. в первую очередь страдают глаза, во вторую - все, на чем сказывается электромагнитное излучение электронной трубки. к тому же элт-монитор однозначно проигрывает жк-монитору с эстетической точки зрения.
жидкокристаллические мониторы. сегодня компьютерный рынок предлагает жидкокристаллические мониторы (рис. 2.34) любых размеров и марок. пользователи предпочитают именно этот тип дисплеев.
рис. 2.34. внешний вид жк-монитора
в жк-мониторе не используется электронно-лучевая трубка, поэтому он не является источником электронно-магнитных волн, которые отрицательно влияют на здоровье. такой монитор занимает мало места на рабочем столе, его можно повесить на стену. он также потребляет намного меньше электроэнергии.
в таких мониторах используется свойство жидких кристаллов упорядочиваться под воздействием электрического поля и изменять угол поляризации проходящего через них света. панель монитора состоит из двух прозрачных пластин, между которыми находятся жидкие кристаллы. снаружи на пластины нанесены тонкие прозрачные параллельные электроды. на одной пластине они вертикальные, на другой - горизонтальные. получается объемная координатная сетка. если пропустить ток по одному вертикальному и одному горизонтальному проводникам, то в ячейке, находящейся между ними, возникает электрическое поле, проходящее через слой жидких кристаллов. регулируя это поле, можно частично или полностью перекрывать свет.
для формирования одной точки используются три ячейки, свет из которых проходит через красный, синий и зеленый светофильтры. в зависимости от интенсивности света, идущего через каждую ячейку, точка экрана окрашивается в определенный цвет.
преимущества жк-монитора неоспоримы. небольшой вес, отличное качество изображения, отсутствие вредного излучения, высокое разрешение экрана - это далеко не все. последние модели жк-мониторов обладают быстрой матрицей, которая позволяет обновлять точки со скоростью 2 мс. раньше именно медленная матрица и дороговизна жк-мониторов препятствовали их широкому распространению, однако сегодня ситуация изменилась.
минусом этого типа мониторов можно считать угол обзора. идеальным считается угол, близкий к прямому (90); если угол слишком маленький или большой, изображение на экране кажется мутным или искаженным по цвету. в дорогих моделях жк-мониторов этот недостаток практически незаметен, однако существует.
технические особенности мониторов. выбирая монитор, нужно обращать внимание на несколько основных характеристик.
 размер диагонали. он определяет, сколько информации будет отображаться на экране. это имеет большое значение, особенно для пользователей, которые любят просматривать содержимое открытого окна, не используя полосы прокрутки.
самые распространенные - мониторы с диагональю 19 дюймов. однако, если вы занимаетесь программированием, обработкой большого изображения и т. п., лучше приобрести монитор с диагональю 20-21 дюйм.
